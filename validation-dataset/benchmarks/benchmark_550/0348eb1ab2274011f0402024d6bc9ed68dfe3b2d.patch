From 0348eb1ab2274011f0402024d6bc9ed68dfe3b2d Mon Sep 17 00:00:00 2001
From: Mark Stoodley <mstoodle@ca.ibm.com>
Date: Thu, 18 May 2017 15:20:25 -0400
Subject: [PATCH] Do not allocate args space for leaf methods on X86

For AMD64, we try to 16-byte align the entry stack pointer for
called methods by allocating space in the caller's frame to
compensate for the return address pushed on the stack by a call.

For leaf methods, there will be no calls, and so there's no
reason to consider 8 bytes being added for a return address
and then to align that 8 bytes to 16 bytes. This commit
uses the fact that the current method is a leaf method to
avoid adding 16 bytes to the stack pointer, which in some
small methods means no stack frame is actually needed.

Signed-off-by: Mark Stoodley <mstoodle@ca.ibm.com>
---
 compiler/x/codegen/X86SystemLinkage.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/compiler/x/codegen/X86SystemLinkage.cpp b/compiler/x/codegen/X86SystemLinkage.cpp
index 31e36651e5..e63d001389 100644
--- a/compiler/x/codegen/X86SystemLinkage.cpp
+++ b/compiler/x/codegen/X86SystemLinkage.cpp
@@ -470,7 +470,7 @@ TR::X86SystemLinkage::createPrologue(TR::Instruction *cursor)
       + ( properties.getAlwaysDedicateFramePointerRegister() ? properties.getGPRWidth() : 0);
 
    uint32_t adjust = 0;
-   if (_properties.getOutgoingArgAlignment())
+   if (_properties.getOutgoingArgAlignment() && !cg()->isLeafMethod())
       {
       // AMD64 SysV spec requires: The end of the input argument area shall be aligned on a 16 (32, if __m256 is passed on stack) byte boundary. In other words, the value (%rsp + 8) is always a multiple of 16 (32) when control is transferred to the function entry point.
       TR_ASSERT(_properties.getOutgoingArgAlignment() == 16 || _properties.getOutgoingArgAlignment() == 4, "AMD64 SysV linkage require outgoingArgAlignment be 16/32 bytes aligned, while IA32 linkage require 4 bytes aligned.  We currently haven't support 32 bytes alignment for AMD64 SysV ABI yet.\n");
