From 5186118e0d19b9541743241ea3b12f1eb22d7272 Mon Sep 17 00:00:00 2001
From: David Korth <gerbilsoft@gerbilsoft.com>
Date: Sun, 3 Dec 2017 15:38:38 -0500
Subject: [PATCH] [librpbase] ImageDecoder_ETC1.cpp::decodeBlock_ETC2_alpha():
 Use argb32_t to apply the alpha channel.

This eliminates the mask and shift. Granted, both gcc and MSVC optimized
them into other instructions, but this does eliminate those, too.
---
 src/librpbase/img/ImageDecoder_ETC1.cpp | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/src/librpbase/img/ImageDecoder_ETC1.cpp b/src/librpbase/img/ImageDecoder_ETC1.cpp
index 0af03899f8..c38c4b8f3c 100644
--- a/src/librpbase/img/ImageDecoder_ETC1.cpp
+++ b/src/librpbase/img/ImageDecoder_ETC1.cpp
@@ -740,6 +740,9 @@ rp_image *ImageDecoder::fromETC2_RGB(int width, int height,
  */
 static void decodeBlock_ETC2_alpha(uint32_t tileBuf[4*4], const etc2_alpha *alpha)
 {
+	// argb32_t for alpha channel handling.
+	argb32_t *const pArgb = reinterpret_cast<argb32_t*>(tileBuf);
+
 	// Get the base codeword and multiplier.
 	// NOTE: mult == 0 is not allowed to be used by the encoder,
 	// but the specification requires decoders to handle it.
@@ -763,10 +766,8 @@ static void decodeBlock_ETC2_alpha(uint32_t tileBuf[4*4], const etc2_alpha *alph
 			A = 0;
 		}
 
-		// Apply the new alpha value.
-		uint32_t *const p = &tileBuf[etc1_mapping[i]];
-		*p &= ~0xFF000000U;
-		*p |= (A << 24);
+		// Set the new alpha value.
+		pArgb[etc1_mapping[i]].a = (uint8_t)A;
 	}
 }
 
