From fd52b5a20473d48fec2891b6a5adf3d25d009767 Mon Sep 17 00:00:00 2001
From: Timothy Simpson <simpsont@objectcomputing.com>
Date: Mon, 8 Apr 2019 10:29:27 -0500
Subject: [PATCH] moving value clamping before index / bit calculations, which
 can then be made const values

---
 dds/DCPS/DisjointSequence.cpp | 15 ++++++---------
 1 file changed, 6 insertions(+), 9 deletions(-)

diff --git a/dds/DCPS/DisjointSequence.cpp b/dds/DCPS/DisjointSequence.cpp
index e09605856c8..65321b2a5ab 100644
--- a/dds/DCPS/DisjointSequence.cpp
+++ b/dds/DCPS/DisjointSequence.cpp
@@ -236,21 +236,18 @@ DisjointSequence::fill_bitmap_range(CORBA::ULong low, CORBA::ULong high,
                                     CORBA::ULong& num_bits)
 {
   bool clamped = false;
-  CORBA::ULong idx_nb = num_bits / 32, bit_nb = num_bits % 32,
-               idx_low = low / 32, bit_low = low % 32,
-               idx_high = high / 32, bit_high = high % 32;
-
-  if (idx_low >= length) {
+  if ((low / 32) >= length) {
     return false;
   }
-  if (idx_high >= length) {
-    // clamp to largest number we can represent
+  if ((high / 32) >= length) {
     high = length * 32 - 1;
-    idx_high = length - 1;
-    bit_high = high % 32;
     clamped = true;
   }
 
+  const CORBA::ULong idx_nb = num_bits / 32, bit_nb = num_bits % 32,
+                     idx_low = low / 32, bit_low = low % 32,
+                     idx_high = high / 32, bit_high = high % 32;
+
   static const CORBA::Long MNSLI = 0x80000000; // most negative signed long integer
 
   // handle idx_nb zeros
