From 98f0b1a35836ce79f44a48171dfcebb497e98eb9 Mon Sep 17 00:00:00 2001
From: Matthias Kramm <kramm@google.com>
Date: Wed, 13 Jun 2018 18:17:54 -0700
Subject: [PATCH] always use inline implementation of clz

---
 src/CodeGen_C.cpp | 13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)

diff --git a/src/CodeGen_C.cpp b/src/CodeGen_C.cpp
index b7d61fcf3d..328aaf83b6 100644
--- a/src/CodeGen_C.cpp
+++ b/src/CodeGen_C.cpp
@@ -117,6 +117,16 @@ inline float float_from_bits(uint32_t bits) {
     return reinterpret<float, uint32_t>(bits);
 }
 
+template<typename T>
+inline uint8_t halide_count_leading_zeros(T v) {
+    int bits = sizeof(v) * 8;
+    while (v) {
+        v >>= 1;
+        bits--;
+    }
+    return bits;
+}
+
 template<typename T>
 inline T halide_cpp_max(const T &a, const T &b) {return (a > b) ? a : b;}
 
@@ -1951,8 +1961,7 @@ void CodeGen_C::visit(const Call *op) {
     } else if (op->is_intrinsic(Call::count_leading_zeros)) {
         internal_assert(op->args.size() == 1);
         string a0 = print_expr(op->args[0]);
-        rhs << "(__builtin_clzll(" << a0 << ") - (sizeof(unsigned long long) * 8 - " <<
-                op->args[0].type().bits() << "))";
+        rhs << "halide_count_leading_zeros(" << a0 << ")";
     } else if (op->is_intrinsic(Call::lerp)) {
         internal_assert(op->args.size() == 3);
         Expr e = lower_lerp(op->args[0], op->args[1], op->args[2]);
