From a516e94cf159b9ea02af31872fc59b7ceeef7965 Mon Sep 17 00:00:00 2001
From: Jakob Stoklund Olesen <stoklund@2pi.dk>
Date: Tue, 10 Aug 2010 21:16:16 +0000
Subject: [PATCH] Give up on register class recalculation when the register is
 used with subreg operands. We don't currently have a hook to provide "the
 largest super class of A where all registers' getSubReg(subidx) is valid and
 in B".

git-svn-id: https://llvm.org/svn/llvm-project/llvm/trunk@110730 91177308-0d34-0410-b5e6-96231b3b80d8
---
 lib/CodeGen/CalcSpillWeights.cpp | 11 ++++++++++-
 1 file changed, 10 insertions(+), 1 deletion(-)

diff --git a/lib/CodeGen/CalcSpillWeights.cpp b/lib/CodeGen/CalcSpillWeights.cpp
index a39503ba2ee..8ecce4a3fbe 100644
--- a/lib/CodeGen/CalcSpillWeights.cpp
+++ b/lib/CodeGen/CalcSpillWeights.cpp
@@ -181,10 +181,19 @@ void VirtRegAuxInfo::CalculateRegClass(unsigned reg) {
   SmallPtrSet<const TargetRegisterClass*,8> rcs;
 
   for (MachineRegisterInfo::reg_nodbg_iterator I = mri.reg_nodbg_begin(reg),
-       E = mri.reg_nodbg_end(); I != E; ++I)
+       E = mri.reg_nodbg_end(); I != E; ++I) {
+    // The targets don't have accurate enough regclass descriptions that we can
+    // handle subregs. We need something similar to
+    // TRI::getMatchingSuperRegClass, but returning a super class instead of a
+    // sub class.
+    if (I.getOperand().getSubReg()) {
+      DEBUG(dbgs() << "Cannot handle subregs: " << I.getOperand() << '\n');
+      return;
+    }
     if (const TargetRegisterClass *rc =
                                 I->getDesc().getRegClass(I.getOperandNo(), tri))
       rcs.insert(rc);
+  }
 
   // If we found no regclass constraints, just leave reg as is.
   // In theory, we could inflate to the largest superclass of reg's existing
