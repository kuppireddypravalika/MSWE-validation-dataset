From 54b7a43b95fa23af0b2ce97a6913e16351b076d7 Mon Sep 17 00:00:00 2001
From: Ryan Houdek <Sonicadvance1@gmail.com>
Date: Sun, 16 Jul 2023 18:52:34 -0700
Subject: [PATCH] ArmEmitter: Support 32-bit bitmask moves

Noticed this when inspecting some code that was moving constant
`0x80808080` in to a register. Was using two move instructions when it
could have used a single bitmask move.

This now checks to see if a constant can be 32-bit encoded in a logical
bitmask move and uses that.
---
 .../Interface/Core/ArchHelpers/Arm64Emitter.cpp | 17 +++++++++++++++++
 1 file changed, 17 insertions(+)

diff --git a/External/FEXCore/Source/Interface/Core/ArchHelpers/Arm64Emitter.cpp b/External/FEXCore/Source/Interface/Core/ArchHelpers/Arm64Emitter.cpp
index 10ca7596b0..d6ba2f3e9f 100644
--- a/External/FEXCore/Source/Interface/Core/ArchHelpers/Arm64Emitter.cpp
+++ b/External/FEXCore/Source/Interface/Core/ArchHelpers/Arm64Emitter.cpp
@@ -192,6 +192,23 @@ void Arm64Emitter::LoadConstant(ARMEmitter::Size s, ARMEmitter::Register Reg, ui
     return;
   }
 
+  if ((Constant >> 32) == 0) {
+    // If the upper 32-bits is all zero, we can now switch to a 32-bit move.
+    s = ARMEmitter::Size::i32Bit;
+    Is64Bit = false;
+    Segments = 2;
+  }
+
+  // If this can be loaded with a mov bitmask.
+  const auto IsImm = vixl::aarch64::Assembler::IsImmLogical(Constant, RegSizeInBits(s));
+  if (IsImm) {
+    orr(s, Reg, ARMEmitter::Reg::zr, Constant);
+    if (NOPPad) {
+      nop(); nop(); nop();
+    }
+    return;
+  }
+
   int NumMoves = 1;
   int RequiredMoveSegments{};
 
