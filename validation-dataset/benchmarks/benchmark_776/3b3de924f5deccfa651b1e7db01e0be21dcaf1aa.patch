From 3b3de924f5deccfa651b1e7db01e0be21dcaf1aa Mon Sep 17 00:00:00 2001
From: Daniel Dunbar <daniel@zuster.org>
Date: Tue, 18 Aug 2009 22:24:00 +0000
Subject: [PATCH] Speed up raw_ostream::<<(unsigned long long) for 32-bit
 systems by doing most div/mods in 32-bits.

git-svn-id: https://llvm.org/svn/llvm-project/llvm/trunk@79375 91177308-0d34-0410-b5e6-96231b3b80d8
---
 lib/Support/raw_ostream.cpp | 25 +++++++++++++++----------
 1 file changed, 15 insertions(+), 10 deletions(-)

diff --git a/lib/Support/raw_ostream.cpp b/lib/Support/raw_ostream.cpp
index 0c1843c457c..ac9bc6418f4 100644
--- a/lib/Support/raw_ostream.cpp
+++ b/lib/Support/raw_ostream.cpp
@@ -125,19 +125,24 @@ raw_ostream &raw_ostream::operator<<(long N) {
 }
 
 raw_ostream &raw_ostream::operator<<(unsigned long long N) {
-  // Output using 32-bit div/mod when possible.
+  // Handle simple case when value fits in long already.
   if (N == static_cast<unsigned long>(N))
     return this->operator<<(static_cast<unsigned long>(N));
 
-  char NumberBuffer[20];
-  char *EndPtr = NumberBuffer+sizeof(NumberBuffer);
-  char *CurPtr = EndPtr;
-  
-  while (N) {
-    *--CurPtr = '0' + char(N % 10);
-    N /= 10;
-  }
-  return write(CurPtr, EndPtr-CurPtr);
+  // Otherwise divide into at two or three 10**9 chunks and write out using
+  // long div/mod, this is substantially faster on a 32-bit system.
+  unsigned long Top = 0, Mid = 0, Bot = N % 1000000000;
+  N /= 1000000000;
+  if (N > 1000000000) {
+    Mid = N % 1000000000;
+    Top = N / 1000000000;
+  } else
+    Mid = N;
+
+  if (Top)
+    this->operator<<(static_cast<unsigned long>(Top));
+  this->operator<<(static_cast<unsigned long>(Mid));
+  return this->operator<<(static_cast<unsigned long>(Bot));
 }
 
 raw_ostream &raw_ostream::operator<<(long long N) {
