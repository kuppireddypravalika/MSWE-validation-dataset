From 26e51ba5cd8cd0c6c60795884c2f9913f526d11d Mon Sep 17 00:00:00 2001
From: David Gobbi <david.gobbi@gmail.com>
Date: Thu, 17 Oct 2002 10:20:25 -0400
Subject: [PATCH] ENH: use C Volpe's fast floor() code for i386, previous code
 had rounding errors at the 2**(-16) bit.

---
 Imaging/vtkImageReslice.cxx | 14 ++++++++++----
 1 file changed, 10 insertions(+), 4 deletions(-)

diff --git a/Imaging/vtkImageReslice.cxx b/Imaging/vtkImageReslice.cxx
index 3d0b10e44c8..722e074d685 100644
--- a/Imaging/vtkImageReslice.cxx
+++ b/Imaging/vtkImageReslice.cxx
@@ -26,7 +26,7 @@
 #include <float.h>
 #include <math.h>
 
-vtkCxxRevisionMacro(vtkImageReslice, "1.29");
+vtkCxxRevisionMacro(vtkImageReslice, "1.30");
 vtkStandardNewMacro(vtkImageReslice);
 vtkCxxSetObjectMacro(vtkImageReslice, InformationInput, vtkImageData);
 
@@ -741,9 +741,15 @@ inline int vtkResliceFloor(double x)
 #if defined mips || defined sparc
   return (int)((unsigned int)(x + 2147483648.0) - 2147483648U);
 #elif defined i386 || defined _M_IX86
-  unsigned int hilo[2];
-  *((double *)hilo) = x + 103079215104.0;  // (2**(52-16))*1.5
-  return (int)((hilo[1]<<16)|(hilo[0]>>16));
+  double tempval;
+  // use 52-bit precision of IEEE double to round (x - 0.25) to 
+  // the nearest multiple of 0.5, according to prevailing rounding
+  // mode which is IEEE round-to-nearest,even
+  tempval = (x - 0.25) + 3377699720527872.0; // (2**51)*1.5
+  // extract mantissa, use shift to divide by 2 and hence get rid
+  // of the bit that gets messed up because the FPU uses
+  // round-to-nearest,even mode instead of round-to-nearest,+infinity
+  return ((int*)&tempval)[0] >> 1;
 #else
   return int(floor(x));
 #endif
