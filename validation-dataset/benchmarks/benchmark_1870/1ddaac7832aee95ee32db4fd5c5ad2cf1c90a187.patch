From 1ddaac7832aee95ee32db4fd5c5ad2cf1c90a187 Mon Sep 17 00:00:00 2001
From: weihongkai2008 <weihongkai2008@hotmail.com>
Date: Sat, 27 Mar 2021 18:59:50 +0800
Subject: [PATCH] [Compaction] Optimize cumulative compaction point calculate
 when after restart be (#5561)

This pr is to reduce a large number of useless cumulative compactions caused by
cumulative compaction point calculation problems after be restarts.
---
 be/src/olap/cumulative_compaction_policy.cpp | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/be/src/olap/cumulative_compaction_policy.cpp b/be/src/olap/cumulative_compaction_policy.cpp
index 1f026aba70..e6e9392121 100644
--- a/be/src/olap/cumulative_compaction_policy.cpp
+++ b/be/src/olap/cumulative_compaction_policy.cpp
@@ -83,8 +83,8 @@ void SizeBasedCumulativeCompactionPolicy::calculate_cumulative_point(
 
         bool is_delete = tablet->version_for_delete_predicate(rs->version());
 
-        // break the loop if segments in this rowset is overlapping, or is a singleton.
-        if (!is_delete && (rs->is_segments_overlapping() || rs->is_singleton_delta())) {
+        // break the loop if segments in this rowset is overlapping.
+        if (!is_delete && rs->is_segments_overlapping()) {
             *ret_cumulative_point = rs->version().first;
             break;
         }
@@ -95,6 +95,7 @@ void SizeBasedCumulativeCompactionPolicy::calculate_cumulative_point(
             break;
         }
 
+        // include one situation: When the segment is not deleted, and is singleton delta, and is NONOVERLAPPING, ret_cumulative_point increase 
         prev_version = rs->version().second;
         *ret_cumulative_point = prev_version + 1;
     }
