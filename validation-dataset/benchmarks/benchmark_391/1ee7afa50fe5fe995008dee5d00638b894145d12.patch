From 1ee7afa50fe5fe995008dee5d00638b894145d12 Mon Sep 17 00:00:00 2001
From: Ulf Hermann <ulf.hermann@qt.io>
Date: Thu, 16 May 2019 14:15:06 +0200
Subject: [PATCH] Re-add cache for looking up attached properties objects

c018df5b4075ae962966d4df7653d476dab02840 removed an optimization in
qmlAttachedPropertiesObject. The attached properties ID was implicitly
cached as it was static in a method templated by the type the attached
properties were registered for. We don't actually need the ID for this,
as we can also cache the function pointer.

Fixes: QTBUG-75609
Change-Id: I15e728ce4bbb89062a84ee6f113b1188faa32b92
Reviewed-by: Simon Hausmann <simon.hausmann@qt.io>
---
 src/qml/qml/qqml.h | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/src/qml/qml/qqml.h b/src/qml/qml/qqml.h
index 9eacc5bc223..ebf4817b4a5 100644
--- a/src/qml/qml/qqml.h
+++ b/src/qml/qml/qqml.h
@@ -605,9 +605,12 @@ Q_QML_EXPORT void qmlRegisterModule(const char *uri, int versionMajor, int versi
 template<typename T>
 QObject *qmlAttachedPropertiesObject(const QObject *obj, bool create = true)
 {
-    QObject *mutableObj = const_cast<QObject *>(obj);
-    return qmlAttachedPropertiesObject(
-            mutableObj, qmlAttachedPropertiesFunction(mutableObj, &T::staticMetaObject), create);
+    // We don't need a concrete object to resolve the function. As T is a C++ type, it and all its
+    // super types should be registered as CppType (or not at all). We only need the object and its
+    // QML engine to resolve composite types. Therefore, the function is actually a static property
+    // of the C++ type system and we can cache it here for improved performance on further lookups.
+    static const auto func = qmlAttachedPropertiesFunction(nullptr, &T::staticMetaObject);
+    return qmlAttachedPropertiesObject(const_cast<QObject *>(obj), func, create);
 }
 
 Q_QML_EXPORT void qmlRegisterBaseTypes(const char *uri, int versionMajor, int versionMinor);
