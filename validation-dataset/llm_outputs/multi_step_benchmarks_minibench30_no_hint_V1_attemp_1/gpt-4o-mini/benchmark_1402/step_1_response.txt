{
  "optimized_code": "#include \"tensor.hpp\"\n#include <algorithm>\n#include <vector>\n#include <limits>\n\nvoid topk(const Tensor<float>& input, Tensor<float>& output, Tensor<int64_t>& indices, std::size_t k) {\n    std::size_t row = input.rows;\n    std::size_t col = input.cols;\n    for (std::size_t i = 0; i < row; ++i) {\n        // Use a min-heap to store the top k elements\n        std::vector<std::pair<float, std::size_t>> vec;\n        vec.reserve(k);\n        for (std::size_t j = 0; j < k; ++j) {\n            vec.emplace_back(input(i, j), j);\n        }\n        // Process remaining elements\n        for (std::size_t j = k; j < col; ++j) {\n            if (input(i, j) > vec.front().first) {\n                std::pop_heap(vec.begin(), vec.end(), std::greater<>());\n                vec.pop_back();\n                vec.emplace_back(input(i, j), j);\n                std::push_heap(vec.begin(), vec.end(), std::greater<>());\n            }\n        }\n        // Sort the top k results\n        std::sort(vec.begin(), vec.end(), std::greater<>());\n        for (std::size_t j = 0; j < k; ++j) {\n            output(i, j) = vec[j].first;\n            indices(i, j) = static_cast<int64_t>(vec[j].second);\n        }\n    }\n}\n\n\n// Explicit template instantiations\n#include <string>\ntemplate struct Tensor<float>;\ntemplate struct Tensor<int64_t>;",
  "analysis": "The optimizations focus on reducing the time complexity of the top-k selection by using a min-heap approach instead of the full vector sort. This change avoids the need to sort all elements in the row and instead maintains only the top k elements. This reduces the number of comparisons and movements required, likely leading to significant performance improvements, especially for larger column sizes."
}