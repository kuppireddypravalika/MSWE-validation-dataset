{"org": "catchorg", "repo": "Catch2", "number": 2849, "state": "closed", "title": "Handle ANSI escape sequences when performing column wrapping", "body": "## Description\r\nThis PR adds functionality to skip around ANSI escape sequences in catch_textflow so they do not contribute to line length and line wrapping code does not split escape sequences in the middle. I've implemented this by creating a `AnsiSkippingString` abstraction that has a bidirectional iterator that can skip around escape sequences while iterating. Additionally I refactored `Column::const_iterator` to be iterator-based rather than index-based so this abstraction is a simple drop-in for `std::string`.\r\n\r\nCurrently only color sequences are handled, other escape sequences are left unaffected.\r\n\r\nMotivation: Text with ANSI color sequences gets messed up when being output by Catch2 #2833.\r\n\r\n\r\nFor example, the current behavior of string with lots of escapes:\r\n![image](https://github.com/catchorg/Catch2/assets/51220084/fbd9320f-2ca9-45ae-b741-ae00679c572c)\r\nThe example I have handy is a syntax-highlighted assertion from another library.\r\n\r\nBehavior with this PR:\r\n![image](https://github.com/catchorg/Catch2/assets/51220084/0a60148b-9e3b-4d9f-bade-da094be6e9c1)\r\n\r\n\r\n\r\n## GitHub Issues\r\nCloses #2833", "base": {"label": "catchorg:devel", "ref": "devel", "sha": "7ce35799767de7b9c6ba836c72e479c5f70219a3"}, "resolved_issues": [{"number": 2833, "title": "Handle ANSI escape sequences during text wrapping", "body": "**Description**\r\n\r\nI'd like to provide diagnostic messages from a `Catch::Matchers::MatcherBase::describe` function that are colored with ANSI sequences, however Catch2's line wrapping interferes with this.\r\n\r\nWould a PR to update the line wrapping logic be welcomed?\r\n\r\n**Additional context**\r\n\r\nI have an assertion library that I'd like to provide a catch2 integration for. Without color codes, with my current attempt to make it work in Catch2, it looks like this:\r\n\r\n![image](https://github.com/catchorg/Catch2/assets/51220084/4f410b0c-a0c4-472d-935a-37e0068770ba)\r\n\r\nHowever with color codes the lines are messed up and escape sequences are split in the middle:\r\n\r\n![image](https://github.com/catchorg/Catch2/assets/51220084/a600caf7-f047-4c66-90cf-dd41f9eef258)"}], "fix_patch": "diff --git a/src/catch2/internal/catch_textflow.cpp b/src/catch2/internal/catch_textflow.cpp\nindex 857fd2b9f4..1c21d20e56 100644\n--- a/src/catch2/internal/catch_textflow.cpp\n+++ b/src/catch2/internal/catch_textflow.cpp\n@@ -26,117 +26,228 @@ namespace {\n         return std::memchr( chars, c, sizeof( chars ) - 1 ) != nullptr;\n     }\n \n-    bool isBoundary( std::string const& line, size_t at ) {\n-        assert( at > 0 );\n-        assert( at <= line.size() );\n-\n-        return at == line.size() ||\n-               ( isWhitespace( line[at] ) && !isWhitespace( line[at - 1] ) ) ||\n-               isBreakableBefore( line[at] ) ||\n-               isBreakableAfter( line[at - 1] );\n-    }\n-\n } // namespace\n \n namespace Catch {\n     namespace TextFlow {\n+        void AnsiSkippingString::preprocessString() {\n+            for ( auto it = m_string.begin(); it != m_string.end(); ) {\n+                // try to read through an ansi sequence\n+                while ( it != m_string.end() && *it == '\\033' &&\n+                        it + 1 != m_string.end() && *( it + 1 ) == '[' ) {\n+                    auto cursor = it + 2;\n+                    while ( cursor != m_string.end() &&\n+                            ( isdigit( *cursor ) || *cursor == ';' ) ) {\n+                        ++cursor;\n+                    }\n+                    if ( cursor == m_string.end() || *cursor != 'm' ) {\n+                        break;\n+                    }\n+                    // 'm' -> 0xff\n+                    *cursor = AnsiSkippingString::sentinel;\n+                    // if we've read an ansi sequence, set the iterator and\n+                    // return to the top of the loop\n+                    it = cursor + 1;\n+                }\n+                if ( it != m_string.end() ) {\n+                    ++m_size;\n+                    ++it;\n+                }\n+            }\n+        }\n+\n+        AnsiSkippingString::AnsiSkippingString( std::string const& text ):\n+            m_string( text ) {\n+            preprocessString();\n+        }\n+\n+        AnsiSkippingString::AnsiSkippingString( std::string&& text ):\n+            m_string( CATCH_MOVE( text ) ) {\n+            preprocessString();\n+        }\n+\n+        AnsiSkippingString::const_iterator AnsiSkippingString::begin() const {\n+            return const_iterator( m_string );\n+        }\n+\n+        AnsiSkippingString::const_iterator AnsiSkippingString::end() const {\n+            return const_iterator( m_string, const_iterator::EndTag{} );\n+        }\n+\n+        std::string AnsiSkippingString::substring( const_iterator begin,\n+                                                   const_iterator end ) const {\n+            // There's one caveat here to an otherwise simple substring: when\n+            // making a begin iterator we might have skipped ansi sequences at\n+            // the start. If `begin` here is a begin iterator, skipped over\n+            // initial ansi sequences, we'll use the true beginning of the\n+            // string. Lastly: We need to transform any chars we replaced with\n+            // 0xff back to 'm'\n+            auto str = std::string( begin == this->begin() ? m_string.begin()\n+                                                           : begin.m_it,\n+                                    end.m_it );\n+            std::transform( str.begin(), str.end(), str.begin(), []( char c ) {\n+                return c == AnsiSkippingString::sentinel ? 'm' : c;\n+            } );\n+            return str;\n+        }\n+\n+        void AnsiSkippingString::const_iterator::tryParseAnsiEscapes() {\n+            // check if we've landed on an ansi sequence, and if so read through\n+            // it\n+            while ( m_it != m_string->end() && *m_it == '\\033' &&\n+                    m_it + 1 != m_string->end() &&  *( m_it + 1 ) == '[' ) {\n+                auto cursor = m_it + 2;\n+                while ( cursor != m_string->end() &&\n+                        ( isdigit( *cursor ) || *cursor == ';' ) ) {\n+                    ++cursor;\n+                }\n+                if ( cursor == m_string->end() ||\n+                     *cursor != AnsiSkippingString::sentinel ) {\n+                    break;\n+                }\n+                // if we've read an ansi sequence, set the iterator and\n+                // return to the top of the loop\n+                m_it = cursor + 1;\n+            }\n+        }\n+\n+        void AnsiSkippingString::const_iterator::advance() {\n+            assert( m_it != m_string->end() );\n+            m_it++;\n+            tryParseAnsiEscapes();\n+        }\n+\n+        void AnsiSkippingString::const_iterator::unadvance() {\n+            assert( m_it != m_string->begin() );\n+            m_it--;\n+            // if *m_it is 0xff, scan back to the \\033 and then m_it-- once more\n+            // (and repeat check)\n+            while ( *m_it == AnsiSkippingString::sentinel ) {\n+                while ( *m_it != '\\033' ) {\n+                    assert( m_it != m_string->begin() );\n+                    m_it--;\n+                }\n+                // if this happens, we must have been a begin iterator that had\n+                // skipped over ansi sequences at the start of a string\n+                assert( m_it != m_string->begin() );\n+                assert( *m_it == '\\033' );\n+                m_it--;\n+            }\n+        }\n+\n+        static bool isBoundary( AnsiSkippingString const& line,\n+                                AnsiSkippingString::const_iterator it ) {\n+            return it == line.end() ||\n+                   ( isWhitespace( *it ) &&\n+                     !isWhitespace( *it.oneBefore() ) ) ||\n+                   isBreakableBefore( *it ) ||\n+                   isBreakableAfter( *it.oneBefore() );\n+        }\n \n         void Column::const_iterator::calcLength() {\n             m_addHyphen = false;\n             m_parsedTo = m_lineStart;\n+            AnsiSkippingString const& current_line = m_column.m_string;\n \n-            std::string const& current_line = m_column.m_string;\n-            if ( current_line[m_lineStart] == '\\n' ) {\n-                ++m_parsedTo;\n+            if ( m_parsedTo == current_line.end() ) {\n+                m_lineEnd = m_parsedTo;\n+                return;\n             }\n \n+            assert( m_lineStart != current_line.end() );\n+            if ( *m_lineStart == '\\n' ) { ++m_parsedTo; }\n+\n             const auto maxLineLength = m_column.m_width - indentSize();\n-            const auto maxParseTo = std::min(current_line.size(), m_lineStart + maxLineLength);\n-            while ( m_parsedTo < maxParseTo &&\n-                    current_line[m_parsedTo] != '\\n' ) {\n+            std::size_t lineLength = 0;\n+            while ( m_parsedTo != current_line.end() &&\n+                    lineLength < maxLineLength && *m_parsedTo != '\\n' ) {\n                 ++m_parsedTo;\n+                ++lineLength;\n             }\n \n             // If we encountered a newline before the column is filled,\n             // then we linebreak at the newline and consider this line\n             // finished.\n-            if ( m_parsedTo < m_lineStart + maxLineLength ) {\n-                m_lineLength = m_parsedTo - m_lineStart;\n+            if ( lineLength < maxLineLength ) {\n+                m_lineEnd = m_parsedTo;\n             } else {\n                 // Look for a natural linebreak boundary in the column\n                 // (We look from the end, so that the first found boundary is\n                 // the right one)\n-                size_t newLineLength = maxLineLength;\n-                while ( newLineLength > 0 && !isBoundary( current_line, m_lineStart + newLineLength ) ) {\n-                    --newLineLength;\n+                m_lineEnd = m_parsedTo;\n+                while ( lineLength > 0 &&\n+                        !isBoundary( current_line, m_lineEnd ) ) {\n+                    --lineLength;\n+                    --m_lineEnd;\n                 }\n-                while ( newLineLength > 0 &&\n-                        isWhitespace( current_line[m_lineStart + newLineLength - 1] ) ) {\n-                    --newLineLength;\n+                while ( lineLength > 0 &&\n+                        isWhitespace( *m_lineEnd.oneBefore() ) ) {\n+                    --lineLength;\n+                    --m_lineEnd;\n                 }\n \n-                // If we found one, then that is where we linebreak\n-                if ( newLineLength > 0 ) {\n-                    m_lineLength = newLineLength;\n-                } else {\n-                    // Otherwise we have to split text with a hyphen\n+                // If we found one, then that is where we linebreak, otherwise\n+                // we have to split text with a hyphen\n+                if ( lineLength == 0 ) {\n                     m_addHyphen = true;\n-                    m_lineLength = maxLineLength - 1;\n+                    m_lineEnd = m_parsedTo.oneBefore();\n                 }\n             }\n         }\n \n         size_t Column::const_iterator::indentSize() const {\n-            auto initial =\n-                m_lineStart == 0 ? m_column.m_initialIndent : std::string::npos;\n+            auto initial = m_lineStart == m_column.m_string.begin()\n+                               ? m_column.m_initialIndent\n+                               : std::string::npos;\n             return initial == std::string::npos ? m_column.m_indent : initial;\n         }\n \n-        std::string\n-        Column::const_iterator::addIndentAndSuffix( size_t position,\n-                                              size_t length ) const {\n+        std::string Column::const_iterator::addIndentAndSuffix(\n+            AnsiSkippingString::const_iterator start,\n+            AnsiSkippingString::const_iterator end ) const {\n             std::string ret;\n             const auto desired_indent = indentSize();\n-            ret.reserve( desired_indent + length + m_addHyphen );\n+            // ret.reserve( desired_indent + (end - start) + m_addHyphen );\n             ret.append( desired_indent, ' ' );\n-            ret.append( m_column.m_string, position, length );\n-            if ( m_addHyphen ) {\n-                ret.push_back( '-' );\n-            }\n+            // ret.append( start, end );\n+            ret += m_column.m_string.substring( start, end );\n+            if ( m_addHyphen ) { ret.push_back( '-' ); }\n \n             return ret;\n         }\n \n-        Column::const_iterator::const_iterator( Column const& column ): m_column( column ) {\n+        Column::const_iterator::const_iterator( Column const& column ):\n+            m_column( column ),\n+            m_lineStart( column.m_string.begin() ),\n+            m_lineEnd( column.m_string.begin() ),\n+            m_parsedTo( column.m_string.begin() ) {\n             assert( m_column.m_width > m_column.m_indent );\n             assert( m_column.m_initialIndent == std::string::npos ||\n                     m_column.m_width > m_column.m_initialIndent );\n             calcLength();\n-            if ( m_lineLength == 0 ) {\n-                m_lineStart = m_column.m_string.size();\n+            if ( m_lineStart == m_lineEnd ) {\n+                m_lineStart = m_column.m_string.end();\n             }\n         }\n \n         std::string Column::const_iterator::operator*() const {\n             assert( m_lineStart <= m_parsedTo );\n-            return addIndentAndSuffix( m_lineStart, m_lineLength );\n+            return addIndentAndSuffix( m_lineStart, m_lineEnd );\n         }\n \n         Column::const_iterator& Column::const_iterator::operator++() {\n-            m_lineStart += m_lineLength;\n-            std::string const& current_line = m_column.m_string;\n-            if ( m_lineStart < current_line.size() && current_line[m_lineStart] == '\\n' ) {\n-                m_lineStart += 1;\n+            m_lineStart = m_lineEnd;\n+            AnsiSkippingString const& current_line = m_column.m_string;\n+            if ( m_lineStart != current_line.end() && *m_lineStart == '\\n' ) {\n+                m_lineStart++;\n             } else {\n-                while ( m_lineStart < current_line.size() &&\n-                        isWhitespace( current_line[m_lineStart] ) ) {\n+                while ( m_lineStart != current_line.end() &&\n+                        isWhitespace( *m_lineStart ) ) {\n                     ++m_lineStart;\n                 }\n             }\n \n-            if ( m_lineStart != current_line.size() ) {\n-                calcLength();\n-            }\n+            if ( m_lineStart != current_line.end() ) { calcLength(); }\n             return *this;\n         }\n \n@@ -233,25 +344,25 @@ namespace Catch {\n             return os;\n         }\n \n-        Columns operator+(Column const& lhs, Column const& rhs) {\n+        Columns operator+( Column const& lhs, Column const& rhs ) {\n             Columns cols;\n             cols += lhs;\n             cols += rhs;\n             return cols;\n         }\n-        Columns operator+(Column&& lhs, Column&& rhs) {\n+        Columns operator+( Column&& lhs, Column&& rhs ) {\n             Columns cols;\n             cols += CATCH_MOVE( lhs );\n             cols += CATCH_MOVE( rhs );\n             return cols;\n         }\n \n-        Columns& operator+=(Columns& lhs, Column const& rhs) {\n+        Columns& operator+=( Columns& lhs, Column const& rhs ) {\n             lhs.m_columns.push_back( rhs );\n             return lhs;\n         }\n-        Columns& operator+=(Columns& lhs, Column&& rhs) {\n-            lhs.m_columns.push_back( CATCH_MOVE(rhs) );\n+        Columns& operator+=( Columns& lhs, Column&& rhs ) {\n+            lhs.m_columns.push_back( CATCH_MOVE( rhs ) );\n             return lhs;\n         }\n         Columns operator+( Columns const& lhs, Column const& rhs ) {\ndiff --git a/src/catch2/internal/catch_textflow.hpp b/src/catch2/internal/catch_textflow.hpp\nindex a78451d559..2d9d78a50a 100644\n--- a/src/catch2/internal/catch_textflow.hpp\n+++ b/src/catch2/internal/catch_textflow.hpp\n@@ -20,6 +20,107 @@ namespace Catch {\n \n         class Columns;\n \n+        /**\n+         * Abstraction for a string with ansi escape sequences that\n+         * automatically skips over escapes when iterating. Only graphical\n+         * escape sequences are considered.\n+         *\n+         * Internal representation:\n+         * An escape sequence looks like \\033[39;49m\n+         * We need bidirectional iteration and the unbound length of escape\n+         * sequences poses a problem for operator-- To make this work we'll\n+         * replace the last `m` with a 0xff (this is a codepoint that won't have\n+         * any utf-8 meaning).\n+         */\n+        class AnsiSkippingString {\n+            std::string m_string;\n+            std::size_t m_size = 0;\n+\n+            // perform 0xff replacement and calculate m_size\n+            void preprocessString();\n+\n+        public:\n+            class const_iterator;\n+            using iterator = const_iterator;\n+            // note: must be u-suffixed or this will cause a \"truncation of\n+            // constant value\" warning on MSVC\n+            static constexpr char sentinel = static_cast<char>( 0xffu );\n+\n+            explicit AnsiSkippingString( std::string const& text );\n+            explicit AnsiSkippingString( std::string&& text );\n+\n+            const_iterator begin() const;\n+            const_iterator end() const;\n+\n+            size_t size() const { return m_size; }\n+\n+            std::string substring( const_iterator begin,\n+                                   const_iterator end ) const;\n+        };\n+\n+        class AnsiSkippingString::const_iterator {\n+            friend AnsiSkippingString;\n+            struct EndTag {};\n+\n+            const std::string* m_string;\n+            std::string::const_iterator m_it;\n+\n+            explicit const_iterator( const std::string& string, EndTag ):\n+                m_string( &string ), m_it( string.end() ) {}\n+\n+            void tryParseAnsiEscapes();\n+            void advance();\n+            void unadvance();\n+\n+        public:\n+            using difference_type = std::ptrdiff_t;\n+            using value_type = char;\n+            using pointer = value_type*;\n+            using reference = value_type&;\n+            using iterator_category = std::bidirectional_iterator_tag;\n+\n+            explicit const_iterator( const std::string& string ):\n+                m_string( &string ), m_it( string.begin() ) {\n+                tryParseAnsiEscapes();\n+            }\n+\n+            char operator*() const { return *m_it; }\n+\n+            const_iterator& operator++() {\n+                advance();\n+                return *this;\n+            }\n+            const_iterator operator++( int ) {\n+                iterator prev( *this );\n+                operator++();\n+                return prev;\n+            }\n+            const_iterator& operator--() {\n+                unadvance();\n+                return *this;\n+            }\n+            const_iterator operator--( int ) {\n+                iterator prev( *this );\n+                operator--();\n+                return prev;\n+            }\n+\n+            bool operator==( const_iterator const& other ) const {\n+                return m_it == other.m_it;\n+            }\n+            bool operator!=( const_iterator const& other ) const {\n+                return !operator==( other );\n+            }\n+            bool operator<=( const_iterator const& other ) const {\n+                return m_it <= other.m_it;\n+            }\n+\n+            const_iterator oneBefore() const {\n+                auto it = *this;\n+                return --it;\n+            }\n+        };\n+\n         /**\n          * Represents a column of text with specific width and indentation\n          *\n@@ -29,10 +130,11 @@ namespace Catch {\n          */\n         class Column {\n             // String to be written out\n-            std::string m_string;\n+            AnsiSkippingString m_string;\n             // Width of the column for linebreaking\n             size_t m_width = CATCH_CONFIG_CONSOLE_WIDTH - 1;\n-            // Indentation of other lines (including first if initial indent is unset)\n+            // Indentation of other lines (including first if initial indent is\n+            // unset)\n             size_t m_indent = 0;\n             // Indentation of the first line\n             size_t m_initialIndent = std::string::npos;\n@@ -47,16 +149,19 @@ namespace Catch {\n \n                 Column const& m_column;\n                 // Where does the current line start?\n-                size_t m_lineStart = 0;\n+                AnsiSkippingString::const_iterator m_lineStart;\n                 // How long should the current line be?\n-                size_t m_lineLength = 0;\n+                AnsiSkippingString::const_iterator m_lineEnd;\n                 // How far have we checked the string to iterate?\n-                size_t m_parsedTo = 0;\n+                AnsiSkippingString::const_iterator m_parsedTo;\n                 // Should a '-' be appended to the line?\n                 bool m_addHyphen = false;\n \n                 const_iterator( Column const& column, EndTag ):\n-                    m_column( column ), m_lineStart( m_column.m_string.size() ) {}\n+                    m_column( column ),\n+                    m_lineStart( m_column.m_string.end() ),\n+                    m_lineEnd( column.m_string.end() ),\n+                    m_parsedTo( column.m_string.end() ) {}\n \n                 // Calculates the length of the current line\n                 void calcLength();\n@@ -66,8 +171,9 @@ namespace Catch {\n \n                 // Creates an indented and (optionally) suffixed string from\n                 // current iterator position, indentation and length.\n-                std::string addIndentAndSuffix( size_t position,\n-                                                size_t length ) const;\n+                std::string addIndentAndSuffix(\n+                    AnsiSkippingString::const_iterator start,\n+                    AnsiSkippingString::const_iterator end ) const;\n \n             public:\n                 using difference_type = std::ptrdiff_t;\n@@ -84,7 +190,8 @@ namespace Catch {\n                 const_iterator operator++( int );\n \n                 bool operator==( const_iterator const& other ) const {\n-                    return m_lineStart == other.m_lineStart && &m_column == &other.m_column;\n+                    return m_lineStart == other.m_lineStart &&\n+                           &m_column == &other.m_column;\n                 }\n                 bool operator!=( const_iterator const& other ) const {\n                     return !operator==( other );\n@@ -94,7 +201,7 @@ namespace Catch {\n \n             explicit Column( std::string const& text ): m_string( text ) {}\n             explicit Column( std::string&& text ):\n-                m_string( CATCH_MOVE(text)) {}\n+                m_string( CATCH_MOVE( text ) ) {}\n \n             Column& width( size_t newWidth ) & {\n                 assert( newWidth > 0 );\n@@ -125,7 +232,9 @@ namespace Catch {\n \n             size_t width() const { return m_width; }\n             const_iterator begin() const { return const_iterator( *this ); }\n-            const_iterator end() const { return { *this, const_iterator::EndTag{} }; }\n+            const_iterator end() const {\n+                return { *this, const_iterator::EndTag{} };\n+            }\n \n             friend std::ostream& operator<<( std::ostream& os,\n                                              Column const& col );\n", "test_patch": "diff --git a/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp b/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp\nindex 653f65ba4c..de03ed09af 100644\n--- a/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp\n@@ -12,6 +12,7 @@\n #include <sstream>\n \n using Catch::TextFlow::Column;\n+using Catch::TextFlow::AnsiSkippingString;\n \n namespace {\n     static std::string as_written(Column const& c) {\n@@ -198,3 +199,202 @@ TEST_CASE( \"#1400 - TextFlow::Column wrapping would sometimes duplicate words\",\n             \"  in \\n\"\n             \"  convallis posuere, libero nisi ultricies orci, nec lobortis.\");\n }\n+\n+TEST_CASE( \"TextFlow::AnsiSkippingString skips ansi sequences\",\n+           \"[TextFlow][ansiskippingstring][approvals]\" ) {\n+\n+    SECTION(\"basic string\") {\n+        std::string text = \"a\\033[38;2;98;174;239mb\\033[38mc\\033[0md\\033[me\";\n+        AnsiSkippingString str(text);\n+\n+        SECTION( \"iterates forward\" ) {\n+            auto it = str.begin();\n+            CHECK(*it == 'a');\n+            ++it;\n+            CHECK(*it == 'b');\n+            ++it;\n+            CHECK(*it == 'c');\n+            ++it;\n+            CHECK(*it == 'd');\n+            ++it;\n+            CHECK(*it == 'e');\n+            ++it;\n+            CHECK(it == str.end());\n+        }\n+        SECTION( \"iterates backwards\" ) {\n+            auto it = str.end();\n+            --it;\n+            CHECK(*it == 'e');\n+            --it;\n+            CHECK(*it == 'd');\n+            --it;\n+            CHECK(*it == 'c');\n+            --it;\n+            CHECK(*it == 'b');\n+            --it;\n+            CHECK(*it == 'a');\n+            CHECK(it == str.begin());\n+        }\n+    }\n+\n+    SECTION( \"ansi escape sequences at the start\" ) {\n+        std::string text = \"\\033[38;2;98;174;239ma\\033[38;2;98;174;239mb\\033[38mc\\033[0md\\033[me\";\n+        AnsiSkippingString str(text);\n+        auto it = str.begin();\n+        CHECK(*it == 'a');\n+        ++it;\n+        CHECK(*it == 'b');\n+        ++it;\n+        CHECK(*it == 'c');\n+        ++it;\n+        CHECK(*it == 'd');\n+        ++it;\n+        CHECK(*it == 'e');\n+        ++it;\n+        CHECK(it == str.end());\n+        --it;\n+        CHECK(*it == 'e');\n+        --it;\n+        CHECK(*it == 'd');\n+        --it;\n+        CHECK(*it == 'c');\n+        --it;\n+        CHECK(*it == 'b');\n+        --it;\n+        CHECK(*it == 'a');\n+        CHECK(it == str.begin());\n+    }\n+\n+    SECTION( \"ansi escape sequences at the end\" ) {\n+        std::string text = \"a\\033[38;2;98;174;239mb\\033[38mc\\033[0md\\033[me\\033[38;2;98;174;239m\";\n+        AnsiSkippingString str(text);\n+        auto it = str.begin();\n+        CHECK(*it == 'a');\n+        ++it;\n+        CHECK(*it == 'b');\n+        ++it;\n+        CHECK(*it == 'c');\n+        ++it;\n+        CHECK(*it == 'd');\n+        ++it;\n+        CHECK(*it == 'e');\n+        ++it;\n+        CHECK(it == str.end());\n+        --it;\n+        CHECK(*it == 'e');\n+        --it;\n+        CHECK(*it == 'd');\n+        --it;\n+        CHECK(*it == 'c');\n+        --it;\n+        CHECK(*it == 'b');\n+        --it;\n+        CHECK(*it == 'a');\n+        CHECK(it == str.begin());\n+    }\n+\n+    SECTION( \"skips consecutive escapes\" ) {\n+        std::string text = \"\\033[38;2;98;174;239m\\033[38;2;98;174;239ma\\033[38;2;98;174;239mb\\033[38m\\033[38m\\033[38mc\\033[0md\\033[me\";\n+        AnsiSkippingString str(text);\n+        auto it = str.begin();\n+        CHECK(*it == 'a');\n+        ++it;\n+        CHECK(*it == 'b');\n+        ++it;\n+        CHECK(*it == 'c');\n+        ++it;\n+        CHECK(*it == 'd');\n+        ++it;\n+        CHECK(*it == 'e');\n+        ++it;\n+        CHECK(it == str.end());\n+        --it;\n+        CHECK(*it == 'e');\n+        --it;\n+        CHECK(*it == 'd');\n+        --it;\n+        CHECK(*it == 'c');\n+        --it;\n+        CHECK(*it == 'b');\n+        --it;\n+        CHECK(*it == 'a');\n+        CHECK(it == str.begin());\n+    }\n+\n+    SECTION( \"handles incomplete ansi sequences\" ) {\n+        std::string text = \"a\\033[b\\033[30c\\033[30;d\\033[30;2e\";\n+        AnsiSkippingString str(text);\n+        CHECK(std::string(str.begin(), str.end()) == text);\n+    }\n+}\n+\n+TEST_CASE( \"TextFlow::AnsiSkippingString computes the size properly\",\n+           \"[TextFlow][ansiskippingstring][approvals]\" ) {\n+    std::string text = \"\\033[38;2;98;174;239m\\033[38;2;98;174;239ma\\033[38;2;98;174;239mb\\033[38m\\033[38m\\033[38mc\\033[0md\\033[me\";\n+    AnsiSkippingString str(text);\n+    CHECK(str.size() == 5);\n+}\n+\n+TEST_CASE( \"TextFlow::AnsiSkippingString substrings properly\",\n+           \"[TextFlow][ansiskippingstring][approvals]\" ) {\n+    SECTION(\"basic test\") {\n+        std::string text = \"a\\033[38;2;98;174;239mb\\033[38mc\\033[0md\\033[me\";\n+        AnsiSkippingString str(text);\n+        auto a = str.begin();\n+        auto b = str.begin();\n+        ++b;\n+        ++b;\n+        CHECK(str.substring(a, b) == \"a\\033[38;2;98;174;239mb\\033[38m\");\n+        ++a;\n+        ++b;\n+        CHECK(str.substring(a, b) == \"b\\033[38mc\\033[0m\");\n+        CHECK(str.substring(a, str.end()) == \"b\\033[38mc\\033[0md\\033[me\");\n+        CHECK(str.substring(str.begin(), str.end()) == text);\n+    }\n+    SECTION(\"escapes at the start\") {\n+        std::string text = \"\\033[38;2;98;174;239m\\033[38;2;98;174;239ma\\033[38;2;98;174;239mb\\033[38m\\033[38m\\033[38mc\\033[0md\\033[me\";\n+        AnsiSkippingString str(text);\n+        auto a = str.begin();\n+        auto b = str.begin();\n+        ++b;\n+        ++b;\n+        CHECK(str.substring(a, b) == \"\\033[38;2;98;174;239m\\033[38;2;98;174;239ma\\033[38;2;98;174;239mb\\033[38m\\033[38m\\033[38m\");\n+        ++a;\n+        ++b;\n+        CHECK(str.substring(a, b) == \"b\\033[38m\\033[38m\\033[38mc\\033[0m\");\n+        CHECK(str.substring(a, str.end()) == \"b\\033[38m\\033[38m\\033[38mc\\033[0md\\033[me\");\n+        CHECK(str.substring(str.begin(), str.end()) == text);\n+    }\n+    SECTION(\"escapes at the end\") {\n+        std::string text = \"a\\033[38;2;98;174;239mb\\033[38mc\\033[0md\\033[me\\033[38m\";\n+        AnsiSkippingString str(text);\n+        auto a = str.begin();\n+        auto b = str.begin();\n+        ++b;\n+        ++b;\n+        CHECK(str.substring(a, b) == \"a\\033[38;2;98;174;239mb\\033[38m\");\n+        ++a;\n+        ++b;\n+        CHECK(str.substring(a, b) == \"b\\033[38mc\\033[0m\");\n+        CHECK(str.substring(a, str.end()) == \"b\\033[38mc\\033[0md\\033[me\\033[38m\");\n+        CHECK(str.substring(str.begin(), str.end()) == text);\n+    }\n+}\n+\n+TEST_CASE( \"TextFlow::Column skips ansi escape sequences\",\n+           \"[TextFlow][column][approvals]\" ) {\n+    std::string text = \"\\033[38;2;98;174;239m\\033[38;2;198;120;221mThe quick brown \\033[38;2;198;120;221mfox jumped over the lazy dog\\033[0m\";\n+    Column col(text);\n+\n+    SECTION( \"width=20\" ) {\n+        col.width( 20 );\n+        REQUIRE( as_written( col ) == \"\\033[38;2;98;174;239m\\033[38;2;198;120;221mThe quick brown \\033[38;2;198;120;221mfox\\n\"\n+                                      \"jumped over the lazy\\n\"\n+                                      \"dog\\033[0m\" );\n+    }\n+\n+    SECTION( \"width=80\" ) {\n+        col.width( 80 );\n+        REQUIRE( as_written( col ) == text );\n+    }\n+}\n", "fixed_tests": {"testspecs::nomatchedtestsfail": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "randomtestordering": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::reporters::output": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "libidentitytest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:rngseed:compact": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:rngseed:xml": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "unmatchedoutputfilter": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filenameastagsmatching": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::xmloutput": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tags::exitcode": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "warnings::unmatchedtestspecisaccepted": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:filters:xml": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::output": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:rngseed:json": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::listeners::xmloutput": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "escapespecialcharactersintestnames": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "warnings::multiplewarningscanbespecified": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "noassertions": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters::reporterspecificcolouroverridesdefaultcolour": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:filters:json": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "benchmarking::failurereporting::failedassertion": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "errorhandling::invalidtestspecexitsearly": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "multireporter::capturingreportersdontpropagatestdout": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "multireporter::noncapturingreporterspropagatestdout": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:rngseed:console": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testspecs::overridefailurewithnomatchedtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testspecs::combiningmatchingandnonmatchingisok-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::escapespecialcharacters": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::invalidtestnames-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tags::xmloutput": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "colours::colourmodecanbeexplicitlysettoansi": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:filters:console": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters::junit::namespacesarenormalized": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:rngseed:junit": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:filters:junit": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "versioncheck": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "benchmarking::failurereporting::failmacro": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:filters:sonarqube": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "checkconvenienceheaders": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tags::output": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::listeners::exitcode": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:filters:compact": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "approvaltests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testspecs::warnunmatchedtestspecfailswithunmatchedtestspec": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "benchmarking::failurereporting::shouldfailisrespected": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "negativespecnohiddentests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "outputs::dashasoutlocationsendsoutputtostdout": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection::generatorsdontcauseinfiniteloop-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testspecs::combiningmatchingandnonmatchingisok-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::exitcode": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:rngseed:sonarqube": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:rngseed:tap": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:filters:tap": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::quiet": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::simplespecs": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters::dashaslocationinreporterspecsendsoutputtostdout": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "regressioncheck-1670": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::reporters::exitcode": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testspecs::overrideallskipfailure": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filenameastagstest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testspecs::nonmatchingtestspecisroundtrippable": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::listeners::output": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "benchmarking::skipbenchmarkmacros": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters::unrecognizedoptioninspeccauseserror": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "tagalias": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::reporters::xmloutput": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "benchmarking::failurereporting::throwingbenchmark": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection::generatorsdontcauseinfiniteloop-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "p2p_tests": {"have_flag__wfloat_equal": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wunused_function": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wmissing_declarations": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wmismatched_tags": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wold_style_cast": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wstrict_aliasing": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wparentheses": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wredundant_decls": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wextra_semi": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wundef": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wdeprecated": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wuninitialized": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wmismatched_new_delete": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wexceptions": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wunused_parameter": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__winit_self": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wextra": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wsubobject_linkage": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wpedantic": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wvla": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wall": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wnull_dereference": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wmissing_braces": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__woverloaded_virtual": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wcast_align": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wmisleading_indentation": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wshadow": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wmissing_noreturn": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__ffile_prefix_map__home_catch2__": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wunused": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wsuggest_override": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wcatch_value": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wreorder": {"run": "PASS", "test": "PASS", "fix": "PASS"}}, "f2p_tests": {}, "s2p_tests": {}, "n2p_tests": {"testspecs::nomatchedtestsfail": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "randomtestordering": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::reporters::output": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "libidentitytest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:rngseed:compact": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:rngseed:xml": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "unmatchedoutputfilter": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filenameastagsmatching": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::xmloutput": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tags::exitcode": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "warnings::unmatchedtestspecisaccepted": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:filters:xml": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::output": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:rngseed:json": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::listeners::xmloutput": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "escapespecialcharactersintestnames": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "warnings::multiplewarningscanbespecified": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "noassertions": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters::reporterspecificcolouroverridesdefaultcolour": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:filters:json": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "benchmarking::failurereporting::failedassertion": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "errorhandling::invalidtestspecexitsearly": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "multireporter::capturingreportersdontpropagatestdout": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "multireporter::noncapturingreporterspropagatestdout": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:rngseed:console": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testspecs::overridefailurewithnomatchedtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testspecs::combiningmatchingandnonmatchingisok-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::escapespecialcharacters": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::invalidtestnames-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tags::xmloutput": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "colours::colourmodecanbeexplicitlysettoansi": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:filters:console": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters::junit::namespacesarenormalized": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:rngseed:junit": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:filters:junit": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "versioncheck": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "benchmarking::failurereporting::failmacro": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:filters:sonarqube": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "checkconvenienceheaders": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tags::output": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::listeners::exitcode": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:filters:compact": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "approvaltests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testspecs::warnunmatchedtestspecfailswithunmatchedtestspec": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "benchmarking::failurereporting::shouldfailisrespected": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "negativespecnohiddentests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "outputs::dashasoutlocationsendsoutputtostdout": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection::generatorsdontcauseinfiniteloop-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testspecs::combiningmatchingandnonmatchingisok-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::exitcode": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:rngseed:sonarqube": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:rngseed:tap": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters:filters:tap": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::quiet": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::simplespecs": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters::dashaslocationinreporterspecsendsoutputtostdout": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "regressioncheck-1670": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::reporters::exitcode": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testspecs::overrideallskipfailure": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filenameastagstest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testspecs::nonmatchingtestspecisroundtrippable": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::listeners::output": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "benchmarking::skipbenchmarkmacros": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters::unrecognizedoptioninspeccauseserror": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "tagalias": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::reporters::xmloutput": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "benchmarking::failurereporting::throwingbenchmark": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection::generatorsdontcauseinfiniteloop-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "run_result": {"passed_count": 104, "failed_count": 14, "skipped_count": 0, "passed_tests": ["testspecs::nomatchedtestsfail", "randomtestordering", "libidentitytest", "have_flag__wfloat_equal", "reporters:rngseed:compact", "reporters:rngseed:xml", "unmatchedoutputfilter", "have_flag__wmissing_declarations", "filenameastagsmatching", "have_flag__wmismatched_tags", "list::tests::output", "have_flag__wold_style_cast", "have_flag__wstrict_aliasing", "noassertions", "reporters:filters:json", "benchmarking::failurereporting::failedassertion", "reporters:rngseed:console", "runtests", "testspecs::combiningmatchingandnonmatchingisok-2", "testsinfile::escapespecialcharacters", "testsinfile::invalidtestnames-1", "filteredsection-2", "list::tags::xmloutput", "colours::colourmodecanbeexplicitlysettoansi", "reporters:filters:console", "have_flag__wuninitialized", "have_flag__wmismatched_new_delete", "have_flag__wexceptions", "filteredsection-1", "benchmarking::failurereporting::failmacro", "reporters:filters:sonarqube", "have_flag__winit_self", "have_flag__wextra", "list::listeners::exitcode", "reporters:filters:compact", "approvaltests", "testspecs::warnunmatchedtestspecfailswithunmatchedtestspec", "benchmarking::failurereporting::shouldfailisrespected", "have_flag__wvla", "have_flag__wall", "negativespecnohiddentests", "outputs::dashasoutlocationsendsoutputtostdout", "filteredsection::generatorsdontcauseinfiniteloop-2", "have_flag__wnull_dereference", "testspecs::combiningmatchingandnonmatchingisok-1", "have_flag__wmissing_braces", "reporters:filters:tap", "testsinfile::simplespecs", "reporters::dashaslocationinreporterspecsendsoutputtostdout", "have_flag__wcast_align", "have_flag__wmisleading_indentation", "regressioncheck-1670", "have_flag__wmissing_noreturn", "list::listeners::output", "have_flag__wsuggest_override", "benchmarking::skipbenchmarkmacros", "reporters::unrecognizedoptioninspeccauseserror", "tagalias", "have_flag__wreorder", "list::reporters::output", "have_flag__wunused_function", "list::tests::xmloutput", "list::tags::exitcode", "warnings::unmatchedtestspecisaccepted", "reporters:filters:xml", "reporters:rngseed:json", "list::listeners::xmloutput", "escapespecialcharactersintestnames", "have_flag__wparentheses", "warnings::multiplewarningscanbespecified", "reporters::reporterspecificcolouroverridesdefaultcolour", "have_flag__wredundant_decls", "errorhandling::invalidtestspecexitsearly", "have_flag__wextra_semi", "have_flag__wundef", "multireporter::capturingreportersdontpropagatestdout", "multireporter::noncapturingreporterspropagatestdout", "testspecs::overridefailurewithnomatchedtests", "have_flag__wdeprecated", "reporters::junit::namespacesarenormalized", "reporters:rngseed:junit", "reporters:filters:junit", "versioncheck", "have_flag__wunused_parameter", "checkconvenienceheaders", "list::tags::output", "have_flag__wsubobject_linkage", "have_flag__wpedantic", "list::tests::exitcode", "reporters:rngseed:sonarqube", "reporters:rngseed:tap", "list::tests::quiet", "have_flag__woverloaded_virtual", "have_flag__wshadow", "list::reporters::exitcode", "testspecs::overrideallskipfailure", "filenameastagstest", "have_flag__ffile_prefix_map__home_catch2__", "testspecs::nonmatchingtestspecisroundtrippable", "have_flag__wunused", "have_flag__wcatch_value", "list::reporters::xmloutput", "benchmarking::failurereporting::throwingbenchmark", "filteredsection::generatorsdontcauseinfiniteloop-1"], "failed_tests": ["have_flag__wdeprecated_register", "have_flag__wdangling", "have_flag__wsuggest_destructor_override", "have_flag__wglobal_constructors", "have_flag__wmissing_prototypes", "have_flag__wreturn_std_move", "have_flag__wabsolute_value", "have_flag__wweak_vtables", "have_flag__wunneeded_internal_declaration", "have_flag__wmismatched_return_types", "have_flag__wcall_to_pure_virtual_from_ctor_dtor", "have_flag__wunreachable_code_aggressive", "have_flag__wmissing_variable_declarations", "have_flag__wexit_time_destructors"], "skipped_tests": []}, "test_patch_result": {"passed_count": 33, "failed_count": 14, "skipped_count": 0, "passed_tests": ["have_flag__wunused_function", "have_flag__wfloat_equal", "have_flag__wmissing_declarations", "have_flag__winit_self", "have_flag__wmismatched_tags", "have_flag__wextra", "have_flag__wsubobject_linkage", "have_flag__wpedantic", "have_flag__wold_style_cast", "have_flag__wstrict_aliasing", "have_flag__wparentheses", "have_flag__wvla", "have_flag__wall", "have_flag__wredundant_decls", "have_flag__wnull_dereference", "have_flag__wextra_semi", "have_flag__wmissing_braces", "have_flag__wundef", "have_flag__woverloaded_virtual", "have_flag__wcast_align", "have_flag__wmisleading_indentation", "have_flag__wdeprecated", "have_flag__wshadow", "have_flag__wmissing_noreturn", "have_flag__ffile_prefix_map__home_catch2__", "have_flag__wmismatched_new_delete", "have_flag__wuninitialized", "have_flag__wunused", "have_flag__wsuggest_override", "have_flag__wexceptions", "have_flag__wcatch_value", "have_flag__wunused_parameter", "have_flag__wreorder"], "failed_tests": ["have_flag__wdeprecated_register", "have_flag__wdangling", "have_flag__wsuggest_destructor_override", "have_flag__wglobal_constructors", "have_flag__wmissing_prototypes", "have_flag__wreturn_std_move", "have_flag__wabsolute_value", "have_flag__wweak_vtables", "have_flag__wunneeded_internal_declaration", "have_flag__wmismatched_return_types", "have_flag__wcall_to_pure_virtual_from_ctor_dtor", "have_flag__wunreachable_code_aggressive", "have_flag__wmissing_variable_declarations", "have_flag__wexit_time_destructors"], "skipped_tests": []}, "fix_patch_result": {"passed_count": 104, "failed_count": 14, "skipped_count": 0, "passed_tests": ["testspecs::nomatchedtestsfail", "randomtestordering", "libidentitytest", "have_flag__wfloat_equal", "reporters:rngseed:compact", "reporters:rngseed:xml", "unmatchedoutputfilter", "have_flag__wmissing_declarations", "filenameastagsmatching", "have_flag__wmismatched_tags", "list::tests::output", "have_flag__wold_style_cast", "have_flag__wstrict_aliasing", "noassertions", "reporters:filters:json", "benchmarking::failurereporting::failedassertion", "reporters:rngseed:console", "runtests", "testspecs::combiningmatchingandnonmatchingisok-2", "testsinfile::escapespecialcharacters", "testsinfile::invalidtestnames-1", "filteredsection-2", "list::tags::xmloutput", "colours::colourmodecanbeexplicitlysettoansi", "reporters:filters:console", "have_flag__wuninitialized", "have_flag__wmismatched_new_delete", "have_flag__wexceptions", "filteredsection-1", "benchmarking::failurereporting::failmacro", "reporters:filters:sonarqube", "have_flag__winit_self", "have_flag__wextra", "list::listeners::exitcode", "reporters:filters:compact", "approvaltests", "testspecs::warnunmatchedtestspecfailswithunmatchedtestspec", "benchmarking::failurereporting::shouldfailisrespected", "have_flag__wvla", "have_flag__wall", "negativespecnohiddentests", "outputs::dashasoutlocationsendsoutputtostdout", "filteredsection::generatorsdontcauseinfiniteloop-2", "have_flag__wnull_dereference", "testspecs::combiningmatchingandnonmatchingisok-1", "have_flag__wmissing_braces", "reporters:filters:tap", "testsinfile::simplespecs", "reporters::dashaslocationinreporterspecsendsoutputtostdout", "have_flag__wcast_align", "have_flag__wmisleading_indentation", "regressioncheck-1670", "have_flag__wmissing_noreturn", "list::listeners::output", "have_flag__wsuggest_override", "benchmarking::skipbenchmarkmacros", "reporters::unrecognizedoptioninspeccauseserror", "tagalias", "have_flag__wreorder", "list::reporters::output", "have_flag__wunused_function", "list::tests::xmloutput", "list::tags::exitcode", "warnings::unmatchedtestspecisaccepted", "reporters:filters:xml", "reporters:rngseed:json", "list::listeners::xmloutput", "escapespecialcharactersintestnames", "have_flag__wparentheses", "warnings::multiplewarningscanbespecified", "reporters::reporterspecificcolouroverridesdefaultcolour", "have_flag__wredundant_decls", "errorhandling::invalidtestspecexitsearly", "have_flag__wextra_semi", "have_flag__wundef", "multireporter::capturingreportersdontpropagatestdout", "multireporter::noncapturingreporterspropagatestdout", "testspecs::overridefailurewithnomatchedtests", "have_flag__wdeprecated", "reporters::junit::namespacesarenormalized", "reporters:rngseed:junit", "reporters:filters:junit", "versioncheck", "have_flag__wunused_parameter", "checkconvenienceheaders", "list::tags::output", "have_flag__wsubobject_linkage", "have_flag__wpedantic", "list::tests::exitcode", "reporters:rngseed:sonarqube", "reporters:rngseed:tap", "list::tests::quiet", "have_flag__woverloaded_virtual", "have_flag__wshadow", "list::reporters::exitcode", "testspecs::overrideallskipfailure", "filenameastagstest", "have_flag__ffile_prefix_map__home_catch2__", "testspecs::nonmatchingtestspecisroundtrippable", "have_flag__wunused", "have_flag__wcatch_value", "list::reporters::xmloutput", "benchmarking::failurereporting::throwingbenchmark", "filteredsection::generatorsdontcauseinfiniteloop-1"], "failed_tests": ["have_flag__wdeprecated_register", "have_flag__wdangling", "have_flag__wsuggest_destructor_override", "have_flag__wglobal_constructors", "have_flag__wmissing_prototypes", "have_flag__wreturn_std_move", "have_flag__wabsolute_value", "have_flag__wweak_vtables", "have_flag__wunneeded_internal_declaration", "have_flag__wmismatched_return_types", "have_flag__wcall_to_pure_virtual_from_ctor_dtor", "have_flag__wunreachable_code_aggressive", "have_flag__wmissing_variable_declarations", "have_flag__wexit_time_destructors"], "skipped_tests": []}, "instance_id": "catchorg__Catch2-2849"}
{"org": "catchorg", "repo": "Catch2", "number": 2723, "state": "closed", "title": "Assert Info reset need to also reset result disposition to normal to handle uncaught exception correctly", "body": "<!--\r\nPlease do not submit pull requests changing the `version.hpp`\r\nor the single-include `catch.hpp` file, these are changed\r\nonly when a new release is made.\r\n\r\nBefore submitting a PR you should probably read the contributor documentation\r\nat docs/contributing.md. It will tell you how to properly test your changes.\r\n-->\r\n\r\n\r\n## Description\r\n<!--\r\nDescribe the what and the why of your pull request. Remember that these two\r\nare usually a bit different. As an example, if you have made various changes\r\nto decrease the number of new strings allocated, that's what. The why probably\r\nwas that you have a large set of tests and found that this speeds them up.\r\n-->\r\nwhy?\r\nAfter CHECK_ELSE is run, uncaught exception would pass unit tests which causes huge issues.\r\n\r\nwhat?\r\nThis pull request added two unit tests to demo how uncaught exception are swallowed silently, and fixes that with resetting the result disposition flag to normal. Since populateReaction uses the last assertion info, it needs to be reset after populateReaction is called.\r\n\r\n## GitHub Issues\r\n<!-- \r\nIf this PR was motivated by some existing issues, reference them here.\r\n\r\nIf it is a simple bug-fix, please also add a line like 'Closes #123'\r\nto your commit message, so that it is automatically closed.\r\nIf it is not, don't, as it might take several iterations for a feature\r\nto be done properly. If in doubt, leave it open and reference it in the\r\nPR itself, so that maintainers can decide.\r\n-->\r\nCloses #2719\r\n", "base": {"label": "catchorg:devel", "ref": "devel", "sha": "4acc51828f7f93f3b2058a63f54d112af4034503"}, "resolved_issues": [{"number": 2719, "title": "Exception is treated as passing when used CHECKED_ELSE before in xml reporter", "body": "**Describe the bug**\r\nAfter CHECKED_ELSE(true) {} is being run, any exception being thrown in the tests are suppressed and treated as passing when using xml reporter. Using console reporter reports failure.\r\n\r\nAfter CHECKED_ELSE(false) {} is being run, any exception being thrown are suppressed in both console and xml reporter.\r\n\r\n**Expected behavior**\r\nBoth the console reporter and xml reporter should behave exactly the same, that the exception is reported and test counted as failure in both cases.\r\n\r\n**Reproduction steps**\r\nSteps to reproduce the bug.\r\n<!-- Usually this means a small and self-contained piece of code that uses Catch and specifying compiler flags if relevant. -->\r\n```\r\n#include <catch2/catch_test_macros.hpp>\r\n#include <exception>\r\n\r\nTEST_CASE(\"Testing\") {\r\n    CHECKED_ELSE(true) {}\r\n    throw std::runtime_error(\"it is an error\");\r\n}\r\n```\r\nRunning it with \r\n./test -r xml\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<Catch2TestRun name=\"test\" rng-seed=\"3025144594\" xml-format-version=\"2\" catch\r\n  <TestCase name=\"Testing\" filename=\"/home/ross/workspace/catch2-xml/test.cpp\r\n    <OverallResult success=\"true\" skips=\"0\"/>\r\n  </TestCase>\r\n  <OverallResults successes=\"1\" failures=\"0\" expectedFailures=\"0\" skips=\"0\"/>\r\n  <OverallResultsCases successes=\"1\" failures=\"0\" expectedFailures=\"0\" skips=\r\n</Catch2TestRun>\r\n```\r\nAnd running it directly with\r\n./test\r\n```\r\n...\r\n/home/ross/workspace/catch2-xml/test.cpp:4: FAILED:\r\n  {Unknown expression after the reported line}\r\ndue to unexpected exception with message:\r\n  it is an error\r\n\r\n===============================================================================\r\ntest cases: 1 | 1 failed\r\nassertions: 2 | 1 passed | 1 failed\r\n```\r\nAnd if the argument inside CHECKED_ELSE is false, exception is suppressed for both console and xml reporter. It also looks like a bug.\r\n\r\n```\r\n#include <catch2/catch_test_macros.hpp>\r\n#include <exception>\r\n\r\nTEST_CASE(\"Testing\") {\r\n    CHECKED_ELSE(false) {}\r\n    throw std::runtime_error(\"it is an error\");\r\n}\r\n```\r\nRunning\r\n./test -r xml\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<Catch2TestRun name=\"test\" rng-seed=\"3270933764\" xml-format-version=\"2\" catch2-version=\"3.3.2\">\r\n  <TestCase name=\"Testing\" filename=\"/home/ross/workspace/catch2-xml/test.cpp\" line=\"4\">\r\n    <OverallResult success=\"true\" skips=\"0\"/>\r\n  </TestCase>\r\n  <OverallResults successes=\"0\" failures=\"0\" expectedFailures=\"0\" skips=\"0\"/>\r\n  <OverallResultsCases successes=\"1\" failures=\"0\" expectedFailures=\"0\" skips=\"0\"/>\r\n</Catch2TestRun>\r\n```\r\nRunning \r\n./test \r\n```\r\nRandomness seeded to: 1751265161\r\n===============================================================================\r\ntest cases: 1 | 1 passed\r\nassertions: - none -\r\n```\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: **Ubuntu jammy**\r\n - Compiler+version: **clang++-15**\r\n - Catch version: **v3.3.2**\r\n\r\n\r\n**Additional context**\r\nAdd any other context about the problem here.\r\n"}], "fix_patch": "diff --git a/src/catch2/internal/catch_run_context.cpp b/src/catch2/internal/catch_run_context.cpp\nindex 6f15cfb1a4..e568100d60 100644\n--- a/src/catch2/internal/catch_run_context.cpp\n+++ b/src/catch2/internal/catch_run_context.cpp\n@@ -20,6 +20,7 @@\n #include <catch2/internal/catch_output_redirect.hpp>\n #include <catch2/internal/catch_assertion_handler.hpp>\n #include <catch2/internal/catch_test_failure_exception.hpp>\n+#include <catch2/internal/catch_result_type.hpp>\n \n #include <cassert>\n #include <algorithm>\n@@ -293,13 +294,14 @@ namespace Catch {\n             m_messageScopes.clear();\n         }\n \n-        // Reset working state\n-        resetAssertionInfo();\n+        // Reset working state. assertion info will be reset after\n+        // populateReaction is run if it is needed\n         m_lastResult = CATCH_MOVE( result );\n     }\n     void RunContext::resetAssertionInfo() {\n         m_lastAssertionInfo.macroName = StringRef();\n         m_lastAssertionInfo.capturedExpression = \"{Unknown expression after the reported line}\"_sr;\n+        m_lastAssertionInfo.resultDisposition = ResultDisposition::Normal;\n     }\n \n     void RunContext::notifyAssertionStarted( AssertionInfo const& info ) {\n@@ -447,6 +449,7 @@ namespace Catch {\n         AssertionResult result(m_lastAssertionInfo, CATCH_MOVE(tempResult));\n \n         assertionEnded(CATCH_MOVE(result) );\n+        resetAssertionInfo();\n \n         handleUnfinishedSections();\n \n@@ -583,6 +586,7 @@ namespace Catch {\n             reportExpr(info, ResultWas::ExpressionFailed, &expr, negated );\n             populateReaction( reaction );\n         }\n+        resetAssertionInfo();\n     }\n     void RunContext::reportExpr(\n             AssertionInfo const &info,\n@@ -621,6 +625,7 @@ namespace Catch {\n             // considered \"OK\"\n             reaction.shouldSkip = true;\n         }\n+        resetAssertionInfo();\n     }\n     void RunContext::handleUnexpectedExceptionNotThrown(\n             AssertionInfo const& info,\n@@ -641,6 +646,7 @@ namespace Catch {\n         AssertionResult assertionResult{ info, CATCH_MOVE(data) };\n         assertionEnded( CATCH_MOVE(assertionResult) );\n         populateReaction( reaction );\n+        resetAssertionInfo();\n     }\n \n     void RunContext::populateReaction( AssertionReaction& reaction ) {\n@@ -658,6 +664,7 @@ namespace Catch {\n         data.message = \"Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE\"s;\n         AssertionResult assertionResult{ info, CATCH_MOVE( data ) };\n         assertionEnded( CATCH_MOVE(assertionResult) );\n+        resetAssertionInfo();\n     }\n     void RunContext::handleNonExpr(\n             AssertionInfo const &info,\n@@ -672,6 +679,7 @@ namespace Catch {\n         const auto isOk = assertionResult.isOk();\n         assertionEnded( CATCH_MOVE(assertionResult) );\n         if ( !isOk ) { populateReaction( reaction ); }\n+        resetAssertionInfo();\n     }\n \n \n", "test_patch": "diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\nindex 14a68e3494..74017c3884 100644\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -78,6 +78,7 @@ endif(MSVC) #Temporary workaround\n set(TEST_SOURCES\n         ${SELF_TEST_DIR}/TestRegistrations.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Algorithms.tests.cpp\n+        ${SELF_TEST_DIR}/IntrospectiveTests/AssertionHandler.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Clara.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/CmdLine.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/CmdLineHelpers.tests.cpp\ndiff --git a/tests/SelfTest/Baselines/automake.sw.approved.txt b/tests/SelfTest/Baselines/automake.sw.approved.txt\nindex 6b5938a67b..cfddf2171d 100644\n--- a/tests/SelfTest/Baselines/automake.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/automake.sw.approved.txt\n@@ -166,6 +166,7 @@ Nor would this\n :test-result: FAIL INFO gets logged on failure\n :test-result: FAIL INFO gets logged on failure, even if captured before successful assertions\n :test-result: FAIL INFO is reset for each loop\n+:test-result: XFAIL Incomplete AssertionHandler\n :test-result: XFAIL Inequality checks that should fail\n :test-result: PASS Inequality checks that should succeed\n :test-result: PASS Lambdas in assertions\n@@ -265,6 +266,8 @@ Message from section two\n :test-result: PASS Testing checked-if\n :test-result: XFAIL Testing checked-if 2\n :test-result: XFAIL Testing checked-if 3\n+:test-result: XFAIL Testing checked-if 4\n+:test-result: XFAIL Testing checked-if 5\n :test-result: FAIL The NO_FAIL macro reports a failure but does not fail the test\n :test-result: PASS The default listing implementation write to provided stream\n :test-result: FAIL This test 'should' fail but doesn't\ndiff --git a/tests/SelfTest/Baselines/automake.sw.multi.approved.txt b/tests/SelfTest/Baselines/automake.sw.multi.approved.txt\nindex cd56e64871..80ed132566 100644\n--- a/tests/SelfTest/Baselines/automake.sw.multi.approved.txt\n+++ b/tests/SelfTest/Baselines/automake.sw.multi.approved.txt\n@@ -164,6 +164,7 @@\n :test-result: FAIL INFO gets logged on failure\n :test-result: FAIL INFO gets logged on failure, even if captured before successful assertions\n :test-result: FAIL INFO is reset for each loop\n+:test-result: XFAIL Incomplete AssertionHandler\n :test-result: XFAIL Inequality checks that should fail\n :test-result: PASS Inequality checks that should succeed\n :test-result: PASS Lambdas in assertions\n@@ -258,6 +259,8 @@\n :test-result: PASS Testing checked-if\n :test-result: XFAIL Testing checked-if 2\n :test-result: XFAIL Testing checked-if 3\n+:test-result: XFAIL Testing checked-if 4\n+:test-result: XFAIL Testing checked-if 5\n :test-result: FAIL The NO_FAIL macro reports a failure but does not fail the test\n :test-result: PASS The default listing implementation write to provided stream\n :test-result: FAIL This test 'should' fail but doesn't\ndiff --git a/tests/SelfTest/Baselines/compact.sw.approved.txt b/tests/SelfTest/Baselines/compact.sw.approved.txt\nindex be7a412035..cac5fc0383 100644\n--- a/tests/SelfTest/Baselines/compact.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/compact.sw.approved.txt\n@@ -961,6 +961,7 @@ Message.tests.cpp:<line number>: passed: i < 10 for: 7 < 10 with 2 messages: 'cu\n Message.tests.cpp:<line number>: passed: i < 10 for: 8 < 10 with 2 messages: 'current counter 8' and 'i := 8'\n Message.tests.cpp:<line number>: passed: i < 10 for: 9 < 10 with 2 messages: 'current counter 9' and 'i := 9'\n Message.tests.cpp:<line number>: failed: i < 10 for: 10 < 10 with 2 messages: 'current counter 10' and 'i := 10'\n+AssertionHandler.tests.cpp:<line number>: failed: unexpected exception with message: 'Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE'; expression was: Dummy\n Condition.tests.cpp:<line number>: failed: data.int_seven != 7 for: 7 != 7\n Condition.tests.cpp:<line number>: failed: data.float_nine_point_one != Approx( 9.1f ) for: 9.1f != Approx( 9.1000003815 )\n Condition.tests.cpp:<line number>: failed: data.double_pi != Approx( 3.1415926535 ) for: 3.1415926535 != Approx( 3.1415926535 )\n@@ -1750,6 +1751,10 @@ Misc.tests.cpp:<line number>: passed: true\n Misc.tests.cpp:<line number>: failed: explicitly\n Misc.tests.cpp:<line number>: failed - but was ok: false\n Misc.tests.cpp:<line number>: failed: explicitly\n+Misc.tests.cpp:<line number>: passed: true\n+Misc.tests.cpp:<line number>: failed: unexpected exception with message: 'Uncaught exception should fail!'; expression was: {Unknown expression after the reported line}\n+Misc.tests.cpp:<line number>: failed - but was ok: false\n+Misc.tests.cpp:<line number>: failed: unexpected exception with message: 'Uncaught exception should fail!'; expression was: {Unknown expression after the reported line}\n Message.tests.cpp:<line number>: failed - but was ok: 1 == 2\n Reporters.tests.cpp:<line number>: passed: listingString, ContainsSubstring(\"[fakeTag]\"s) for: \"All available tags:\n    1  [fakeTag]\n@@ -2538,7 +2543,7 @@ InternalBenchmark.tests.cpp:<line number>: passed: med == 18. for: 18.0 == 18.0\n InternalBenchmark.tests.cpp:<line number>: passed: q3 == 23. for: 23.0 == 23.0\n Misc.tests.cpp:<line number>: passed:\n Misc.tests.cpp:<line number>: passed:\n-test cases:  409 |  308 passed |  84 failed | 6 skipped | 11 failed as expected\n-assertions: 2225 | 2048 passed | 145 failed | 32 failed as expected\n+test cases:  412 |  308 passed |  84 failed | 6 skipped | 14 failed as expected\n+assertions: 2229 | 2049 passed | 145 failed | 35 failed as expected\n \n \ndiff --git a/tests/SelfTest/Baselines/compact.sw.multi.approved.txt b/tests/SelfTest/Baselines/compact.sw.multi.approved.txt\nindex 6c48ab917f..e3e3fe25c8 100644\n--- a/tests/SelfTest/Baselines/compact.sw.multi.approved.txt\n+++ b/tests/SelfTest/Baselines/compact.sw.multi.approved.txt\n@@ -959,6 +959,7 @@ Message.tests.cpp:<line number>: passed: i < 10 for: 7 < 10 with 2 messages: 'cu\n Message.tests.cpp:<line number>: passed: i < 10 for: 8 < 10 with 2 messages: 'current counter 8' and 'i := 8'\n Message.tests.cpp:<line number>: passed: i < 10 for: 9 < 10 with 2 messages: 'current counter 9' and 'i := 9'\n Message.tests.cpp:<line number>: failed: i < 10 for: 10 < 10 with 2 messages: 'current counter 10' and 'i := 10'\n+AssertionHandler.tests.cpp:<line number>: failed: unexpected exception with message: 'Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE'; expression was: Dummy\n Condition.tests.cpp:<line number>: failed: data.int_seven != 7 for: 7 != 7\n Condition.tests.cpp:<line number>: failed: data.float_nine_point_one != Approx( 9.1f ) for: 9.1f != Approx( 9.1000003815 )\n Condition.tests.cpp:<line number>: failed: data.double_pi != Approx( 3.1415926535 ) for: 3.1415926535 != Approx( 3.1415926535 )\n@@ -1743,6 +1744,10 @@ Misc.tests.cpp:<line number>: passed: true\n Misc.tests.cpp:<line number>: failed: explicitly\n Misc.tests.cpp:<line number>: failed - but was ok: false\n Misc.tests.cpp:<line number>: failed: explicitly\n+Misc.tests.cpp:<line number>: passed: true\n+Misc.tests.cpp:<line number>: failed: unexpected exception with message: 'Uncaught exception should fail!'; expression was: {Unknown expression after the reported line}\n+Misc.tests.cpp:<line number>: failed - but was ok: false\n+Misc.tests.cpp:<line number>: failed: unexpected exception with message: 'Uncaught exception should fail!'; expression was: {Unknown expression after the reported line}\n Message.tests.cpp:<line number>: failed - but was ok: 1 == 2\n Reporters.tests.cpp:<line number>: passed: listingString, ContainsSubstring(\"[fakeTag]\"s) for: \"All available tags:\n    1  [fakeTag]\n@@ -2527,7 +2532,7 @@ InternalBenchmark.tests.cpp:<line number>: passed: med == 18. for: 18.0 == 18.0\n InternalBenchmark.tests.cpp:<line number>: passed: q3 == 23. for: 23.0 == 23.0\n Misc.tests.cpp:<line number>: passed:\n Misc.tests.cpp:<line number>: passed:\n-test cases:  409 |  308 passed |  84 failed | 6 skipped | 11 failed as expected\n-assertions: 2225 | 2048 passed | 145 failed | 32 failed as expected\n+test cases:  412 |  308 passed |  84 failed | 6 skipped | 14 failed as expected\n+assertions: 2229 | 2049 passed | 145 failed | 35 failed as expected\n \n \ndiff --git a/tests/SelfTest/Baselines/console.std.approved.txt b/tests/SelfTest/Baselines/console.std.approved.txt\nindex 0945f0dfb8..52a1b3a9a0 100644\n--- a/tests/SelfTest/Baselines/console.std.approved.txt\n+++ b/tests/SelfTest/Baselines/console.std.approved.txt\n@@ -659,6 +659,17 @@ with messages:\n   current counter 10\n   i := 10\n \n+-------------------------------------------------------------------------------\n+Incomplete AssertionHandler\n+-------------------------------------------------------------------------------\n+AssertionHandler.tests.cpp:<line number>\n+...............................................................................\n+\n+AssertionHandler.tests.cpp:<line number>: FAILED:\n+  REQUIRE( Dummy )\n+due to unexpected exception with message:\n+  Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE\n+\n -------------------------------------------------------------------------------\n Inequality checks that should fail\n -------------------------------------------------------------------------------\n@@ -997,6 +1008,28 @@ Misc.tests.cpp:<line number>\n \n Misc.tests.cpp:<line number>: FAILED:\n \n+-------------------------------------------------------------------------------\n+Testing checked-if 4\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: FAILED:\n+  {Unknown expression after the reported line}\n+due to unexpected exception with message:\n+  Uncaught exception should fail!\n+\n+-------------------------------------------------------------------------------\n+Testing checked-if 5\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: FAILED:\n+  {Unknown expression after the reported line}\n+due to unexpected exception with message:\n+  Uncaught exception should fail!\n+\n -------------------------------------------------------------------------------\n Thrown string literals are translated\n -------------------------------------------------------------------------------\n@@ -1543,6 +1576,6 @@ due to unexpected exception with message:\n   Why would you throw a std::string?\n \n ===============================================================================\n-test cases:  409 |  322 passed |  69 failed | 7 skipped | 11 failed as expected\n-assertions: 2208 | 2048 passed | 128 failed | 32 failed as expected\n+test cases:  412 |  322 passed |  69 failed | 7 skipped | 14 failed as expected\n+assertions: 2212 | 2049 passed | 128 failed | 35 failed as expected\n \ndiff --git a/tests/SelfTest/Baselines/console.sw.approved.txt b/tests/SelfTest/Baselines/console.sw.approved.txt\nindex 150980e82f..80317f5bda 100644\n--- a/tests/SelfTest/Baselines/console.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/console.sw.approved.txt\n@@ -7143,6 +7143,17 @@ with messages:\n   current counter 10\n   i := 10\n \n+-------------------------------------------------------------------------------\n+Incomplete AssertionHandler\n+-------------------------------------------------------------------------------\n+AssertionHandler.tests.cpp:<line number>\n+...............................................................................\n+\n+AssertionHandler.tests.cpp:<line number>: FAILED:\n+  REQUIRE( Dummy )\n+due to unexpected exception with message:\n+  Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE\n+\n -------------------------------------------------------------------------------\n Inequality checks that should fail\n -------------------------------------------------------------------------------\n@@ -12522,6 +12533,34 @@ Misc.tests.cpp:<line number>: FAILED - but was ok:\n \n Misc.tests.cpp:<line number>: FAILED:\n \n+-------------------------------------------------------------------------------\n+Testing checked-if 4\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  CHECKED_ELSE( true )\n+\n+Misc.tests.cpp:<line number>: FAILED:\n+  {Unknown expression after the reported line}\n+due to unexpected exception with message:\n+  Uncaught exception should fail!\n+\n+-------------------------------------------------------------------------------\n+Testing checked-if 5\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: FAILED - but was ok:\n+  CHECKED_ELSE( false )\n+\n+Misc.tests.cpp:<line number>: FAILED:\n+  {Unknown expression after the reported line}\n+due to unexpected exception with message:\n+  Uncaught exception should fail!\n+\n -------------------------------------------------------------------------------\n The NO_FAIL macro reports a failure but does not fail the test\n -------------------------------------------------------------------------------\n@@ -18232,6 +18271,6 @@ Misc.tests.cpp:<line number>\n Misc.tests.cpp:<line number>: PASSED:\n \n ===============================================================================\n-test cases:  409 |  308 passed |  84 failed | 6 skipped | 11 failed as expected\n-assertions: 2225 | 2048 passed | 145 failed | 32 failed as expected\n+test cases:  412 |  308 passed |  84 failed | 6 skipped | 14 failed as expected\n+assertions: 2229 | 2049 passed | 145 failed | 35 failed as expected\n \ndiff --git a/tests/SelfTest/Baselines/console.sw.multi.approved.txt b/tests/SelfTest/Baselines/console.sw.multi.approved.txt\nindex 4cc942dd49..fb55a0c4a4 100644\n--- a/tests/SelfTest/Baselines/console.sw.multi.approved.txt\n+++ b/tests/SelfTest/Baselines/console.sw.multi.approved.txt\n@@ -7141,6 +7141,17 @@ with messages:\n   current counter 10\n   i := 10\n \n+-------------------------------------------------------------------------------\n+Incomplete AssertionHandler\n+-------------------------------------------------------------------------------\n+AssertionHandler.tests.cpp:<line number>\n+...............................................................................\n+\n+AssertionHandler.tests.cpp:<line number>: FAILED:\n+  REQUIRE( Dummy )\n+due to unexpected exception with message:\n+  Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE\n+\n -------------------------------------------------------------------------------\n Inequality checks that should fail\n -------------------------------------------------------------------------------\n@@ -12515,6 +12526,34 @@ Misc.tests.cpp:<line number>: FAILED - but was ok:\n \n Misc.tests.cpp:<line number>: FAILED:\n \n+-------------------------------------------------------------------------------\n+Testing checked-if 4\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  CHECKED_ELSE( true )\n+\n+Misc.tests.cpp:<line number>: FAILED:\n+  {Unknown expression after the reported line}\n+due to unexpected exception with message:\n+  Uncaught exception should fail!\n+\n+-------------------------------------------------------------------------------\n+Testing checked-if 5\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: FAILED - but was ok:\n+  CHECKED_ELSE( false )\n+\n+Misc.tests.cpp:<line number>: FAILED:\n+  {Unknown expression after the reported line}\n+due to unexpected exception with message:\n+  Uncaught exception should fail!\n+\n -------------------------------------------------------------------------------\n The NO_FAIL macro reports a failure but does not fail the test\n -------------------------------------------------------------------------------\n@@ -18221,6 +18260,6 @@ Misc.tests.cpp:<line number>\n Misc.tests.cpp:<line number>: PASSED:\n \n ===============================================================================\n-test cases:  409 |  308 passed |  84 failed | 6 skipped | 11 failed as expected\n-assertions: 2225 | 2048 passed | 145 failed | 32 failed as expected\n+test cases:  412 |  308 passed |  84 failed | 6 skipped | 14 failed as expected\n+assertions: 2229 | 2049 passed | 145 failed | 35 failed as expected\n \ndiff --git a/tests/SelfTest/Baselines/junit.sw.approved.txt b/tests/SelfTest/Baselines/junit.sw.approved.txt\nindex c992154c41..7fb79463ed 100644\n--- a/tests/SelfTest/Baselines/junit.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/junit.sw.approved.txt\n@@ -1,7 +1,7 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <testsuitesloose text artifact\n >\n-  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"128\" skipped=\"12\" tests=\"2237\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n+  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"128\" skipped=\"12\" tests=\"2241\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n     <properties>\n       <property name=\"random-seed\" value=\"1\"/>\n       <property name=\"filters\" value=\"&quot;*&quot; ~[!nonportable] ~[!benchmark] ~[approvals]\"/>\n@@ -796,6 +796,15 @@ i := 10\n at Message.tests.cpp:<line number>\n       </failure>\n     </testcase>\n+    <testcase classname=\"<exe-name>.global\" name=\"Incomplete AssertionHandler\" time=\"{duration}\" status=\"run\">\n+      <skipped message=\"TEST_CASE tagged with !mayfail\"/>\n+      <error message=\"Dummy\" type=\"REQUIRE\">\n+FAILED:\n+  REQUIRE( Dummy )\n+Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE\n+at AssertionHandler.tests.cpp:<line number>\n+      </error>\n+    </testcase>\n     <testcase classname=\"<exe-name>.global\" name=\"Inequality checks that should fail\" time=\"{duration}\" status=\"run\">\n       <skipped message=\"TEST_CASE tagged with !mayfail\"/>\n       <failure message=\"data.int_seven != 7\" type=\"CHECK\">\n@@ -1360,6 +1369,24 @@ FAILED:\n at Misc.tests.cpp:<line number>\n       </failure>\n     </testcase>\n+    <testcase classname=\"<exe-name>.global\" name=\"Testing checked-if 4\" time=\"{duration}\" status=\"run\">\n+      <skipped message=\"TEST_CASE tagged with !mayfail\"/>\n+      <error message=\"{Unknown expression after the reported line}\">\n+FAILED:\n+  {Unknown expression after the reported line}\n+Uncaught exception should fail!\n+at Misc.tests.cpp:<line number>\n+      </error>\n+    </testcase>\n+    <testcase classname=\"<exe-name>.global\" name=\"Testing checked-if 5\" time=\"{duration}\" status=\"run\">\n+      <skipped message=\"TEST_CASE tagged with !mayfail\"/>\n+      <error message=\"{Unknown expression after the reported line}\">\n+FAILED:\n+  {Unknown expression after the reported line}\n+Uncaught exception should fail!\n+at Misc.tests.cpp:<line number>\n+      </error>\n+    </testcase>\n     <testcase classname=\"<exe-name>.global\" name=\"The NO_FAIL macro reports a failure but does not fail the test\" time=\"{duration}\" status=\"run\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"The default listing implementation write to provided stream/Listing tags\" time=\"{duration}\" status=\"run\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"The default listing implementation write to provided stream/Listing reporters\" time=\"{duration}\" status=\"run\"/>\ndiff --git a/tests/SelfTest/Baselines/junit.sw.multi.approved.txt b/tests/SelfTest/Baselines/junit.sw.multi.approved.txt\nindex 79c3236506..4fee867f72 100644\n--- a/tests/SelfTest/Baselines/junit.sw.multi.approved.txt\n+++ b/tests/SelfTest/Baselines/junit.sw.multi.approved.txt\n@@ -1,6 +1,6 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <testsuites>\n-  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"128\" skipped=\"12\" tests=\"2237\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n+  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"128\" skipped=\"12\" tests=\"2241\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n     <properties>\n       <property name=\"random-seed\" value=\"1\"/>\n       <property name=\"filters\" value=\"&quot;*&quot; ~[!nonportable] ~[!benchmark] ~[approvals]\"/>\n@@ -795,6 +795,15 @@ i := 10\n at Message.tests.cpp:<line number>\n       </failure>\n     </testcase>\n+    <testcase classname=\"<exe-name>.global\" name=\"Incomplete AssertionHandler\" time=\"{duration}\" status=\"run\">\n+      <skipped message=\"TEST_CASE tagged with !mayfail\"/>\n+      <error message=\"Dummy\" type=\"REQUIRE\">\n+FAILED:\n+  REQUIRE( Dummy )\n+Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE\n+at AssertionHandler.tests.cpp:<line number>\n+      </error>\n+    </testcase>\n     <testcase classname=\"<exe-name>.global\" name=\"Inequality checks that should fail\" time=\"{duration}\" status=\"run\">\n       <skipped message=\"TEST_CASE tagged with !mayfail\"/>\n       <failure message=\"data.int_seven != 7\" type=\"CHECK\">\n@@ -1359,6 +1368,24 @@ FAILED:\n at Misc.tests.cpp:<line number>\n       </failure>\n     </testcase>\n+    <testcase classname=\"<exe-name>.global\" name=\"Testing checked-if 4\" time=\"{duration}\" status=\"run\">\n+      <skipped message=\"TEST_CASE tagged with !mayfail\"/>\n+      <error message=\"{Unknown expression after the reported line}\">\n+FAILED:\n+  {Unknown expression after the reported line}\n+Uncaught exception should fail!\n+at Misc.tests.cpp:<line number>\n+      </error>\n+    </testcase>\n+    <testcase classname=\"<exe-name>.global\" name=\"Testing checked-if 5\" time=\"{duration}\" status=\"run\">\n+      <skipped message=\"TEST_CASE tagged with !mayfail\"/>\n+      <error message=\"{Unknown expression after the reported line}\">\n+FAILED:\n+  {Unknown expression after the reported line}\n+Uncaught exception should fail!\n+at Misc.tests.cpp:<line number>\n+      </error>\n+    </testcase>\n     <testcase classname=\"<exe-name>.global\" name=\"The NO_FAIL macro reports a failure but does not fail the test\" time=\"{duration}\" status=\"run\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"The default listing implementation write to provided stream/Listing tags\" time=\"{duration}\" status=\"run\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"The default listing implementation write to provided stream/Listing reporters\" time=\"{duration}\" status=\"run\"/>\ndiff --git a/tests/SelfTest/Baselines/sonarqube.sw.approved.txt b/tests/SelfTest/Baselines/sonarqube.sw.approved.txt\nindex 592887f9c4..6cbb7c7b3c 100644\n--- a/tests/SelfTest/Baselines/sonarqube.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/sonarqube.sw.approved.txt\n@@ -2,6 +2,16 @@\n <!-- filters='\"*\" ~[!nonportable] ~[!benchmark] ~[approvals]' rng-seed=1 -->\n <testExecutions version=\"1\"loose text artifact\n >\n+  <file path=\"tests/<exe-name>/IntrospectiveTests/AssertionHandler.tests.cpp\">\n+    <testCase name=\"Incomplete AssertionHandler\" duration=\"{duration}\">\n+      <skipped message=\"REQUIRE(Dummy)\">\n+FAILED:\n+\tREQUIRE( Dummy )\n+Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE\n+at AssertionHandler.tests.cpp:<line number>\n+      </skipped>\n+    </testCase>\n+  </file>\n   <file path=\"tests/<exe-name>/IntrospectiveTests/Clara.tests.cpp\">\n     <testCase name=\"Clara::Arg supports single-arg parse the way Opt does\" duration=\"{duration}\"/>\n     <testCase name=\"Clara::Opt supports accept-many lambdas/Parsing fails on multiple options without accept_many\" duration=\"{duration}\"/>\n@@ -1727,6 +1737,22 @@ at Misc.tests.cpp:<line number>\n     <testCase name=\"Testing checked-if 3\" duration=\"{duration}\">\n       <skipped message=\"FAIL()\">\n FAILED:\n+at Misc.tests.cpp:<line number>\n+      </skipped>\n+    </testCase>\n+    <testCase name=\"Testing checked-if 4\" duration=\"{duration}\">\n+      <skipped message=\"({Unknown expression after the reported line})\">\n+FAILED:\n+\t{Unknown expression after the reported line}\n+Uncaught exception should fail!\n+at Misc.tests.cpp:<line number>\n+      </skipped>\n+    </testCase>\n+    <testCase name=\"Testing checked-if 5\" duration=\"{duration}\">\n+      <skipped message=\"({Unknown expression after the reported line})\">\n+FAILED:\n+\t{Unknown expression after the reported line}\n+Uncaught exception should fail!\n at Misc.tests.cpp:<line number>\n       </skipped>\n     </testCase>\ndiff --git a/tests/SelfTest/Baselines/sonarqube.sw.multi.approved.txt b/tests/SelfTest/Baselines/sonarqube.sw.multi.approved.txt\nindex 3509287f78..ba9504cb47 100644\n--- a/tests/SelfTest/Baselines/sonarqube.sw.multi.approved.txt\n+++ b/tests/SelfTest/Baselines/sonarqube.sw.multi.approved.txt\n@@ -1,6 +1,16 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <!-- filters='\"*\" ~[!nonportable] ~[!benchmark] ~[approvals]' rng-seed=1 -->\n <testExecutions version=\"1\">\n+  <file path=\"tests/<exe-name>/IntrospectiveTests/AssertionHandler.tests.cpp\">\n+    <testCase name=\"Incomplete AssertionHandler\" duration=\"{duration}\">\n+      <skipped message=\"REQUIRE(Dummy)\">\n+FAILED:\n+\tREQUIRE( Dummy )\n+Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE\n+at AssertionHandler.tests.cpp:<line number>\n+      </skipped>\n+    </testCase>\n+  </file>\n   <file path=\"tests/<exe-name>/IntrospectiveTests/Clara.tests.cpp\">\n     <testCase name=\"Clara::Arg supports single-arg parse the way Opt does\" duration=\"{duration}\"/>\n     <testCase name=\"Clara::Opt supports accept-many lambdas/Parsing fails on multiple options without accept_many\" duration=\"{duration}\"/>\n@@ -1726,6 +1736,22 @@ at Misc.tests.cpp:<line number>\n     <testCase name=\"Testing checked-if 3\" duration=\"{duration}\">\n       <skipped message=\"FAIL()\">\n FAILED:\n+at Misc.tests.cpp:<line number>\n+      </skipped>\n+    </testCase>\n+    <testCase name=\"Testing checked-if 4\" duration=\"{duration}\">\n+      <skipped message=\"({Unknown expression after the reported line})\">\n+FAILED:\n+\t{Unknown expression after the reported line}\n+Uncaught exception should fail!\n+at Misc.tests.cpp:<line number>\n+      </skipped>\n+    </testCase>\n+    <testCase name=\"Testing checked-if 5\" duration=\"{duration}\">\n+      <skipped message=\"({Unknown expression after the reported line})\">\n+FAILED:\n+\t{Unknown expression after the reported line}\n+Uncaught exception should fail!\n at Misc.tests.cpp:<line number>\n       </skipped>\n     </testCase>\ndiff --git a/tests/SelfTest/Baselines/tap.sw.approved.txt b/tests/SelfTest/Baselines/tap.sw.approved.txt\nindex acd0a1c149..59bd2054da 100644\n--- a/tests/SelfTest/Baselines/tap.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/tap.sw.approved.txt\n@@ -1830,6 +1830,8 @@ ok {test-number} - i < 10 for: 8 < 10 with 2 messages: 'current counter 8' and '\n ok {test-number} - i < 10 for: 9 < 10 with 2 messages: 'current counter 9' and 'i := 9'\n # INFO is reset for each loop\n not ok {test-number} - i < 10 for: 10 < 10 with 2 messages: 'current counter 10' and 'i := 10'\n+# Incomplete AssertionHandler\n+not ok {test-number} - unexpected exception with message: 'Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE'; expression was: Dummy\n # Inequality checks that should fail\n not ok {test-number} - data.int_seven != 7 for: 7 != 7\n # Inequality checks that should fail\n@@ -3067,6 +3069,14 @@ not ok {test-number} - explicitly\n ok {test-number} - false  # TODO\n # Testing checked-if 3\n not ok {test-number} - explicitly\n+# Testing checked-if 4\n+ok {test-number} - true\n+# Testing checked-if 4\n+not ok {test-number} - unexpected exception with message: 'Uncaught exception should fail!'; expression was: {Unknown expression after the reported line}\n+# Testing checked-if 5\n+ok {test-number} - false  # TODO\n+# Testing checked-if 5\n+not ok {test-number} - unexpected exception with message: 'Uncaught exception should fail!'; expression was: {Unknown expression after the reported line}\n # The NO_FAIL macro reports a failure but does not fail the test\n ok {test-number} - 1 == 2  # TODO\n # The default listing implementation write to provided stream\n@@ -4477,5 +4487,5 @@ ok {test-number} - q3 == 23. for: 23.0 == 23.0\n ok {test-number} -\n # xmlentitycheck\n ok {test-number} -\n-1..2237\n+1..2241\n \ndiff --git a/tests/SelfTest/Baselines/tap.sw.multi.approved.txt b/tests/SelfTest/Baselines/tap.sw.multi.approved.txt\nindex 033290497d..3b1a4d852e 100644\n--- a/tests/SelfTest/Baselines/tap.sw.multi.approved.txt\n+++ b/tests/SelfTest/Baselines/tap.sw.multi.approved.txt\n@@ -1828,6 +1828,8 @@ ok {test-number} - i < 10 for: 8 < 10 with 2 messages: 'current counter 8' and '\n ok {test-number} - i < 10 for: 9 < 10 with 2 messages: 'current counter 9' and 'i := 9'\n # INFO is reset for each loop\n not ok {test-number} - i < 10 for: 10 < 10 with 2 messages: 'current counter 10' and 'i := 10'\n+# Incomplete AssertionHandler\n+not ok {test-number} - unexpected exception with message: 'Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE'; expression was: Dummy\n # Inequality checks that should fail\n not ok {test-number} - data.int_seven != 7 for: 7 != 7\n # Inequality checks that should fail\n@@ -3060,6 +3062,14 @@ not ok {test-number} - explicitly\n ok {test-number} - false  # TODO\n # Testing checked-if 3\n not ok {test-number} - explicitly\n+# Testing checked-if 4\n+ok {test-number} - true\n+# Testing checked-if 4\n+not ok {test-number} - unexpected exception with message: 'Uncaught exception should fail!'; expression was: {Unknown expression after the reported line}\n+# Testing checked-if 5\n+ok {test-number} - false  # TODO\n+# Testing checked-if 5\n+not ok {test-number} - unexpected exception with message: 'Uncaught exception should fail!'; expression was: {Unknown expression after the reported line}\n # The NO_FAIL macro reports a failure but does not fail the test\n ok {test-number} - 1 == 2  # TODO\n # The default listing implementation write to provided stream\n@@ -4466,5 +4476,5 @@ ok {test-number} - q3 == 23. for: 23.0 == 23.0\n ok {test-number} -\n # xmlentitycheck\n ok {test-number} -\n-1..2237\n+1..2241\n \ndiff --git a/tests/SelfTest/Baselines/teamcity.sw.approved.txt b/tests/SelfTest/Baselines/teamcity.sw.approved.txt\nindex a298633a16..1f215c1e66 100644\n--- a/tests/SelfTest/Baselines/teamcity.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/teamcity.sw.approved.txt\n@@ -405,6 +405,9 @@\n ##teamcity[testStarted name='INFO is reset for each loop']\n ##teamcity[testFailed name='INFO is reset for each loop' message='Message.tests.cpp:<line number>|n...............................................................................|n|nMessage.tests.cpp:<line number>|nexpression failed with messages:|n  \"current counter 10\"|n  \"i := 10\"|n  REQUIRE( i < 10 )|nwith expansion:|n  10 < 10|n']\n ##teamcity[testFinished name='INFO is reset for each loop' duration=\"{duration}\"]\n+##teamcity[testStarted name='Incomplete AssertionHandler']\n+##teamcity[testIgnored name='Incomplete AssertionHandler' message='AssertionHandler.tests.cpp:<line number>|n...............................................................................|n|nAssertionHandler.tests.cpp:<line number>|nunexpected exception with message:|n  \"Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE\"|n  REQUIRE( Dummy )|nwith expansion:|n  Dummy|n- failure ignore as test marked as |'ok to fail|'|n']\n+##teamcity[testFinished name='Incomplete AssertionHandler' duration=\"{duration}\"]\n ##teamcity[testStarted name='Inequality checks that should fail']\n ##teamcity[testIgnored name='Inequality checks that should fail' message='Condition.tests.cpp:<line number>|n...............................................................................|n|nCondition.tests.cpp:<line number>|nexpression failed|n  CHECK( data.int_seven != 7 )|nwith expansion:|n  7 != 7|n- failure ignore as test marked as |'ok to fail|'|n']\n ##teamcity[testIgnored name='Inequality checks that should fail' message='Condition.tests.cpp:<line number>|nexpression failed|n  CHECK( data.float_nine_point_one != Approx( 9.1f ) )|nwith expansion:|n  9.1f != Approx( 9.1000003815 )|n- failure ignore as test marked as |'ok to fail|'|n']\n@@ -639,6 +642,12 @@\n ##teamcity[testStarted name='Testing checked-if 3']\n ##teamcity[testIgnored name='Testing checked-if 3' message='Misc.tests.cpp:<line number>|n...............................................................................|n|nMisc.tests.cpp:<line number>|nexplicit failure- failure ignore as test marked as |'ok to fail|'|n']\n ##teamcity[testFinished name='Testing checked-if 3' duration=\"{duration}\"]\n+##teamcity[testStarted name='Testing checked-if 4']\n+##teamcity[testIgnored name='Testing checked-if 4' message='Misc.tests.cpp:<line number>|n...............................................................................|n|nMisc.tests.cpp:<line number>|nunexpected exception with message:|n  \"Uncaught exception should fail!\"|n  {Unknown expression after the reported line}|nwith expansion:|n  {Unknown expression after the reported line}|n- failure ignore as test marked as |'ok to fail|'|n']\n+##teamcity[testFinished name='Testing checked-if 4' duration=\"{duration}\"]\n+##teamcity[testStarted name='Testing checked-if 5']\n+##teamcity[testIgnored name='Testing checked-if 5' message='Misc.tests.cpp:<line number>|n...............................................................................|n|nMisc.tests.cpp:<line number>|nunexpected exception with message:|n  \"Uncaught exception should fail!\"|n  {Unknown expression after the reported line}|nwith expansion:|n  {Unknown expression after the reported line}|n- failure ignore as test marked as |'ok to fail|'|n']\n+##teamcity[testFinished name='Testing checked-if 5' duration=\"{duration}\"]\n ##teamcity[testStarted name='The NO_FAIL macro reports a failure but does not fail the test']\n ##teamcity[testFinished name='The NO_FAIL macro reports a failure but does not fail the test' duration=\"{duration}\"]\n ##teamcity[testStarted name='The default listing implementation write to provided stream']\ndiff --git a/tests/SelfTest/Baselines/teamcity.sw.multi.approved.txt b/tests/SelfTest/Baselines/teamcity.sw.multi.approved.txt\nindex 861d64715b..1f557c8f3a 100644\n--- a/tests/SelfTest/Baselines/teamcity.sw.multi.approved.txt\n+++ b/tests/SelfTest/Baselines/teamcity.sw.multi.approved.txt\n@@ -405,6 +405,9 @@\n ##teamcity[testStarted name='INFO is reset for each loop']\n ##teamcity[testFailed name='INFO is reset for each loop' message='Message.tests.cpp:<line number>|n...............................................................................|n|nMessage.tests.cpp:<line number>|nexpression failed with messages:|n  \"current counter 10\"|n  \"i := 10\"|n  REQUIRE( i < 10 )|nwith expansion:|n  10 < 10|n']\n ##teamcity[testFinished name='INFO is reset for each loop' duration=\"{duration}\"]\n+##teamcity[testStarted name='Incomplete AssertionHandler']\n+##teamcity[testIgnored name='Incomplete AssertionHandler' message='AssertionHandler.tests.cpp:<line number>|n...............................................................................|n|nAssertionHandler.tests.cpp:<line number>|nunexpected exception with message:|n  \"Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE\"|n  REQUIRE( Dummy )|nwith expansion:|n  Dummy|n- failure ignore as test marked as |'ok to fail|'|n']\n+##teamcity[testFinished name='Incomplete AssertionHandler' duration=\"{duration}\"]\n ##teamcity[testStarted name='Inequality checks that should fail']\n ##teamcity[testIgnored name='Inequality checks that should fail' message='Condition.tests.cpp:<line number>|n...............................................................................|n|nCondition.tests.cpp:<line number>|nexpression failed|n  CHECK( data.int_seven != 7 )|nwith expansion:|n  7 != 7|n- failure ignore as test marked as |'ok to fail|'|n']\n ##teamcity[testIgnored name='Inequality checks that should fail' message='Condition.tests.cpp:<line number>|nexpression failed|n  CHECK( data.float_nine_point_one != Approx( 9.1f ) )|nwith expansion:|n  9.1f != Approx( 9.1000003815 )|n- failure ignore as test marked as |'ok to fail|'|n']\n@@ -639,6 +642,12 @@\n ##teamcity[testStarted name='Testing checked-if 3']\n ##teamcity[testIgnored name='Testing checked-if 3' message='Misc.tests.cpp:<line number>|n...............................................................................|n|nMisc.tests.cpp:<line number>|nexplicit failure- failure ignore as test marked as |'ok to fail|'|n']\n ##teamcity[testFinished name='Testing checked-if 3' duration=\"{duration}\"]\n+##teamcity[testStarted name='Testing checked-if 4']\n+##teamcity[testIgnored name='Testing checked-if 4' message='Misc.tests.cpp:<line number>|n...............................................................................|n|nMisc.tests.cpp:<line number>|nunexpected exception with message:|n  \"Uncaught exception should fail!\"|n  {Unknown expression after the reported line}|nwith expansion:|n  {Unknown expression after the reported line}|n- failure ignore as test marked as |'ok to fail|'|n']\n+##teamcity[testFinished name='Testing checked-if 4' duration=\"{duration}\"]\n+##teamcity[testStarted name='Testing checked-if 5']\n+##teamcity[testIgnored name='Testing checked-if 5' message='Misc.tests.cpp:<line number>|n...............................................................................|n|nMisc.tests.cpp:<line number>|nunexpected exception with message:|n  \"Uncaught exception should fail!\"|n  {Unknown expression after the reported line}|nwith expansion:|n  {Unknown expression after the reported line}|n- failure ignore as test marked as |'ok to fail|'|n']\n+##teamcity[testFinished name='Testing checked-if 5' duration=\"{duration}\"]\n ##teamcity[testStarted name='The NO_FAIL macro reports a failure but does not fail the test']\n ##teamcity[testFinished name='The NO_FAIL macro reports a failure but does not fail the test' duration=\"{duration}\"]\n ##teamcity[testStarted name='The default listing implementation write to provided stream']\ndiff --git a/tests/SelfTest/Baselines/xml.sw.approved.txt b/tests/SelfTest/Baselines/xml.sw.approved.txt\nindex bf9cf2053f..7f4e8d3aaa 100644\n--- a/tests/SelfTest/Baselines/xml.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/xml.sw.approved.txt\n@@ -8619,6 +8619,20 @@ C\n     </Expression>\n     <OverallResult success=\"false\" skips=\"0\"/>\n   </TestCase>\n+  <TestCase name=\"Incomplete AssertionHandler\" tags=\"[!shouldfail][assertion-handler]\" filename=\"tests/<exe-name>/IntrospectiveTests/AssertionHandler.tests.cpp\" >\n+    <Expression success=\"false\" type=\"REQUIRE\" filename=\"tests/<exe-name>/IntrospectiveTests/AssertionHandler.tests.cpp\" >\n+      <Original>\n+        Dummy\n+      </Original>\n+      <Expanded>\n+        Dummy\n+      </Expanded>\n+      <Exception filename=\"tests/<exe-name>/IntrospectiveTests/AssertionHandler.tests.cpp\" >\n+        Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE\n+      </Exception>\n+    </Expression>\n+    <OverallResult success=\"true\" skips=\"0\"/>\n+  </TestCase>\n   <TestCase name=\"Inequality checks that should fail\" tags=\"[!shouldfail][.][failing]\" filename=\"tests/<exe-name>/UsageTests/Condition.tests.cpp\" >\n     <Expression success=\"false\" type=\"CHECK\" filename=\"tests/<exe-name>/UsageTests/Condition.tests.cpp\" >\n       <Original>\n@@ -14547,6 +14561,50 @@ Message from section two\n     <Failure filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" />\n     <OverallResult success=\"true\" skips=\"0\"/>\n   </TestCase>\n+  <TestCase name=\"Testing checked-if 4\" tags=\"[!shouldfail][checked-if]\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+    <Expression success=\"true\" type=\"CHECKED_ELSE\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+      <Original>\n+        true\n+      </Original>\n+      <Expanded>\n+        true\n+      </Expanded>\n+    </Expression>\n+    <Expression success=\"false\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+      <Original>\n+        {Unknown expression after the reported line}\n+      </Original>\n+      <Expanded>\n+        {Unknown expression after the reported line}\n+      </Expanded>\n+      <Exception filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        Uncaught exception should fail!\n+      </Exception>\n+    </Expression>\n+    <OverallResult success=\"true\" skips=\"0\"/>\n+  </TestCase>\n+  <TestCase name=\"Testing checked-if 5\" tags=\"[!shouldfail][checked-if]\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+    <Expression success=\"false\" type=\"CHECKED_ELSE\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+      <Original>\n+        false\n+      </Original>\n+      <Expanded>\n+        false\n+      </Expanded>\n+    </Expression>\n+    <Expression success=\"false\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+      <Original>\n+        {Unknown expression after the reported line}\n+      </Original>\n+      <Expanded>\n+        {Unknown expression after the reported line}\n+      </Expanded>\n+      <Exception filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        Uncaught exception should fail!\n+      </Exception>\n+    </Expression>\n+    <OverallResult success=\"true\" skips=\"0\"/>\n+  </TestCase>\n   <TestCase name=\"The NO_FAIL macro reports a failure but does not fail the test\" tags=\"[messages]\" filename=\"tests/<exe-name>/UsageTests/Message.tests.cpp\" >\n     <Expression success=\"false\" type=\"CHECK_NOFAIL\" filename=\"tests/<exe-name>/UsageTests/Message.tests.cpp\" >\n       <Original>\n@@ -21198,6 +21256,6 @@ b1!\n     </Section>\n     <OverallResult success=\"true\" skips=\"0\"/>\n   </TestCase>\n-  <OverallResults successes=\"2048\" failures=\"145\" expectedFailures=\"32\" skips=\"12\"/>\n-  <OverallResultsCases successes=\"308\" failures=\"84\" expectedFailures=\"11\" skips=\"6\"/>\n+  <OverallResults successes=\"2049\" failures=\"145\" expectedFailures=\"35\" skips=\"12\"/>\n+  <OverallResultsCases successes=\"308\" failures=\"84\" expectedFailures=\"14\" skips=\"6\"/>\n </Catch2TestRun>\ndiff --git a/tests/SelfTest/Baselines/xml.sw.multi.approved.txt b/tests/SelfTest/Baselines/xml.sw.multi.approved.txt\nindex 41dc8cb315..53afdef42e 100644\n--- a/tests/SelfTest/Baselines/xml.sw.multi.approved.txt\n+++ b/tests/SelfTest/Baselines/xml.sw.multi.approved.txt\n@@ -8619,6 +8619,20 @@ C\n     </Expression>\n     <OverallResult success=\"false\" skips=\"0\"/>\n   </TestCase>\n+  <TestCase name=\"Incomplete AssertionHandler\" tags=\"[!shouldfail][assertion-handler]\" filename=\"tests/<exe-name>/IntrospectiveTests/AssertionHandler.tests.cpp\" >\n+    <Expression success=\"false\" type=\"REQUIRE\" filename=\"tests/<exe-name>/IntrospectiveTests/AssertionHandler.tests.cpp\" >\n+      <Original>\n+        Dummy\n+      </Original>\n+      <Expanded>\n+        Dummy\n+      </Expanded>\n+      <Exception filename=\"tests/<exe-name>/IntrospectiveTests/AssertionHandler.tests.cpp\" >\n+        Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE\n+      </Exception>\n+    </Expression>\n+    <OverallResult success=\"true\" skips=\"0\"/>\n+  </TestCase>\n   <TestCase name=\"Inequality checks that should fail\" tags=\"[!shouldfail][.][failing]\" filename=\"tests/<exe-name>/UsageTests/Condition.tests.cpp\" >\n     <Expression success=\"false\" type=\"CHECK\" filename=\"tests/<exe-name>/UsageTests/Condition.tests.cpp\" >\n       <Original>\n@@ -14547,6 +14561,50 @@ Message from section two\n     <Failure filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" />\n     <OverallResult success=\"true\" skips=\"0\"/>\n   </TestCase>\n+  <TestCase name=\"Testing checked-if 4\" tags=\"[!shouldfail][checked-if]\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+    <Expression success=\"true\" type=\"CHECKED_ELSE\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+      <Original>\n+        true\n+      </Original>\n+      <Expanded>\n+        true\n+      </Expanded>\n+    </Expression>\n+    <Expression success=\"false\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+      <Original>\n+        {Unknown expression after the reported line}\n+      </Original>\n+      <Expanded>\n+        {Unknown expression after the reported line}\n+      </Expanded>\n+      <Exception filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        Uncaught exception should fail!\n+      </Exception>\n+    </Expression>\n+    <OverallResult success=\"true\" skips=\"0\"/>\n+  </TestCase>\n+  <TestCase name=\"Testing checked-if 5\" tags=\"[!shouldfail][checked-if]\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+    <Expression success=\"false\" type=\"CHECKED_ELSE\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+      <Original>\n+        false\n+      </Original>\n+      <Expanded>\n+        false\n+      </Expanded>\n+    </Expression>\n+    <Expression success=\"false\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+      <Original>\n+        {Unknown expression after the reported line}\n+      </Original>\n+      <Expanded>\n+        {Unknown expression after the reported line}\n+      </Expanded>\n+      <Exception filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        Uncaught exception should fail!\n+      </Exception>\n+    </Expression>\n+    <OverallResult success=\"true\" skips=\"0\"/>\n+  </TestCase>\n   <TestCase name=\"The NO_FAIL macro reports a failure but does not fail the test\" tags=\"[messages]\" filename=\"tests/<exe-name>/UsageTests/Message.tests.cpp\" >\n     <Expression success=\"false\" type=\"CHECK_NOFAIL\" filename=\"tests/<exe-name>/UsageTests/Message.tests.cpp\" >\n       <Original>\n@@ -21197,6 +21255,6 @@ b1!\n     </Section>\n     <OverallResult success=\"true\" skips=\"0\"/>\n   </TestCase>\n-  <OverallResults successes=\"2048\" failures=\"145\" expectedFailures=\"32\" skips=\"12\"/>\n-  <OverallResultsCases successes=\"308\" failures=\"84\" expectedFailures=\"11\" skips=\"6\"/>\n+  <OverallResults successes=\"2049\" failures=\"145\" expectedFailures=\"35\" skips=\"12\"/>\n+  <OverallResultsCases successes=\"308\" failures=\"84\" expectedFailures=\"14\" skips=\"6\"/>\n </Catch2TestRun>\ndiff --git a/tests/SelfTest/IntrospectiveTests/AssertionHandler.tests.cpp b/tests/SelfTest/IntrospectiveTests/AssertionHandler.tests.cpp\nnew file mode 100644\nindex 0000000000..ab09607450\n--- /dev/null\n+++ b/tests/SelfTest/IntrospectiveTests/AssertionHandler.tests.cpp\n@@ -0,0 +1,17 @@\n+\n+//              Copyright Catch2 Authors\n+// Distributed under the Boost Software License, Version 1.0.\n+//   (See accompanying file LICENSE.txt or copy at\n+//        https://www.boost.org/LICENSE_1_0.txt)\n+\n+// SPDX-License-Identifier: BSL-1.0\n+\n+#include <catch2/catch_test_macros.hpp>\n+\n+TEST_CASE( \"Incomplete AssertionHandler\", \"[assertion-handler][!shouldfail]\" ) {\n+    Catch::AssertionHandler catchAssertionHandler(\n+        \"REQUIRE\"_catch_sr,\n+        CATCH_INTERNAL_LINEINFO,\n+        \"Dummy\",\n+        Catch::ResultDisposition::Normal );\n+}\ndiff --git a/tests/SelfTest/UsageTests/Misc.tests.cpp b/tests/SelfTest/UsageTests/Misc.tests.cpp\nindex 6c1fd68f44..7f06704b41 100644\n--- a/tests/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Misc.tests.cpp\n@@ -217,6 +217,18 @@ TEST_CASE(\"Testing checked-if 3\", \"[checked-if][!shouldfail]\") {\n     SUCCEED();\n }\n \n+[[noreturn]]\n+TEST_CASE(\"Testing checked-if 4\", \"[checked-if][!shouldfail]\") {\n+    CHECKED_ELSE(true) {}\n+    throw std::runtime_error(\"Uncaught exception should fail!\");\n+}\n+\n+[[noreturn]]\n+TEST_CASE(\"Testing checked-if 5\", \"[checked-if][!shouldfail]\") {\n+    CHECKED_ELSE(false) {}\n+    throw std::runtime_error(\"Uncaught exception should fail!\");\n+}\n+\n TEST_CASE( \"xmlentitycheck\" ) {\n     SECTION( \"embedded xml: <test>it should be possible to embed xml characters, such as <, \\\" or &, or even whole <xml>documents</xml> within an attribute</test>\" ) {\n         SUCCEED(); // We need this here to stop it failing due to no tests\n", "fixed_tests": {"runtests": {"run": "PASS", "test": "FAIL", "fix": "PASS"}, "approvaltests": {"run": "PASS", "test": "FAIL", "fix": "PASS"}}, "p2p_tests": {"testspecs::nomatchedtestsfail": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "randomtestordering": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::reporters::output": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "libidentitytest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wfloat_equal": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "reporters:rngseed:compact": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "reporters:rngseed:xml": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wunused_function": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "unmatchedoutputfilter": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wmissing_declarations": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "filenameastagsmatching": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::tests::xmloutput": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wmismatched_tags": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::tags::exitcode": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "warnings::unmatchedtestspecisaccepted": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "reporters:filters:xml": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::tests::output": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::listeners::xmloutput": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "escapespecialcharactersintestnames": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wold_style_cast": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wstrict_aliasing": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wparentheses": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "warnings::multiplewarningscanbespecified": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "noassertions": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "reporters::reporterspecificcolouroverridesdefaultcolour": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wredundant_decls": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "benchmarking::failurereporting::failedassertion": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "errorhandling::invalidtestspecexitsearly": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wextra_semi": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wundef": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "multireporter::capturingreportersdontpropagatestdout": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "multireporter::noncapturingreporterspropagatestdout": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "reporters:rngseed:console": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "testspecs::overridefailurewithnomatchedtests": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wdeprecated": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "testspecs::combiningmatchingandnonmatchingisok-2": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "testsinfile::escapespecialcharacters": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "testsinfile::invalidtestnames-1": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "filteredsection-2": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::tags::xmloutput": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "colours::colourmodecanbeexplicitlysettoansi": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "reporters:filters:console": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "reporters::junit::namespacesarenormalized": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wuninitialized": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wmismatched_new_delete": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "reporters:rngseed:junit": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wexceptions": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "reporters:filters:junit": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "filteredsection-1": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "versioncheck": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wunused_parameter": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "benchmarking::failurereporting::failmacro": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "reporters:filters:sonarqube": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "checkconvenienceheaders": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::tags::output": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__winit_self": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wextra": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::listeners::exitcode": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "reporters:filters:compact": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wpedantic": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "testspecs::warnunmatchedtestspecfailswithunmatchedtestspec": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "benchmarking::failurereporting::shouldfailisrespected": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wvla": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wall": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "negativespecnohiddentests": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "outputs::dashasoutlocationsendsoutputtostdout": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "filteredsection::generatorsdontcauseinfiniteloop-2": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wnull_dereference": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "testspecs::combiningmatchingandnonmatchingisok-1": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wmissing_braces": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::tests::exitcode": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "reporters:rngseed:sonarqube": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "reporters:rngseed:tap": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "reporters:filters:tap": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::tests::quiet": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "testsinfile::simplespecs": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "reporters::dashaslocationinreporterspecsendsoutputtostdout": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wc__20_compat": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__woverloaded_virtual": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wcast_align": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wmisleading_indentation": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "regressioncheck-1670": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wshadow": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::reporters::exitcode": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "testspecs::overrideallskipfailure": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wmissing_noreturn": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "filenameastagstest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__ffile_prefix_map__home_catch2__": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "testspecs::nonmatchingtestspecisroundtrippable": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wunused": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::listeners::output": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wsuggest_override": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "benchmarking::skipbenchmarkmacros": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "reporters::unrecognizedoptioninspeccauseserror": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wcatch_value": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "tagalias": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::reporters::xmloutput": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "benchmarking::failurereporting::throwingbenchmark": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "filteredsection::generatorsdontcauseinfiniteloop-1": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag__wreorder": {"run": "PASS", "test": "PASS", "fix": "PASS"}}, "f2p_tests": {"runtests": {"run": "PASS", "test": "FAIL", "fix": "PASS"}, "approvaltests": {"run": "PASS", "test": "FAIL", "fix": "PASS"}}, "s2p_tests": {}, "n2p_tests": {}, "run_result": {"passed_count": 102, "failed_count": 14, "skipped_count": 0, "passed_tests": ["testspecs::nomatchedtestsfail", "randomtestordering", "libidentitytest", "have_flag__wfloat_equal", "reporters:rngseed:compact", "reporters:rngseed:xml", "unmatchedoutputfilter", "have_flag__wmissing_declarations", "filenameastagsmatching", "have_flag__wmismatched_tags", "list::tests::output", "have_flag__wold_style_cast", "have_flag__wstrict_aliasing", "noassertions", "benchmarking::failurereporting::failedassertion", "reporters:rngseed:console", "runtests", "testspecs::combiningmatchingandnonmatchingisok-2", "testsinfile::escapespecialcharacters", "testsinfile::invalidtestnames-1", "filteredsection-2", "list::tags::xmloutput", "colours::colourmodecanbeexplicitlysettoansi", "reporters:filters:console", "have_flag__wuninitialized", "have_flag__wmismatched_new_delete", "have_flag__wexceptions", "filteredsection-1", "benchmarking::failurereporting::failmacro", "reporters:filters:sonarqube", "have_flag__winit_self", "have_flag__wextra", "list::listeners::exitcode", "reporters:filters:compact", "approvaltests", "testspecs::warnunmatchedtestspecfailswithunmatchedtestspec", "benchmarking::failurereporting::shouldfailisrespected", "have_flag__wvla", "have_flag__wall", "negativespecnohiddentests", "outputs::dashasoutlocationsendsoutputtostdout", "filteredsection::generatorsdontcauseinfiniteloop-2", "have_flag__wnull_dereference", "testspecs::combiningmatchingandnonmatchingisok-1", "have_flag__wmissing_braces", "reporters:filters:tap", "testsinfile::simplespecs", "reporters::dashaslocationinreporterspecsendsoutputtostdout", "have_flag__wcast_align", "have_flag__wmisleading_indentation", "regressioncheck-1670", "have_flag__wmissing_noreturn", "list::listeners::output", "have_flag__wsuggest_override", "benchmarking::skipbenchmarkmacros", "reporters::unrecognizedoptioninspeccauseserror", "tagalias", "have_flag__wreorder", "list::reporters::output", "have_flag__wunused_function", "list::tests::xmloutput", "list::tags::exitcode", "warnings::unmatchedtestspecisaccepted", "reporters:filters:xml", "list::listeners::xmloutput", "escapespecialcharactersintestnames", "have_flag__wparentheses", "warnings::multiplewarningscanbespecified", "reporters::reporterspecificcolouroverridesdefaultcolour", "have_flag__wredundant_decls", "errorhandling::invalidtestspecexitsearly", "have_flag__wextra_semi", "have_flag__wundef", "multireporter::capturingreportersdontpropagatestdout", "multireporter::noncapturingreporterspropagatestdout", "testspecs::overridefailurewithnomatchedtests", "have_flag__wdeprecated", "reporters::junit::namespacesarenormalized", "reporters:rngseed:junit", "reporters:filters:junit", "versioncheck", "have_flag__wunused_parameter", "checkconvenienceheaders", "list::tags::output", "have_flag__wpedantic", "list::tests::exitcode", "reporters:rngseed:sonarqube", "reporters:rngseed:tap", "list::tests::quiet", "have_flag__wc__20_compat", "have_flag__woverloaded_virtual", "have_flag__wshadow", "list::reporters::exitcode", "testspecs::overrideallskipfailure", "filenameastagstest", "have_flag__ffile_prefix_map__home_catch2__", "testspecs::nonmatchingtestspecisroundtrippable", "have_flag__wunused", "have_flag__wcatch_value", "list::reporters::xmloutput", "benchmarking::failurereporting::throwingbenchmark", "filteredsection::generatorsdontcauseinfiniteloop-1"], "failed_tests": ["have_flag__wdeprecated_register", "have_flag__wdangling", "have_flag__wsuggest_destructor_override", "have_flag__wglobal_constructors", "have_flag__wmissing_prototypes", "have_flag__wreturn_std_move", "have_flag__wabsolute_value", "have_flag__wweak_vtables", "have_flag__wunneeded_internal_declaration", "have_flag__wmismatched_return_types", "have_flag__wcall_to_pure_virtual_from_ctor_dtor", "have_flag__wunreachable_code_aggressive", "have_flag__wmissing_variable_declarations", "have_flag__wexit_time_destructors"], "skipped_tests": []}, "test_patch_result": {"passed_count": 100, "failed_count": 16, "skipped_count": 0, "passed_tests": ["testspecs::nomatchedtestsfail", "randomtestordering", "libidentitytest", "have_flag__wfloat_equal", "reporters:rngseed:compact", "reporters:rngseed:xml", "unmatchedoutputfilter", "have_flag__wmissing_declarations", "filenameastagsmatching", "have_flag__wmismatched_tags", "list::tests::output", "have_flag__wold_style_cast", "have_flag__wstrict_aliasing", "noassertions", "benchmarking::failurereporting::failedassertion", "reporters:rngseed:console", "testspecs::combiningmatchingandnonmatchingisok-2", "testsinfile::escapespecialcharacters", "testsinfile::invalidtestnames-1", "filteredsection-2", "list::tags::xmloutput", "colours::colourmodecanbeexplicitlysettoansi", "reporters:filters:console", "have_flag__wuninitialized", "have_flag__wmismatched_new_delete", "have_flag__wexceptions", "filteredsection-1", "benchmarking::failurereporting::failmacro", "reporters:filters:sonarqube", "have_flag__winit_self", "have_flag__wextra", "list::listeners::exitcode", "reporters:filters:compact", "testspecs::warnunmatchedtestspecfailswithunmatchedtestspec", "benchmarking::failurereporting::shouldfailisrespected", "have_flag__wvla", "have_flag__wall", "negativespecnohiddentests", "outputs::dashasoutlocationsendsoutputtostdout", "filteredsection::generatorsdontcauseinfiniteloop-2", "have_flag__wnull_dereference", "testspecs::combiningmatchingandnonmatchingisok-1", "have_flag__wmissing_braces", "reporters:filters:tap", "testsinfile::simplespecs", "reporters::dashaslocationinreporterspecsendsoutputtostdout", "have_flag__wcast_align", "have_flag__wmisleading_indentation", "regressioncheck-1670", "have_flag__wmissing_noreturn", "list::listeners::output", "have_flag__wsuggest_override", "benchmarking::skipbenchmarkmacros", "reporters::unrecognizedoptioninspeccauseserror", "tagalias", "have_flag__wreorder", "list::reporters::output", "have_flag__wunused_function", "list::tests::xmloutput", "list::tags::exitcode", "warnings::unmatchedtestspecisaccepted", "reporters:filters:xml", "list::listeners::xmloutput", "escapespecialcharactersintestnames", "have_flag__wparentheses", "warnings::multiplewarningscanbespecified", "reporters::reporterspecificcolouroverridesdefaultcolour", "have_flag__wredundant_decls", "errorhandling::invalidtestspecexitsearly", "have_flag__wextra_semi", "have_flag__wundef", "multireporter::capturingreportersdontpropagatestdout", "multireporter::noncapturingreporterspropagatestdout", "testspecs::overridefailurewithnomatchedtests", "have_flag__wdeprecated", "reporters::junit::namespacesarenormalized", "reporters:rngseed:junit", "reporters:filters:junit", "versioncheck", "have_flag__wunused_parameter", "checkconvenienceheaders", "list::tags::output", "have_flag__wpedantic", "list::tests::exitcode", "reporters:rngseed:sonarqube", "reporters:rngseed:tap", "list::tests::quiet", "have_flag__wc__20_compat", "have_flag__woverloaded_virtual", "have_flag__wshadow", "list::reporters::exitcode", "testspecs::overrideallskipfailure", "filenameastagstest", "have_flag__ffile_prefix_map__home_catch2__", "testspecs::nonmatchingtestspecisroundtrippable", "have_flag__wunused", "have_flag__wcatch_value", "list::reporters::xmloutput", "benchmarking::failurereporting::throwingbenchmark", "filteredsection::generatorsdontcauseinfiniteloop-1"], "failed_tests": ["have_flag__wdeprecated_register", "have_flag__wdangling", "approvaltests", "have_flag__wsuggest_destructor_override", "have_flag__wglobal_constructors", "have_flag__wmissing_prototypes", "have_flag__wreturn_std_move", "have_flag__wabsolute_value", "have_flag__wweak_vtables", "have_flag__wunneeded_internal_declaration", "have_flag__wmismatched_return_types", "runtests", "have_flag__wcall_to_pure_virtual_from_ctor_dtor", "have_flag__wunreachable_code_aggressive", "have_flag__wmissing_variable_declarations", "have_flag__wexit_time_destructors"], "skipped_tests": []}, "fix_patch_result": {"passed_count": 102, "failed_count": 14, "skipped_count": 0, "passed_tests": ["testspecs::nomatchedtestsfail", "randomtestordering", "libidentitytest", "have_flag__wfloat_equal", "reporters:rngseed:compact", "reporters:rngseed:xml", "unmatchedoutputfilter", "have_flag__wmissing_declarations", "filenameastagsmatching", "have_flag__wmismatched_tags", "list::tests::output", "have_flag__wold_style_cast", "have_flag__wstrict_aliasing", "noassertions", "benchmarking::failurereporting::failedassertion", "reporters:rngseed:console", "runtests", "testspecs::combiningmatchingandnonmatchingisok-2", "testsinfile::escapespecialcharacters", "testsinfile::invalidtestnames-1", "filteredsection-2", "list::tags::xmloutput", "colours::colourmodecanbeexplicitlysettoansi", "reporters:filters:console", "have_flag__wuninitialized", "have_flag__wmismatched_new_delete", "have_flag__wexceptions", "filteredsection-1", "benchmarking::failurereporting::failmacro", "reporters:filters:sonarqube", "have_flag__winit_self", "have_flag__wextra", "list::listeners::exitcode", "reporters:filters:compact", "approvaltests", "testspecs::warnunmatchedtestspecfailswithunmatchedtestspec", "benchmarking::failurereporting::shouldfailisrespected", "have_flag__wvla", "have_flag__wall", "negativespecnohiddentests", "outputs::dashasoutlocationsendsoutputtostdout", "filteredsection::generatorsdontcauseinfiniteloop-2", "have_flag__wnull_dereference", "testspecs::combiningmatchingandnonmatchingisok-1", "have_flag__wmissing_braces", "reporters:filters:tap", "testsinfile::simplespecs", "reporters::dashaslocationinreporterspecsendsoutputtostdout", "have_flag__wcast_align", "have_flag__wmisleading_indentation", "regressioncheck-1670", "have_flag__wmissing_noreturn", "list::listeners::output", "have_flag__wsuggest_override", "benchmarking::skipbenchmarkmacros", "reporters::unrecognizedoptioninspeccauseserror", "tagalias", "have_flag__wreorder", "list::reporters::output", "have_flag__wunused_function", "list::tests::xmloutput", "list::tags::exitcode", "warnings::unmatchedtestspecisaccepted", "reporters:filters:xml", "list::listeners::xmloutput", "escapespecialcharactersintestnames", "have_flag__wparentheses", "warnings::multiplewarningscanbespecified", "reporters::reporterspecificcolouroverridesdefaultcolour", "have_flag__wredundant_decls", "errorhandling::invalidtestspecexitsearly", "have_flag__wextra_semi", "have_flag__wundef", "multireporter::capturingreportersdontpropagatestdout", "multireporter::noncapturingreporterspropagatestdout", "testspecs::overridefailurewithnomatchedtests", "have_flag__wdeprecated", "reporters::junit::namespacesarenormalized", "reporters:rngseed:junit", "reporters:filters:junit", "versioncheck", "have_flag__wunused_parameter", "checkconvenienceheaders", "list::tags::output", "have_flag__wpedantic", "list::tests::exitcode", "reporters:rngseed:sonarqube", "reporters:rngseed:tap", "list::tests::quiet", "have_flag__wc__20_compat", "have_flag__woverloaded_virtual", "have_flag__wshadow", "list::reporters::exitcode", "testspecs::overrideallskipfailure", "filenameastagstest", "have_flag__ffile_prefix_map__home_catch2__", "testspecs::nonmatchingtestspecisroundtrippable", "have_flag__wunused", "have_flag__wcatch_value", "list::reporters::xmloutput", "benchmarking::failurereporting::throwingbenchmark", "filteredsection::generatorsdontcauseinfiniteloop-1"], "failed_tests": ["have_flag__wdeprecated_register", "have_flag__wdangling", "have_flag__wsuggest_destructor_override", "have_flag__wglobal_constructors", "have_flag__wmissing_prototypes", "have_flag__wreturn_std_move", "have_flag__wabsolute_value", "have_flag__wweak_vtables", "have_flag__wunneeded_internal_declaration", "have_flag__wmismatched_return_types", "have_flag__wcall_to_pure_virtual_from_ctor_dtor", "have_flag__wunreachable_code_aggressive", "have_flag__wmissing_variable_declarations", "have_flag__wexit_time_destructors"], "skipped_tests": []}, "instance_id": "catchorg__Catch2-2723"}
{"org": "catchorg", "repo": "Catch2", "number": 2394, "state": "closed", "title": "Added TestCaseInfoHasher and tests.", "body": "This PR tries to fix #2304 \"Test case name hashing should consider tags and class name too\".\r\nThe goal is to \"allow test cases with same name, but different tags, or same names and tags but different class name\".\r\n\r\nSee the following code example that describes what is wanted:\r\n\r\n```cpp\r\nCatch::StringRef className1{std::string(\"C1\")};\r\nCatch::NameAndTags nameAndTag1{std::string(\"N1\"), std::string(\"[T1]\")};\r\n\r\nCatch::StringRef className2{std::string(\"C2\")};\r\nCatch::NameAndTags nameAndTag2{std::string(\"N2\"), std::string(\"[T2]\")};\r\n```\r\n\r\nthis set of test cases satisfies the wanted unique test case invariant as soon as:\r\n\r\n```\r\nif (N1 == N2 || C1 == C2) then [T1] != [T2]\r\nAND\r\nif (C1 == C2 || [T1] == [T2]) then N1 != N2\r\n```\r\n\r\nBefore this PR, the code behaves as follows:\r\nWhen `TestRunOrder::Randomized` is set, `getAllTestsSorted()` does the following:\r\n1) Use `TestHasher` hash the class name of a `TestCaseInfo` (using the FNV-1a algorithm) and push them to a vector.\r\n2) Sort the vector by the hashes, on equality, compare name, if equal compare class name, if also equal compare tags.\r\n\r\nAfter this PR, the code behaves as follows:\r\nWhen `TestRunOrder::Randomized` is set, `getAllTestsSorted()` does the following:\r\n1) Use `TestCaseInfoHasher` to generate hashes that considers class name, name and tag and push them to a vector.\r\n2) Sorting the vector by the hashes. When the unique test case invariant described above is satisfied, the hashes will be unique.\r\n\r\nThis is my first contribution to Catch2, hope i went in the right direction and would be happy about feedback, comments, etc.\r\n", "base": {"label": "catchorg:devel", "ref": "devel", "sha": "1a8a793178d50b74b0f9a0adb3eec937b61039a9"}, "resolved_issues": [{"number": 2304, "title": "Test case name hashing should consider tags and class name too", "body": "**Describe the bug**\r\nRecently I changed the \"unique test case\" criteria to allow test cases with same name, but different tags, or same names and tags but different class name (when a test case hangs off a type).\r\n\r\nHowever, we also hash test cases when ordering them randomly (to get subset-stable ordering), and the hashing currently only considers test case name, which means that hash collisions are now much more realistic (in fact the collision is guaranteed if two test cases have same name, which is a desired property by some users).\r\n\r\n_Note that this doesn't break the subset invariant, because we use the ordering of test case infos to break ties, which handles tags and class name properly_\r\n\r\n**Expected behavior**\r\nTo fix this, the hasher should also consider tags and class name.\r\n\r\n**Additional context**\r\nThis change also makes the hasher complex enough that it should be promoted to a header and receive direct unit tests."}], "fix_patch": "diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt\nindex 78d95956dd..16efa3fe18 100644\n--- a/src/CMakeLists.txt\n+++ b/src/CMakeLists.txt\n@@ -157,6 +157,7 @@ set(INTERNAL_HEADERS\n     ${SOURCES_DIR}/internal/catch_wildcard_pattern.hpp\n     ${SOURCES_DIR}/internal/catch_windows_h_proxy.hpp\n     ${SOURCES_DIR}/internal/catch_xmlwriter.hpp\n+    ${SOURCES_DIR}/internal/catch_test_case_info_hasher.hpp\n )\n set(IMPL_SOURCES\n     ${SOURCES_DIR}/catch_approx.cpp\n@@ -213,6 +214,7 @@ set(IMPL_SOURCES\n     ${SOURCES_DIR}/catch_version.cpp\n     ${SOURCES_DIR}/internal/catch_wildcard_pattern.cpp\n     ${SOURCES_DIR}/internal/catch_xmlwriter.cpp\n+    ${SOURCES_DIR}/internal/catch_test_case_info_hasher.cpp\n )\n set(INTERNAL_FILES ${IMPL_SOURCES} ${INTERNAL_HEADERS})\n \ndiff --git a/src/catch2/catch_all.hpp b/src/catch2/catch_all.hpp\nindex 92cdc205da..656417f485 100644\n--- a/src/catch2/catch_all.hpp\n+++ b/src/catch2/catch_all.hpp\n@@ -95,6 +95,7 @@\n #include <catch2/internal/catch_stringref.hpp>\n #include <catch2/internal/catch_tag_alias_registry.hpp>\n #include <catch2/internal/catch_template_test_registry.hpp>\n+#include <catch2/internal/catch_test_case_info_hasher.hpp>\n #include <catch2/internal/catch_test_case_registry_impl.hpp>\n #include <catch2/internal/catch_test_case_tracker.hpp>\n #include <catch2/internal/catch_test_failure_exception.hpp>\n", "test_patch": "diff --git a/src/catch2/internal/catch_test_case_info_hasher.cpp b/src/catch2/internal/catch_test_case_info_hasher.cpp\nnew file mode 100644\nindex 0000000000..75acc978bc\n--- /dev/null\n+++ b/src/catch2/internal/catch_test_case_info_hasher.cpp\n@@ -0,0 +1,31 @@\n+#include <catch2/catch_test_case_info.hpp>\n+#include <catch2/internal/catch_test_case_info_hasher.hpp>\n+\n+namespace Catch {\n+    TestCaseInfoHasher::TestCaseInfoHasher( hash_t seed ): m_seed( seed ) {}\n+\n+    uint32_t TestCaseInfoHasher::operator()( TestCaseInfo const& t ) const {\n+        // FNV-1a hash algorithm that is designed for uniqueness:\n+        const hash_t prime = 1099511628211u;\n+        hash_t hash = 14695981039346656037u;\n+        for ( const char c : t.name ) {\n+            hash ^= c;\n+            hash *= prime;\n+        }\n+        for ( const char c : t.className ) {\n+            hash ^= c;\n+            hash *= prime;\n+        }\n+        for ( const Tag& tag : t.tags ) {\n+            for ( const char c : tag.original ) {\n+                hash ^= c;\n+                hash *= prime;\n+            }\n+        }\n+        hash ^= m_seed;\n+        hash *= prime;\n+        const uint32_t low{ static_cast<uint32_t>( hash ) };\n+        const uint32_t high{ static_cast<uint32_t>( hash >> 32 ) };\n+        return low * high;\n+    }\n+} // namespace Catch\ndiff --git a/src/catch2/internal/catch_test_case_info_hasher.hpp b/src/catch2/internal/catch_test_case_info_hasher.hpp\nnew file mode 100644\nindex 0000000000..954bdcdebd\n--- /dev/null\n+++ b/src/catch2/internal/catch_test_case_info_hasher.hpp\n@@ -0,0 +1,22 @@\n+#ifndef CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED\n+#define CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED\n+\n+#include <cstdint>\n+\n+namespace Catch {\n+\n+    struct TestCaseInfo;\n+\n+    class TestCaseInfoHasher {\n+    public:\n+        using hash_t = std::uint64_t;\n+        TestCaseInfoHasher( hash_t seed );\n+        uint32_t operator()( TestCaseInfo const& t ) const;\n+\n+    private:\n+        hash_t m_seed;\n+    };\n+\n+} // namespace Catch\n+\n+#endif /* CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED */\ndiff --git a/src/catch2/internal/catch_test_case_registry_impl.cpp b/src/catch2/internal/catch_test_case_registry_impl.cpp\nindex 3c1ab54b2a..6c491a959f 100644\n--- a/src/catch2/internal/catch_test_case_registry_impl.cpp\n+++ b/src/catch2/internal/catch_test_case_registry_impl.cpp\n@@ -16,38 +16,13 @@\n #include <catch2/catch_test_case_info.hpp>\n #include <catch2/catch_test_spec.hpp>\n #include <catch2/internal/catch_move_and_forward.hpp>\n+#include <catch2/internal/catch_test_case_info_hasher.hpp>\n \n #include <algorithm>\n #include <set>\n \n namespace Catch {\n \n-namespace {\n-    struct TestHasher {\n-        using hash_t = uint64_t;\n-\n-        explicit TestHasher( hash_t hashSuffix ):\n-            m_hashSuffix( hashSuffix ) {}\n-\n-        uint64_t m_hashSuffix;\n-\n-        uint32_t operator()( TestCaseInfo const& t ) const {\n-            // FNV-1a hash with multiplication fold.\n-            const hash_t prime = 1099511628211u;\n-            hash_t hash = 14695981039346656037u;\n-            for (const char c : t.name) {\n-                hash ^= c;\n-                hash *= prime;\n-            }\n-            hash ^= m_hashSuffix;\n-            hash *= prime;\n-            const uint32_t low{ static_cast<uint32_t>(hash) };\n-            const uint32_t high{ static_cast<uint32_t>(hash >> 32) };\n-            return low * high;\n-        }\n-    };\n-} // end anonymous namespace\n-\n     std::vector<TestCaseHandle> sortTests( IConfig const& config, std::vector<TestCaseHandle> const& unsortedTestCases ) {\n         switch (config.runOrder()) {\n         case TestRunOrder::Declared:\n@@ -66,9 +41,9 @@ namespace {\n         }\n         case TestRunOrder::Randomized: {\n             seedRng(config);\n-            using TestWithHash = std::pair<TestHasher::hash_t, TestCaseHandle>;\n+            using TestWithHash = std::pair<TestCaseInfoHasher::hash_t, TestCaseHandle>;\n \n-            TestHasher h{ config.rngSeed() };\n+            TestCaseInfoHasher h{ config.rngSeed() };\n             std::vector<TestWithHash> indexed_tests;\n             indexed_tests.reserve(unsortedTestCases.size());\n \ndiff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\nindex ef1b13eae9..1c52012038 100644\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -88,6 +88,7 @@ set(TEST_SOURCES\n         ${SELF_TEST_DIR}/IntrospectiveTests/RandomNumberGeneration.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Reporters.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Tag.tests.cpp\n+        ${SELF_TEST_DIR}/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/TestSpecParser.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/TextFlow.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Sharding.tests.cpp\ndiff --git a/tests/SelfTest/Baselines/automake.sw.approved.txt b/tests/SelfTest/Baselines/automake.sw.approved.txt\nindex fadb274770..9df8be0df1 100644\n--- a/tests/SelfTest/Baselines/automake.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/automake.sw.approved.txt\n@@ -255,6 +255,8 @@ Message from section two\n :test-result: PASS Test case with one argument\n :test-result: PASS Test enum bit values\n :test-result: PASS Test with special, characters \"in name\n+:test-result: PASS TestCaseInfoHasher produces different hashes.\n+:test-result: PASS TestCaseInfoHasher produces equal hashes.\n :test-result: PASS Testing checked-if\n :test-result: XFAIL Testing checked-if 2\n :test-result: XFAIL Testing checked-if 3\ndiff --git a/tests/SelfTest/Baselines/automake.sw.multi.approved.txt b/tests/SelfTest/Baselines/automake.sw.multi.approved.txt\nindex f05de0ab8c..10db54cd22 100644\n--- a/tests/SelfTest/Baselines/automake.sw.multi.approved.txt\n+++ b/tests/SelfTest/Baselines/automake.sw.multi.approved.txt\n@@ -248,6 +248,8 @@\n :test-result: PASS Test case with one argument\n :test-result: PASS Test enum bit values\n :test-result: PASS Test with special, characters \"in name\n+:test-result: PASS TestCaseInfoHasher produces different hashes.\n+:test-result: PASS TestCaseInfoHasher produces equal hashes.\n :test-result: PASS Testing checked-if\n :test-result: XFAIL Testing checked-if 2\n :test-result: XFAIL Testing checked-if 3\ndiff --git a/tests/SelfTest/Baselines/compact.sw.approved.txt b/tests/SelfTest/Baselines/compact.sw.approved.txt\nindex 4688a2289f..8b404c58d5 100644\n--- a/tests/SelfTest/Baselines/compact.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/compact.sw.approved.txt\n@@ -1868,6 +1868,21 @@ Tag.tests.cpp:<line number>: passed: testCase.tags[0] == Tag( \"tag1\" ) for: {?}\n VariadicMacros.tests.cpp:<line number>: passed: with 1 message: 'no assertions'\n Tricky.tests.cpp:<line number>: passed: 0x<hex digits> == bit30and31 for: 3221225472 (0x<hex digits>) == 3221225472\n CmdLine.tests.cpp:<line number>: passed:\n+TestCaseInfoHasher.tests.cpp:<line number>: passed: hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2) for: 764519552 (0x<hex digits>)\n+!=\n+3472848544 (0x<hex digits>)\n+TestCaseInfoHasher.tests.cpp:<line number>: passed: hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2) for: 869111496 (0x<hex digits>)\n+!=\n+2870097333 (0x<hex digits>)\n+TestCaseInfoHasher.tests.cpp:<line number>: passed: hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2) for: 1172537240 (0x<hex digits>)\n+!=\n+1403724645 (0x<hex digits>)\n+TestCaseInfoHasher.tests.cpp:<line number>: passed: h1(testCase1) != h2(testCase2) for: 1836497244 (0x<hex digits>)\n+!=\n+430288597 (0x<hex digits>)\n+TestCaseInfoHasher.tests.cpp:<line number>: passed: hasherWithCustomSeed(testCase1) == hasherWithCustomSeed(testCase2) for: 764519552 (0x<hex digits>)\n+==\n+764519552 (0x<hex digits>)\n Misc.tests.cpp:<line number>: passed: true\n Misc.tests.cpp:<line number>: passed:\n Misc.tests.cpp:<line number>: failed - but was ok: false\ndiff --git a/tests/SelfTest/Baselines/compact.sw.multi.approved.txt b/tests/SelfTest/Baselines/compact.sw.multi.approved.txt\nindex c571b0c9c8..3b3e1eef40 100644\n--- a/tests/SelfTest/Baselines/compact.sw.multi.approved.txt\n+++ b/tests/SelfTest/Baselines/compact.sw.multi.approved.txt\n@@ -1861,6 +1861,21 @@ Tag.tests.cpp:<line number>: passed: testCase.tags[0] == Tag( \"tag1\" ) for: {?}\n VariadicMacros.tests.cpp:<line number>: passed: with 1 message: 'no assertions'\n Tricky.tests.cpp:<line number>: passed: 0x<hex digits> == bit30and31 for: 3221225472 (0x<hex digits>) == 3221225472\n CmdLine.tests.cpp:<line number>: passed:\n+TestCaseInfoHasher.tests.cpp:<line number>: passed: hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2) for: 764519552 (0x<hex digits>)\n+!=\n+3472848544 (0x<hex digits>)\n+TestCaseInfoHasher.tests.cpp:<line number>: passed: hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2) for: 869111496 (0x<hex digits>)\n+!=\n+2870097333 (0x<hex digits>)\n+TestCaseInfoHasher.tests.cpp:<line number>: passed: hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2) for: 1172537240 (0x<hex digits>)\n+!=\n+1403724645 (0x<hex digits>)\n+TestCaseInfoHasher.tests.cpp:<line number>: passed: h1(testCase1) != h2(testCase2) for: 1836497244 (0x<hex digits>)\n+!=\n+430288597 (0x<hex digits>)\n+TestCaseInfoHasher.tests.cpp:<line number>: passed: hasherWithCustomSeed(testCase1) == hasherWithCustomSeed(testCase2) for: 764519552 (0x<hex digits>)\n+==\n+764519552 (0x<hex digits>)\n Misc.tests.cpp:<line number>: passed: true\n Misc.tests.cpp:<line number>: passed:\n Misc.tests.cpp:<line number>: failed - but was ok: false\ndiff --git a/tests/SelfTest/Baselines/console.std.approved.txt b/tests/SelfTest/Baselines/console.std.approved.txt\nindex ca0a77e599..61b1a11230 100644\n--- a/tests/SelfTest/Baselines/console.std.approved.txt\n+++ b/tests/SelfTest/Baselines/console.std.approved.txt\n@@ -1395,6 +1395,6 @@ due to unexpected exception with message:\n   Why would you throw a std::string?\n \n ===============================================================================\n-test cases:  386 |  310 passed |  69 failed |  7 failed as expected\n-assertions: 2219 | 2064 passed | 128 failed | 27 failed as expected\n+test cases:  388 |  312 passed |  69 failed |  7 failed as expected\n+assertions: 2224 | 2069 passed | 128 failed | 27 failed as expected\n \ndiff --git a/tests/SelfTest/Baselines/console.sw.approved.txt b/tests/SelfTest/Baselines/console.sw.approved.txt\nindex 5655f50ab7..148a3b5388 100644\n--- a/tests/SelfTest/Baselines/console.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/console.sw.approved.txt\n@@ -13286,6 +13286,76 @@ CmdLine.tests.cpp:<line number>\n \n CmdLine.tests.cpp:<line number>: PASSED:\n \n+-------------------------------------------------------------------------------\n+TestCaseInfoHasher produces different hashes.\n+  class names are equal, names are equal but tags are different.\n+-------------------------------------------------------------------------------\n+TestCaseInfoHasher.tests.cpp:<line number>\n+...............................................................................\n+\n+TestCaseInfoHasher.tests.cpp:<line number>: PASSED:\n+  CHECK( hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2) )\n+with expansion:\n+  764519552 (0x<hex digits>)\n+  !=\n+  3472848544 (0x<hex digits>)\n+\n+-------------------------------------------------------------------------------\n+TestCaseInfoHasher produces different hashes.\n+  class names are equal, tags are equal but names are different\n+-------------------------------------------------------------------------------\n+TestCaseInfoHasher.tests.cpp:<line number>\n+...............................................................................\n+\n+TestCaseInfoHasher.tests.cpp:<line number>: PASSED:\n+  CHECK( hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2) )\n+with expansion:\n+  869111496 (0x<hex digits>)\n+  !=\n+  2870097333 (0x<hex digits>)\n+\n+-------------------------------------------------------------------------------\n+TestCaseInfoHasher produces different hashes.\n+  names are equal, tags are equal but class names are different\n+-------------------------------------------------------------------------------\n+TestCaseInfoHasher.tests.cpp:<line number>\n+...............................................................................\n+\n+TestCaseInfoHasher.tests.cpp:<line number>: PASSED:\n+  CHECK( hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2) )\n+with expansion:\n+  1172537240 (0x<hex digits>)\n+  !=\n+  1403724645 (0x<hex digits>)\n+\n+-------------------------------------------------------------------------------\n+TestCaseInfoHasher produces different hashes.\n+  class names and names and tags are equal but hashers are seeded differently.\n+-------------------------------------------------------------------------------\n+TestCaseInfoHasher.tests.cpp:<line number>\n+...............................................................................\n+\n+TestCaseInfoHasher.tests.cpp:<line number>: PASSED:\n+  CHECK( h1(testCase1) != h2(testCase2) )\n+with expansion:\n+  1836497244 (0x<hex digits>)\n+  !=\n+  430288597 (0x<hex digits>)\n+\n+-------------------------------------------------------------------------------\n+TestCaseInfoHasher produces equal hashes.\n+  class names and names and tags are equal.\n+-------------------------------------------------------------------------------\n+TestCaseInfoHasher.tests.cpp:<line number>\n+...............................................................................\n+\n+TestCaseInfoHasher.tests.cpp:<line number>: PASSED:\n+  CHECK( hasherWithCustomSeed(testCase1) == hasherWithCustomSeed(testCase2) )\n+with expansion:\n+  764519552 (0x<hex digits>)\n+  ==\n+  764519552 (0x<hex digits>)\n+\n -------------------------------------------------------------------------------\n Testing checked-if\n -------------------------------------------------------------------------------\n@@ -17871,6 +17941,6 @@ Misc.tests.cpp:<line number>\n Misc.tests.cpp:<line number>: PASSED:\n \n ===============================================================================\n-test cases:  386 |  296 passed |  83 failed |  7 failed as expected\n-assertions: 2234 | 2064 passed | 143 failed | 27 failed as expected\n+test cases:  388 |  298 passed |  83 failed |  7 failed as expected\n+assertions: 2239 | 2069 passed | 143 failed | 27 failed as expected\n \ndiff --git a/tests/SelfTest/Baselines/console.sw.multi.approved.txt b/tests/SelfTest/Baselines/console.sw.multi.approved.txt\nindex 32fa068957..412303da9b 100644\n--- a/tests/SelfTest/Baselines/console.sw.multi.approved.txt\n+++ b/tests/SelfTest/Baselines/console.sw.multi.approved.txt\n@@ -13279,6 +13279,76 @@ CmdLine.tests.cpp:<line number>\n \n CmdLine.tests.cpp:<line number>: PASSED:\n \n+-------------------------------------------------------------------------------\n+TestCaseInfoHasher produces different hashes.\n+  class names are equal, names are equal but tags are different.\n+-------------------------------------------------------------------------------\n+TestCaseInfoHasher.tests.cpp:<line number>\n+...............................................................................\n+\n+TestCaseInfoHasher.tests.cpp:<line number>: PASSED:\n+  CHECK( hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2) )\n+with expansion:\n+  764519552 (0x<hex digits>)\n+  !=\n+  3472848544 (0x<hex digits>)\n+\n+-------------------------------------------------------------------------------\n+TestCaseInfoHasher produces different hashes.\n+  class names are equal, tags are equal but names are different\n+-------------------------------------------------------------------------------\n+TestCaseInfoHasher.tests.cpp:<line number>\n+...............................................................................\n+\n+TestCaseInfoHasher.tests.cpp:<line number>: PASSED:\n+  CHECK( hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2) )\n+with expansion:\n+  869111496 (0x<hex digits>)\n+  !=\n+  2870097333 (0x<hex digits>)\n+\n+-------------------------------------------------------------------------------\n+TestCaseInfoHasher produces different hashes.\n+  names are equal, tags are equal but class names are different\n+-------------------------------------------------------------------------------\n+TestCaseInfoHasher.tests.cpp:<line number>\n+...............................................................................\n+\n+TestCaseInfoHasher.tests.cpp:<line number>: PASSED:\n+  CHECK( hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2) )\n+with expansion:\n+  1172537240 (0x<hex digits>)\n+  !=\n+  1403724645 (0x<hex digits>)\n+\n+-------------------------------------------------------------------------------\n+TestCaseInfoHasher produces different hashes.\n+  class names and names and tags are equal but hashers are seeded differently.\n+-------------------------------------------------------------------------------\n+TestCaseInfoHasher.tests.cpp:<line number>\n+...............................................................................\n+\n+TestCaseInfoHasher.tests.cpp:<line number>: PASSED:\n+  CHECK( h1(testCase1) != h2(testCase2) )\n+with expansion:\n+  1836497244 (0x<hex digits>)\n+  !=\n+  430288597 (0x<hex digits>)\n+\n+-------------------------------------------------------------------------------\n+TestCaseInfoHasher produces equal hashes.\n+  class names and names and tags are equal.\n+-------------------------------------------------------------------------------\n+TestCaseInfoHasher.tests.cpp:<line number>\n+...............................................................................\n+\n+TestCaseInfoHasher.tests.cpp:<line number>: PASSED:\n+  CHECK( hasherWithCustomSeed(testCase1) == hasherWithCustomSeed(testCase2) )\n+with expansion:\n+  764519552 (0x<hex digits>)\n+  ==\n+  764519552 (0x<hex digits>)\n+\n -------------------------------------------------------------------------------\n Testing checked-if\n -------------------------------------------------------------------------------\n@@ -17863,6 +17933,6 @@ Misc.tests.cpp:<line number>\n Misc.tests.cpp:<line number>: PASSED:\n \n ===============================================================================\n-test cases:  386 |  296 passed |  83 failed |  7 failed as expected\n-assertions: 2234 | 2064 passed | 143 failed | 27 failed as expected\n+test cases:  388 |  298 passed |  83 failed |  7 failed as expected\n+assertions: 2239 | 2069 passed | 143 failed | 27 failed as expected\n \ndiff --git a/tests/SelfTest/Baselines/junit.sw.approved.txt b/tests/SelfTest/Baselines/junit.sw.approved.txt\nindex 3a099b4f84..7c82e5b3a9 100644\n--- a/tests/SelfTest/Baselines/junit.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/junit.sw.approved.txt\n@@ -1,7 +1,7 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <testsuitesloose text artifact\n >\n-  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"126\" tests=\"2234\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n+  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"126\" tests=\"2239\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n     <properties>\n       <property name=\"random-seed\" value=\"1\"/>\n       <property name=\"filters\" value=\"~[!nonportable]~[!benchmark]~[approvals] *\"/>\n@@ -1355,6 +1355,11 @@ Misc.tests.cpp:<line number>\n     <testcase classname=\"<exe-name>.global\" name=\"Test case with one argument\" time=\"{duration}\" status=\"run\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Test enum bit values\" time=\"{duration}\" status=\"run\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Test with special, characters &quot;in name\" time=\"{duration}\" status=\"run\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TestCaseInfoHasher produces different hashes./class names are equal, names are equal but tags are different.\" time=\"{duration}\" status=\"run\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TestCaseInfoHasher produces different hashes./class names are equal, tags are equal but names are different\" time=\"{duration}\" status=\"run\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TestCaseInfoHasher produces different hashes./names are equal, tags are equal but class names are different\" time=\"{duration}\" status=\"run\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TestCaseInfoHasher produces different hashes./class names and names and tags are equal but hashers are seeded differently.\" time=\"{duration}\" status=\"run\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TestCaseInfoHasher produces equal hashes./class names and names and tags are equal.\" time=\"{duration}\" status=\"run\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Testing checked-if\" time=\"{duration}\" status=\"run\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Testing checked-if 2\" time=\"{duration}\" status=\"run\">\n       <skipped message=\"TEST_CASE tagged with !mayfail\"/>\ndiff --git a/tests/SelfTest/Baselines/junit.sw.multi.approved.txt b/tests/SelfTest/Baselines/junit.sw.multi.approved.txt\nindex 527f7ba0d6..d850f16a42 100644\n--- a/tests/SelfTest/Baselines/junit.sw.multi.approved.txt\n+++ b/tests/SelfTest/Baselines/junit.sw.multi.approved.txt\n@@ -1,6 +1,6 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <testsuites>\n-  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"126\" tests=\"2234\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n+  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"126\" tests=\"2239\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n     <properties>\n       <property name=\"random-seed\" value=\"1\"/>\n       <property name=\"filters\" value=\"~[!nonportable]~[!benchmark]~[approvals] *\"/>\n@@ -1354,6 +1354,11 @@ Misc.tests.cpp:<line number>\n     <testcase classname=\"<exe-name>.global\" name=\"Test case with one argument\" time=\"{duration}\" status=\"run\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Test enum bit values\" time=\"{duration}\" status=\"run\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Test with special, characters &quot;in name\" time=\"{duration}\" status=\"run\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TestCaseInfoHasher produces different hashes./class names are equal, names are equal but tags are different.\" time=\"{duration}\" status=\"run\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TestCaseInfoHasher produces different hashes./class names are equal, tags are equal but names are different\" time=\"{duration}\" status=\"run\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TestCaseInfoHasher produces different hashes./names are equal, tags are equal but class names are different\" time=\"{duration}\" status=\"run\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TestCaseInfoHasher produces different hashes./class names and names and tags are equal but hashers are seeded differently.\" time=\"{duration}\" status=\"run\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TestCaseInfoHasher produces equal hashes./class names and names and tags are equal.\" time=\"{duration}\" status=\"run\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Testing checked-if\" time=\"{duration}\" status=\"run\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Testing checked-if 2\" time=\"{duration}\" status=\"run\">\n       <skipped message=\"TEST_CASE tagged with !mayfail\"/>\ndiff --git a/tests/SelfTest/Baselines/sonarqube.sw.approved.txt b/tests/SelfTest/Baselines/sonarqube.sw.approved.txt\nindex 92db65df57..1a9d215df4 100644\n--- a/tests/SelfTest/Baselines/sonarqube.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/sonarqube.sw.approved.txt\n@@ -273,6 +273,13 @@\n     <testCase name=\"shortened hide tags are split apart\" duration=\"{duration}\"/>\n     <testCase name=\"tags with dots in later positions are not parsed as hidden\" duration=\"{duration}\"/>\n   </file>\n+  <file path=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\">\n+    <testCase name=\"TestCaseInfoHasher produces different hashes./class names are equal, names are equal but tags are different.\" duration=\"{duration}\"/>\n+    <testCase name=\"TestCaseInfoHasher produces different hashes./class names are equal, tags are equal but names are different\" duration=\"{duration}\"/>\n+    <testCase name=\"TestCaseInfoHasher produces different hashes./names are equal, tags are equal but class names are different\" duration=\"{duration}\"/>\n+    <testCase name=\"TestCaseInfoHasher produces different hashes./class names and names and tags are equal but hashers are seeded differently.\" duration=\"{duration}\"/>\n+    <testCase name=\"TestCaseInfoHasher produces equal hashes./class names and names and tags are equal.\" duration=\"{duration}\"/>\n+  </file>\n   <file path=\"tests/<exe-name>/IntrospectiveTests/TestSpecParser.tests.cpp\">\n     <testCase name=\"Parsed tags are matched case insensitive\" duration=\"{duration}\"/>\n     <testCase name=\"Parsing tags with non-alphabetical characters is pass-through\" duration=\"{duration}\"/>\ndiff --git a/tests/SelfTest/Baselines/sonarqube.sw.multi.approved.txt b/tests/SelfTest/Baselines/sonarqube.sw.multi.approved.txt\nindex c9074bf03b..cbefb06363 100644\n--- a/tests/SelfTest/Baselines/sonarqube.sw.multi.approved.txt\n+++ b/tests/SelfTest/Baselines/sonarqube.sw.multi.approved.txt\n@@ -272,6 +272,13 @@\n     <testCase name=\"shortened hide tags are split apart\" duration=\"{duration}\"/>\n     <testCase name=\"tags with dots in later positions are not parsed as hidden\" duration=\"{duration}\"/>\n   </file>\n+  <file path=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\">\n+    <testCase name=\"TestCaseInfoHasher produces different hashes./class names are equal, names are equal but tags are different.\" duration=\"{duration}\"/>\n+    <testCase name=\"TestCaseInfoHasher produces different hashes./class names are equal, tags are equal but names are different\" duration=\"{duration}\"/>\n+    <testCase name=\"TestCaseInfoHasher produces different hashes./names are equal, tags are equal but class names are different\" duration=\"{duration}\"/>\n+    <testCase name=\"TestCaseInfoHasher produces different hashes./class names and names and tags are equal but hashers are seeded differently.\" duration=\"{duration}\"/>\n+    <testCase name=\"TestCaseInfoHasher produces equal hashes./class names and names and tags are equal.\" duration=\"{duration}\"/>\n+  </file>\n   <file path=\"tests/<exe-name>/IntrospectiveTests/TestSpecParser.tests.cpp\">\n     <testCase name=\"Parsed tags are matched case insensitive\" duration=\"{duration}\"/>\n     <testCase name=\"Parsing tags with non-alphabetical characters is pass-through\" duration=\"{duration}\"/>\ndiff --git a/tests/SelfTest/Baselines/tap.sw.approved.txt b/tests/SelfTest/Baselines/tap.sw.approved.txt\nindex 456e80eedf..67ceddfcd9 100644\n--- a/tests/SelfTest/Baselines/tap.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/tap.sw.approved.txt\n@@ -3297,6 +3297,16 @@ ok {test-number} - with 1 message: 'no assertions'\n ok {test-number} - 0x<hex digits> == bit30and31 for: 3221225472 (0x<hex digits>) == 3221225472\n # Test with special, characters \"in name\n ok {test-number} -\n+# TestCaseInfoHasher produces different hashes.\n+ok {test-number} - hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2) for: 764519552 (0x<hex digits>) != 3472848544 (0x<hex digits>)\n+# TestCaseInfoHasher produces different hashes.\n+ok {test-number} - hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2) for: 869111496 (0x<hex digits>) != 2870097333 (0x<hex digits>)\n+# TestCaseInfoHasher produces different hashes.\n+ok {test-number} - hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2) for: 1172537240 (0x<hex digits>) != 1403724645 (0x<hex digits>)\n+# TestCaseInfoHasher produces different hashes.\n+ok {test-number} - h1(testCase1) != h2(testCase2) for: 1836497244 (0x<hex digits>) != 430288597 (0x<hex digits>)\n+# TestCaseInfoHasher produces equal hashes.\n+ok {test-number} - hasherWithCustomSeed(testCase1) == hasherWithCustomSeed(testCase2) for: 764519552 (0x<hex digits>) == 764519552 (0x<hex digits>)\n # Testing checked-if\n ok {test-number} - true\n # Testing checked-if\n@@ -4470,5 +4480,5 @@ ok {test-number} - q3 == 23. for: 23.0 == 23.0\n ok {test-number} -\n # xmlentitycheck\n ok {test-number} -\n-1..2234\n+1..2239\n \ndiff --git a/tests/SelfTest/Baselines/tap.sw.multi.approved.txt b/tests/SelfTest/Baselines/tap.sw.multi.approved.txt\nindex 534005dffc..d369326e51 100644\n--- a/tests/SelfTest/Baselines/tap.sw.multi.approved.txt\n+++ b/tests/SelfTest/Baselines/tap.sw.multi.approved.txt\n@@ -3290,6 +3290,16 @@ ok {test-number} - with 1 message: 'no assertions'\n ok {test-number} - 0x<hex digits> == bit30and31 for: 3221225472 (0x<hex digits>) == 3221225472\n # Test with special, characters \"in name\n ok {test-number} -\n+# TestCaseInfoHasher produces different hashes.\n+ok {test-number} - hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2) for: 764519552 (0x<hex digits>) != 3472848544 (0x<hex digits>)\n+# TestCaseInfoHasher produces different hashes.\n+ok {test-number} - hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2) for: 869111496 (0x<hex digits>) != 2870097333 (0x<hex digits>)\n+# TestCaseInfoHasher produces different hashes.\n+ok {test-number} - hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2) for: 1172537240 (0x<hex digits>) != 1403724645 (0x<hex digits>)\n+# TestCaseInfoHasher produces different hashes.\n+ok {test-number} - h1(testCase1) != h2(testCase2) for: 1836497244 (0x<hex digits>) != 430288597 (0x<hex digits>)\n+# TestCaseInfoHasher produces equal hashes.\n+ok {test-number} - hasherWithCustomSeed(testCase1) == hasherWithCustomSeed(testCase2) for: 764519552 (0x<hex digits>) == 764519552 (0x<hex digits>)\n # Testing checked-if\n ok {test-number} - true\n # Testing checked-if\n@@ -4462,5 +4472,5 @@ ok {test-number} - q3 == 23. for: 23.0 == 23.0\n ok {test-number} -\n # xmlentitycheck\n ok {test-number} -\n-1..2234\n+1..2239\n \ndiff --git a/tests/SelfTest/Baselines/teamcity.sw.approved.txt b/tests/SelfTest/Baselines/teamcity.sw.approved.txt\nindex 43324e060f..d9b98f709b 100644\n--- a/tests/SelfTest/Baselines/teamcity.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/teamcity.sw.approved.txt\n@@ -615,6 +615,10 @@ Misc.tests.cpp:<line number>|nexpression failed|n  CHECK( s1 == s2 )|nwith expan\n ##teamcity[testFinished name='Test enum bit values' duration=\"{duration}\"]\n ##teamcity[testStarted name='Test with special, characters \"in name']\n ##teamcity[testFinished name='Test with special, characters \"in name' duration=\"{duration}\"]\n+##teamcity[testStarted name='TestCaseInfoHasher produces different hashes.']\n+##teamcity[testFinished name='TestCaseInfoHasher produces different hashes.' duration=\"{duration}\"]\n+##teamcity[testStarted name='TestCaseInfoHasher produces equal hashes.']\n+##teamcity[testFinished name='TestCaseInfoHasher produces equal hashes.' duration=\"{duration}\"]\n ##teamcity[testStarted name='Testing checked-if']\n ##teamcity[testFinished name='Testing checked-if' duration=\"{duration}\"]\n ##teamcity[testStarted name='Testing checked-if 2']\ndiff --git a/tests/SelfTest/Baselines/teamcity.sw.multi.approved.txt b/tests/SelfTest/Baselines/teamcity.sw.multi.approved.txt\nindex 3bc028a404..ffdae89ceb 100644\n--- a/tests/SelfTest/Baselines/teamcity.sw.multi.approved.txt\n+++ b/tests/SelfTest/Baselines/teamcity.sw.multi.approved.txt\n@@ -615,6 +615,10 @@ Misc.tests.cpp:<line number>|nexpression failed|n  CHECK( s1 == s2 )|nwith expan\n ##teamcity[testFinished name='Test enum bit values' duration=\"{duration}\"]\n ##teamcity[testStarted name='Test with special, characters \"in name']\n ##teamcity[testFinished name='Test with special, characters \"in name' duration=\"{duration}\"]\n+##teamcity[testStarted name='TestCaseInfoHasher produces different hashes.']\n+##teamcity[testFinished name='TestCaseInfoHasher produces different hashes.' duration=\"{duration}\"]\n+##teamcity[testStarted name='TestCaseInfoHasher produces equal hashes.']\n+##teamcity[testFinished name='TestCaseInfoHasher produces equal hashes.' duration=\"{duration}\"]\n ##teamcity[testStarted name='Testing checked-if']\n ##teamcity[testFinished name='Testing checked-if' duration=\"{duration}\"]\n ##teamcity[testStarted name='Testing checked-if 2']\ndiff --git a/tests/SelfTest/Baselines/xml.sw.approved.txt b/tests/SelfTest/Baselines/xml.sw.approved.txt\nindex f9518c3d0c..4facaec2a9 100644\n--- a/tests/SelfTest/Baselines/xml.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/xml.sw.approved.txt\n@@ -15579,6 +15579,77 @@ Message from section two\n   <TestCase name=\"Test with special, characters &quot;in name\" tags=\"[cli][regression]\" filename=\"tests/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n     <OverallResult success=\"true\"/>\n   </TestCase>\n+  <TestCase name=\"TestCaseInfoHasher produces different hashes.\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+    <Section name=\"class names are equal, names are equal but tags are different.\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+      <Expression success=\"true\" type=\"CHECK\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+        <Original>\n+          hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2)\n+        </Original>\n+        <Expanded>\n+          764519552 (0x<hex digits>)\n+!=\n+3472848544 (0x<hex digits>)\n+        </Expanded>\n+      </Expression>\n+      <OverallResults successes=\"1\" failures=\"0\" expectedFailures=\"0\"/>\n+    </Section>\n+    <Section name=\"class names are equal, tags are equal but names are different\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+      <Expression success=\"true\" type=\"CHECK\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+        <Original>\n+          hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2)\n+        </Original>\n+        <Expanded>\n+          869111496 (0x<hex digits>)\n+!=\n+2870097333 (0x<hex digits>)\n+        </Expanded>\n+      </Expression>\n+      <OverallResults successes=\"1\" failures=\"0\" expectedFailures=\"0\"/>\n+    </Section>\n+    <Section name=\"names are equal, tags are equal but class names are different\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+      <Expression success=\"true\" type=\"CHECK\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+        <Original>\n+          hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2)\n+        </Original>\n+        <Expanded>\n+          1172537240 (0x<hex digits>)\n+!=\n+1403724645 (0x<hex digits>)\n+        </Expanded>\n+      </Expression>\n+      <OverallResults successes=\"1\" failures=\"0\" expectedFailures=\"0\"/>\n+    </Section>\n+    <Section name=\"class names and names and tags are equal but hashers are seeded differently.\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+      <Expression success=\"true\" type=\"CHECK\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+        <Original>\n+          h1(testCase1) != h2(testCase2)\n+        </Original>\n+        <Expanded>\n+          1836497244 (0x<hex digits>)\n+!=\n+430288597 (0x<hex digits>)\n+        </Expanded>\n+      </Expression>\n+      <OverallResults successes=\"1\" failures=\"0\" expectedFailures=\"0\"/>\n+    </Section>\n+    <OverallResult success=\"true\"/>\n+  </TestCase>\n+  <TestCase name=\"TestCaseInfoHasher produces equal hashes.\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+    <Section name=\"class names and names and tags are equal.\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+      <Expression success=\"true\" type=\"CHECK\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+        <Original>\n+          hasherWithCustomSeed(testCase1) == hasherWithCustomSeed(testCase2)\n+        </Original>\n+        <Expanded>\n+          764519552 (0x<hex digits>)\n+==\n+764519552 (0x<hex digits>)\n+        </Expanded>\n+      </Expression>\n+      <OverallResults successes=\"1\" failures=\"0\" expectedFailures=\"0\"/>\n+    </Section>\n+    <OverallResult success=\"true\"/>\n+  </TestCase>\n   <TestCase name=\"Testing checked-if\" tags=\"[checked-if]\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n     <Expression success=\"true\" type=\"CHECKED_IF\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n       <Original>\n@@ -20991,6 +21062,6 @@ loose text artifact\n     </Section>\n     <OverallResult success=\"true\"/>\n   </TestCase>\n-  <OverallResults successes=\"2064\" failures=\"143\" expectedFailures=\"27\"/>\n-  <OverallResultsCases successes=\"296\" failures=\"83\" expectedFailures=\"7\"/>\n+  <OverallResults successes=\"2069\" failures=\"143\" expectedFailures=\"27\"/>\n+  <OverallResultsCases successes=\"298\" failures=\"83\" expectedFailures=\"7\"/>\n </Catch2TestRun>\ndiff --git a/tests/SelfTest/Baselines/xml.sw.multi.approved.txt b/tests/SelfTest/Baselines/xml.sw.multi.approved.txt\nindex 6617afe324..f6b172f590 100644\n--- a/tests/SelfTest/Baselines/xml.sw.multi.approved.txt\n+++ b/tests/SelfTest/Baselines/xml.sw.multi.approved.txt\n@@ -15579,6 +15579,77 @@ Message from section two\n   <TestCase name=\"Test with special, characters &quot;in name\" tags=\"[cli][regression]\" filename=\"tests/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n     <OverallResult success=\"true\"/>\n   </TestCase>\n+  <TestCase name=\"TestCaseInfoHasher produces different hashes.\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+    <Section name=\"class names are equal, names are equal but tags are different.\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+      <Expression success=\"true\" type=\"CHECK\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+        <Original>\n+          hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2)\n+        </Original>\n+        <Expanded>\n+          764519552 (0x<hex digits>)\n+!=\n+3472848544 (0x<hex digits>)\n+        </Expanded>\n+      </Expression>\n+      <OverallResults successes=\"1\" failures=\"0\" expectedFailures=\"0\"/>\n+    </Section>\n+    <Section name=\"class names are equal, tags are equal but names are different\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+      <Expression success=\"true\" type=\"CHECK\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+        <Original>\n+          hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2)\n+        </Original>\n+        <Expanded>\n+          869111496 (0x<hex digits>)\n+!=\n+2870097333 (0x<hex digits>)\n+        </Expanded>\n+      </Expression>\n+      <OverallResults successes=\"1\" failures=\"0\" expectedFailures=\"0\"/>\n+    </Section>\n+    <Section name=\"names are equal, tags are equal but class names are different\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+      <Expression success=\"true\" type=\"CHECK\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+        <Original>\n+          hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2)\n+        </Original>\n+        <Expanded>\n+          1172537240 (0x<hex digits>)\n+!=\n+1403724645 (0x<hex digits>)\n+        </Expanded>\n+      </Expression>\n+      <OverallResults successes=\"1\" failures=\"0\" expectedFailures=\"0\"/>\n+    </Section>\n+    <Section name=\"class names and names and tags are equal but hashers are seeded differently.\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+      <Expression success=\"true\" type=\"CHECK\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+        <Original>\n+          h1(testCase1) != h2(testCase2)\n+        </Original>\n+        <Expanded>\n+          1836497244 (0x<hex digits>)\n+!=\n+430288597 (0x<hex digits>)\n+        </Expanded>\n+      </Expression>\n+      <OverallResults successes=\"1\" failures=\"0\" expectedFailures=\"0\"/>\n+    </Section>\n+    <OverallResult success=\"true\"/>\n+  </TestCase>\n+  <TestCase name=\"TestCaseInfoHasher produces equal hashes.\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+    <Section name=\"class names and names and tags are equal.\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+      <Expression success=\"true\" type=\"CHECK\" filename=\"tests/<exe-name>/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\" >\n+        <Original>\n+          hasherWithCustomSeed(testCase1) == hasherWithCustomSeed(testCase2)\n+        </Original>\n+        <Expanded>\n+          764519552 (0x<hex digits>)\n+==\n+764519552 (0x<hex digits>)\n+        </Expanded>\n+      </Expression>\n+      <OverallResults successes=\"1\" failures=\"0\" expectedFailures=\"0\"/>\n+    </Section>\n+    <OverallResult success=\"true\"/>\n+  </TestCase>\n   <TestCase name=\"Testing checked-if\" tags=\"[checked-if]\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n     <Expression success=\"true\" type=\"CHECKED_IF\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n       <Original>\n@@ -20990,6 +21061,6 @@ There is no extra whitespace here\n     </Section>\n     <OverallResult success=\"true\"/>\n   </TestCase>\n-  <OverallResults successes=\"2064\" failures=\"143\" expectedFailures=\"27\"/>\n-  <OverallResultsCases successes=\"296\" failures=\"83\" expectedFailures=\"7\"/>\n+  <OverallResults successes=\"2069\" failures=\"143\" expectedFailures=\"27\"/>\n+  <OverallResultsCases successes=\"298\" failures=\"83\" expectedFailures=\"7\"/>\n </Catch2TestRun>\ndiff --git a/tests/SelfTest/IntrospectiveTests/TestCaseInfoHasher.tests.cpp b/tests/SelfTest/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\nnew file mode 100644\nindex 0000000000..450073601c\n--- /dev/null\n+++ b/tests/SelfTest/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\n@@ -0,0 +1,51 @@\n+#include <catch2/catch_test_macros.hpp>\n+#include <catch2/catch_test_case_info.hpp>\n+#include <catch2/internal/catch_test_case_info_hasher.hpp>\n+\n+static constexpr Catch::SourceLineInfo dummySourceLineInfo = CATCH_INTERNAL_LINEINFO;\n+\n+TEST_CASE( \"TestCaseInfoHasher produces equal hashes.\" ) {\n+    SECTION( \"class names and names and tags are equal.\" ) {\n+        Catch::TestCaseInfo testCase1(\"\", {\"name\", \"[.magic-tag1]\"}, dummySourceLineInfo);\n+        Catch::TestCaseInfo testCase2(\"\", {\"name\", \"[.magic-tag1]\"}, dummySourceLineInfo);\n+\n+        Catch::TestCaseInfoHasher hasherWithCustomSeed(123456789u);\n+        CHECK(hasherWithCustomSeed(testCase1) == hasherWithCustomSeed(testCase2));\n+    }\n+}\n+\n+TEST_CASE( \"TestCaseInfoHasher produces different hashes.\" ) {\n+    SECTION( \"class names are equal, names are equal but tags are different.\" ) {\n+        Catch::TestCaseInfo testCase1(\"\", {\"name\", \"[.magic-tag1]\"}, dummySourceLineInfo);\n+        Catch::TestCaseInfo testCase2(\"\", {\"name\", \"[.magic-tag2]\"}, dummySourceLineInfo);\n+\n+        Catch::TestCaseInfoHasher hasherWithCustomSeed(123456789u);\n+        CHECK(hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2));\n+    }\n+\n+    SECTION( \"class names are equal, tags are equal but names are different\" ) {\n+        Catch::TestCaseInfo testCase1(\"\", {\"name1\", \"[.magic-tag]\"}, dummySourceLineInfo);\n+        Catch::TestCaseInfo testCase2(\"\", {\"name2\", \"[.magic-tag]\"}, dummySourceLineInfo);\n+\n+        Catch::TestCaseInfoHasher hasherWithCustomSeed(123456789u);\n+        CHECK(hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2));\n+    }\n+\n+    SECTION( \"names are equal, tags are equal but class names are different\" ) {\n+        Catch::TestCaseInfo testCase1(\"class1\", {\"name\", \"[.magic-tag]\"}, dummySourceLineInfo);\n+        Catch::TestCaseInfo testCase2(\"class2\", {\"name\", \"[.magic-tag]\"}, dummySourceLineInfo);\n+\n+        Catch::TestCaseInfoHasher hasherWithCustomSeed(123456789u);\n+        CHECK(hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2));\n+    }\n+\n+    SECTION( \"class names and names and tags are equal but hashers are seeded differently.\" ) {\n+        Catch::TestCaseInfo testCase1(\"\", {\"name\", \"[.magic-tag1]\"}, dummySourceLineInfo);\n+        Catch::TestCaseInfo testCase2(\"\", {\"name\", \"[.magic-tag1]\"}, dummySourceLineInfo);\n+\n+        Catch::TestCaseInfoHasher h1(14695981039346656037u);\n+        Catch::TestCaseInfoHasher h2(14695981039346656038u);\n+\n+        CHECK(h1(testCase1) != h2(testCase2));\n+    }\n+}\n", "fixed_tests": {"testspecs::nomatchedtestsfail": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::reporters::output": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "randomtestordering": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "libidentitytest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "unmatchedoutputfilter": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::xmloutput": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tags::exitcode": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "warnings::unmatchedtestspecisaccepted": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filenameastagsmatching": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::output": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "escapespecialcharactersintestnames": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "warnings::multiplewarningscanbespecified": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "noassertions": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "benchmarking::failurereporting::failedassertion": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "errorhandling::invalidtestspecexitsearly": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "multireporter::capturingreportersdontpropagatestdout": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "multireporter::noncapturingreporterspropagatestdout": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testspecs::combiningmatchingandnonmatchingisok-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testspecs::overridefailurewithnomatchedtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tags::xmloutput": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::escapespecialcharacters": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::invalidtestnames-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "colours::colourmodecanbeexplicitlysettoansi": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "versioncheck": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "benchmarking::failurereporting::failmacro": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "checkconvenienceheaders": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tags::output": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "approvaltests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testspecs::warnunmatchedtestspecfailswithunmatchedtestspec": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "benchmarking::failurereporting::shouldfailisrespected": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "negativespecnohiddentests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "outputs::dashasoutlocationsendsoutputtostdout": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection::generatorsdontcauseinfiniteloop-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testspecs::combiningmatchingandnonmatchingisok-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::exitcode": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::quiet": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::simplespecs": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters::dashaslocationinreporterspecsendsoutputtostdout": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "regressioncheck-1670": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::reporters::exitcode": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filenameastagstest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "tagalias": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::reporters::xmloutput": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "benchmarking::failurereporting::throwingbenchmark": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection::generatorsdontcauseinfiniteloop-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "p2p_tests": {"have_flag_-wmisleading-indentation": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wcatch-value": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wunreachable-code": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wextra": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wmissing-braces": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wpedantic": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wparentheses": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wall": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wunused-parameter": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wstrict-aliasing": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wunused-function": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wdeprecated": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wshadow": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wmissing-noreturn": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wextra-semi": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wold-style-cast": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wvla": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wundef": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wmissing-declarations": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wsuggest-override": {"run": "PASS", "test": "PASS", "fix": "PASS"}}, "f2p_tests": {}, "s2p_tests": {}, "n2p_tests": {"testspecs::nomatchedtestsfail": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::reporters::output": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "randomtestordering": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "libidentitytest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "unmatchedoutputfilter": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::xmloutput": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tags::exitcode": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "warnings::unmatchedtestspecisaccepted": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filenameastagsmatching": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::output": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "escapespecialcharactersintestnames": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "warnings::multiplewarningscanbespecified": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "noassertions": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "benchmarking::failurereporting::failedassertion": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "errorhandling::invalidtestspecexitsearly": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "multireporter::capturingreportersdontpropagatestdout": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "multireporter::noncapturingreporterspropagatestdout": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testspecs::combiningmatchingandnonmatchingisok-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testspecs::overridefailurewithnomatchedtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tags::xmloutput": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::escapespecialcharacters": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::invalidtestnames-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "colours::colourmodecanbeexplicitlysettoansi": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "versioncheck": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "benchmarking::failurereporting::failmacro": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "checkconvenienceheaders": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tags::output": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "approvaltests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testspecs::warnunmatchedtestspecfailswithunmatchedtestspec": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "benchmarking::failurereporting::shouldfailisrespected": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "negativespecnohiddentests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "outputs::dashasoutlocationsendsoutputtostdout": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection::generatorsdontcauseinfiniteloop-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testspecs::combiningmatchingandnonmatchingisok-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::exitcode": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::quiet": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::simplespecs": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "reporters::dashaslocationinreporterspecsendsoutputtostdout": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "regressioncheck-1670": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::reporters::exitcode": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filenameastagstest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "tagalias": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::reporters::xmloutput": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "benchmarking::failurereporting::throwingbenchmark": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection::generatorsdontcauseinfiniteloop-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "run_result": {"passed_count": 68, "failed_count": 7, "skipped_count": 0, "passed_tests": ["benchmarking::failurereporting::failmacro", "testspecs::nomatchedtestsfail", "list::reporters::output", "randomtestordering", "libidentitytest", "unmatchedoutputfilter", "checkconvenienceheaders", "have_flag_-wmisleading-indentation", "list::tags::output", "list::tests::xmloutput", "list::tags::exitcode", "list::reporters::xmloutput", "warnings::unmatchedtestspecisaccepted", "filenameastagsmatching", "have_flag_-wdeprecated", "have_flag_-wcatch-value", "list::tests::output", "approvaltests", "escapespecialcharactersintestnames", "testspecs::warnunmatchedtestspecfailswithunmatchedtestspec", "benchmarking::failurereporting::shouldfailisrespected", "have_flag_-wunreachable-code", "warnings::multiplewarningscanbespecified", "noassertions", "negativespecnohiddentests", "have_flag_-wshadow", "outputs::dashasoutlocationsendsoutputtostdout", "benchmarking::failurereporting::failedassertion", "filteredsection::generatorsdontcauseinfiniteloop-2", "versioncheck", "testspecs::combiningmatchingandnonmatchingisok-1", "errorhandling::invalidtestspecexitsearly", "have_flag_-wextra", "list::tests::exitcode", "multireporter::capturingreportersdontpropagatestdout", "multireporter::noncapturingreporterspropagatestdout", "have_flag_-wmissing-noreturn", "list::tests::quiet", "have_flag_-wmissing-braces", "runtests", "have_flag_-wpedantic", "testsinfile::simplespecs", "reporters::dashaslocationinreporterspecsendsoutputtostdout", "have_flag_-wextra-semi", "regressioncheck-1670", "have_flag_-wparentheses", "have_flag_-wall", "testspecs::combiningmatchingandnonmatchingisok-2", "testspecs::overridefailurewithnomatchedtests", "have_flag_-wold-style-cast", "list::tags::xmloutput", "filteredsection-2", "list::reporters::exitcode", "filenameastagstest", "testsinfile::escapespecialcharacters", "testsinfile::invalidtestnames-1", "benchmarking::failurereporting::throwingbenchmark", "have_flag_-wvla", "colours::colourmodecanbeexplicitlysettoansi", "have_flag_-wundef", "have_flag_-wunused-parameter", "filteredsection-1", "have_flag_-wmissing-declarations", "tagalias", "have_flag_-wunused-function", "have_flag_-wstrict-aliasing", "have_flag_-wsuggest-override", "filteredsection::generatorsdontcauseinfiniteloop-1"], "failed_tests": ["have_flag_-wglobal-constructors", "have_flag_-wreturn-std-move", "have_flag_-wcall-to-pure-virtual-from-ctor-dtor", "have_flag_-wweak-vtables", "have_flag_-wdeprecated-register", "have_flag_-wexit-time-destructors", "have_flag_-wabsolute-value"], "skipped_tests": []}, "test_patch_result": {"passed_count": 20, "failed_count": 7, "skipped_count": 0, "passed_tests": ["have_flag_-wmisleading-indentation", "have_flag_-wdeprecated", "have_flag_-wcatch-value", "have_flag_-wunreachable-code", "have_flag_-wshadow", "have_flag_-wextra", "have_flag_-wmissing-noreturn", "have_flag_-wmissing-braces", "have_flag_-wpedantic", "have_flag_-wextra-semi", "have_flag_-wparentheses", "have_flag_-wall", "have_flag_-wold-style-cast", "have_flag_-wvla", "have_flag_-wundef", "have_flag_-wunused-parameter", "have_flag_-wmissing-declarations", "have_flag_-wunused-function", "have_flag_-wstrict-aliasing", "have_flag_-wsuggest-override"], "failed_tests": ["have_flag_-wglobal-constructors", "have_flag_-wreturn-std-move", "have_flag_-wcall-to-pure-virtual-from-ctor-dtor", "have_flag_-wweak-vtables", "have_flag_-wdeprecated-register", "have_flag_-wexit-time-destructors", "have_flag_-wabsolute-value"], "skipped_tests": []}, "fix_patch_result": {"passed_count": 68, "failed_count": 7, "skipped_count": 0, "passed_tests": ["benchmarking::failurereporting::failmacro", "testspecs::nomatchedtestsfail", "list::reporters::output", "randomtestordering", "libidentitytest", "unmatchedoutputfilter", "checkconvenienceheaders", "have_flag_-wmisleading-indentation", "list::tags::output", "list::tests::xmloutput", "list::tags::exitcode", "list::reporters::xmloutput", "warnings::unmatchedtestspecisaccepted", "filenameastagsmatching", "have_flag_-wdeprecated", "have_flag_-wcatch-value", "list::tests::output", "approvaltests", "escapespecialcharactersintestnames", "testspecs::warnunmatchedtestspecfailswithunmatchedtestspec", "benchmarking::failurereporting::shouldfailisrespected", "have_flag_-wunreachable-code", "warnings::multiplewarningscanbespecified", "noassertions", "negativespecnohiddentests", "have_flag_-wshadow", "outputs::dashasoutlocationsendsoutputtostdout", "benchmarking::failurereporting::failedassertion", "filteredsection::generatorsdontcauseinfiniteloop-2", "versioncheck", "testspecs::combiningmatchingandnonmatchingisok-1", "errorhandling::invalidtestspecexitsearly", "have_flag_-wextra", "list::tests::exitcode", "multireporter::capturingreportersdontpropagatestdout", "multireporter::noncapturingreporterspropagatestdout", "have_flag_-wmissing-noreturn", "list::tests::quiet", "have_flag_-wmissing-braces", "runtests", "have_flag_-wpedantic", "testsinfile::simplespecs", "reporters::dashaslocationinreporterspecsendsoutputtostdout", "have_flag_-wextra-semi", "regressioncheck-1670", "have_flag_-wparentheses", "have_flag_-wall", "testspecs::combiningmatchingandnonmatchingisok-2", "testspecs::overridefailurewithnomatchedtests", "have_flag_-wold-style-cast", "list::tags::xmloutput", "filteredsection-2", "list::reporters::exitcode", "filenameastagstest", "testsinfile::escapespecialcharacters", "testsinfile::invalidtestnames-1", "benchmarking::failurereporting::throwingbenchmark", "have_flag_-wvla", "colours::colourmodecanbeexplicitlysettoansi", "have_flag_-wundef", "have_flag_-wunused-parameter", "filteredsection-1", "have_flag_-wmissing-declarations", "tagalias", "have_flag_-wunused-function", "have_flag_-wstrict-aliasing", "have_flag_-wsuggest-override", "filteredsection::generatorsdontcauseinfiniteloop-1"], "failed_tests": ["have_flag_-wglobal-constructors", "have_flag_-wreturn-std-move", "have_flag_-wcall-to-pure-virtual-from-ctor-dtor", "have_flag_-wweak-vtables", "have_flag_-wdeprecated-register", "have_flag_-wexit-time-destructors", "have_flag_-wabsolute-value"], "skipped_tests": []}, "instance_id": "catchorg__Catch2-2394"}
{"org": "catchorg", "repo": "Catch2", "number": 2288, "state": "closed", "title": "Make Approx::operator() const to fix #2273 for 2.x", "body": "## Description\r\nBackport @horenmar's fix for 2.x branch\r\n\r\n## GitHub Issues\r\n#2273\r\n", "base": {"label": "catchorg:v2.x", "ref": "v2.x", "sha": "85c9544fa4c9625b9656d9bd765e54f8e639287f"}, "resolved_issues": [{"number": 2273, "title": "Approx::operator() not const-correct", "body": "**Describe the bug**\r\n\r\nThe `Approx` type has an overload of `template <typename T, ...SFINAE...> Approx operator()(T const&)` which (correct me if I'm wrong) is meant to be a factory function for instances that have the same epsilon, margin, and scale, but that use the passed value. \r\n\r\nAFAICT this should be const on the instance, but it's not.\r\n\r\nMinimum failing example:\r\n```C++\r\n#include <catch2/catch.hpp>\r\n\r\nTEST_CASE(\"Approx factory is const-correct\") {\r\n  // Set up a template Approx with problem-specific margin, etc.\r\n  Approx const apprx = Approx(0.0).margin(1e-6);\r\n  double value = 1.0;\r\n  // Use template in assertions\r\n  REQUIRE(value == apprx(1.0));\r\n}\r\n```\r\n\r\n**Expected behavior**\r\nAbove test compiles, runs and passes.\r\n\r\n**Reproduction steps**\r\nSee above.\r\n\r\n**Platform information:**\r\n - OS: RHEL 8\r\n - Compiler+version: GCC 8.2.0\r\n - Catch version: 2.13.6\r\n\r\n\r\n**Additional context**\r\nAdd any other context about the problem here.\r\n"}], "fix_patch": "diff --git a/include/internal/catch_approx.h b/include/internal/catch_approx.h\nindex 4522e5ad70..2d12efe406 100644\n--- a/include/internal/catch_approx.h\n+++ b/include/internal/catch_approx.h\n@@ -33,7 +33,7 @@ namespace Detail {\n         Approx operator-() const;\n \n         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n-        Approx operator()( T const& value ) {\n+        Approx operator()( T const& value ) const {\n             Approx approx( static_cast<double>(value) );\n             approx.m_epsilon = m_epsilon;\n             approx.m_margin = m_margin;\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/Approx.tests.cpp b/projects/SelfTest/UsageTests/Approx.tests.cpp\nindex 4029223a2b..6280599ef7 100644\n--- a/projects/SelfTest/UsageTests/Approx.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Approx.tests.cpp\n@@ -212,4 +212,11 @@ TEST_CASE( \"Comparison with explicitly convertible types\", \"[Approx]\" )\n \n }\n \n+TEST_CASE(\"Approx::operator() is const correct\", \"[Approx][.approvals]\") {\n+  const Approx ap = Approx(0.0).margin(0.01);\n+\n+  // As long as this compiles, the test should be considered passing\n+  REQUIRE(1.0 == ap(1.0));\n+}\n+\n }} // namespace ApproxTests\n", "fixed_tests": {"randomtestordering": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "libidentitytest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "warnaboutnotests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "unmatchedoutputfilter": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtags": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::simplespecs": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "notest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "regressioncheck-1670": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection::generatorsdontcauseinfiniteloop-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::escapespecialcharacters": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::invalidtestnames-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filenameastagstest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "approvaltests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "escapespecialcharactersintestnames": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::invalidtestnames-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "noassertions": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "versioncheck": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtestnamesonly": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection::generatorsdontcauseinfiniteloop-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listreporters": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "p2p_tests": {}, "f2p_tests": {}, "s2p_tests": {}, "n2p_tests": {"randomtestordering": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "libidentitytest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "warnaboutnotests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "unmatchedoutputfilter": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtags": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::simplespecs": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "notest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "regressioncheck-1670": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection::generatorsdontcauseinfiniteloop-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::escapespecialcharacters": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::invalidtestnames-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filenameastagstest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "approvaltests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "escapespecialcharactersintestnames": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::invalidtestnames-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "noassertions": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "versioncheck": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtestnamesonly": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection::generatorsdontcauseinfiniteloop-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listreporters": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "run_result": {"passed_count": 24, "failed_count": 0, "skipped_count": 0, "passed_tests": ["randomtestordering", "libidentitytest", "unmatchedoutputfilter", "listtags", "notest", "approvaltests", "escapespecialcharactersintestnames", "testsinfile::invalidtestnames-2", "noassertions", "filteredsection::generatorsdontcauseinfiniteloop-2", "listreporters", "listtestnamesonly", "warnaboutnotests", "runtests", "testsinfile::simplespecs", "listtests", "regressioncheck-1670", "testsinfile::escapespecialcharacters", "filteredsection-2", "testsinfile::invalidtestnames-1", "filenameastagstest", "filteredsection-1", "versioncheck", "filteredsection::generatorsdontcauseinfiniteloop-1"], "failed_tests": [], "skipped_tests": []}, "test_patch_result": {"passed_count": 0, "failed_count": 0, "skipped_count": 0, "passed_tests": [], "failed_tests": [], "skipped_tests": []}, "fix_patch_result": {"passed_count": 24, "failed_count": 0, "skipped_count": 0, "passed_tests": ["randomtestordering", "libidentitytest", "unmatchedoutputfilter", "listtags", "notest", "approvaltests", "escapespecialcharactersintestnames", "testsinfile::invalidtestnames-2", "noassertions", "filteredsection::generatorsdontcauseinfiniteloop-2", "listreporters", "listtestnamesonly", "warnaboutnotests", "runtests", "testsinfile::simplespecs", "listtests", "regressioncheck-1670", "testsinfile::escapespecialcharacters", "filteredsection-2", "testsinfile::invalidtestnames-1", "filenameastagstest", "filteredsection-1", "versioncheck", "filteredsection::generatorsdontcauseinfiniteloop-1"], "failed_tests": [], "skipped_tests": []}, "instance_id": "catchorg__Catch2-2288"}
{"org": "catchorg", "repo": "Catch2", "number": 2187, "state": "closed", "title": "Suppress failure of CHECKED_IF and CHECKED_ELSE", "body": "Resolves #1390", "base": {"label": "catchorg:devel", "ref": "devel", "sha": "2cb5210caf35bf8fc29ade2e5570cc0f37537951"}, "resolved_issues": [{"number": 1390, "title": "Make CHECKED_IF and CHECKED_ELSE \"ok to fail\"", "body": "## Description\r\nBoth `CHECKED_IF` and `CHECKED_ELSE` are currently fairly obscure macros that simplify using `if`/`else` in tests.\r\n\r\nHowever, entering the `else` branch fails the test in which it occurs, because they are not marked as being ok to fail (tagged with `Catch::ResultDisposition::SuppressFail` to be exact). This behaviour makes them less than useful, but with a change they should be actually usable.\r\n\r\nMilestone 3.0, because it is a theoretically breaking change.\r\n"}], "fix_patch": "diff --git a/docs/deprecations.md b/docs/deprecations.md\nindex c0e51b46dc..8edf2842ea 100644\n--- a/docs/deprecations.md\n+++ b/docs/deprecations.md\n@@ -12,14 +12,6 @@ at least the next major release.\n \n ## Planned changes\n \n-### `CHECKED_IF` and `CHECKED_ELSE`\n-\n-To make the `CHECKED_IF` and `CHECKED_ELSE` macros more useful, they will\n-be marked as \"OK to fail\" (`Catch::ResultDisposition::SuppressFail` flag\n-will be added), which means that their failure will not fail the test,\n-making the `else` actually useful.\n-\n-\n ### Console Colour API\n \n The API for Catch2's console colour will be changed to take an extra\ndiff --git a/docs/other-macros.md b/docs/other-macros.md\nindex 50593faee7..f23ee6c242 100644\n--- a/docs/other-macros.md\n+++ b/docs/other-macros.md\n@@ -15,6 +15,8 @@ stringification machinery to the _expr_ and records the result. As with\n evaluates to `true`. `CHECKED_ELSE( expr )` work similarly, but the block\n is entered only if the _expr_ evaluated to `false`.\n \n+> `CHECKED_X` macros were changed to not count as failure in Catch2 X.Y.Z.\n+\n Example:\n ```cpp\n int a = ...;\ndiff --git a/src/catch2/internal/catch_run_context.cpp b/src/catch2/internal/catch_run_context.cpp\nindex 8379a7aa02..e2719d3127 100644\n--- a/src/catch2/internal/catch_run_context.cpp\n+++ b/src/catch2/internal/catch_run_context.cpp\n@@ -230,9 +230,11 @@ namespace Catch {\n         if (result.getResultType() == ResultWas::Ok) {\n             m_totals.assertions.passed++;\n             m_lastAssertionPassed = true;\n-        } else if (!result.isOk()) {\n+        } else if (!result.succeeded()) {\n             m_lastAssertionPassed = false;\n-            if( m_activeTestCase->getTestCaseInfo().okToFail() )\n+            if (result.isOk()) {\n+            }\n+            else if( m_activeTestCase->getTestCaseInfo().okToFail() )\n                 m_totals.assertions.failedButOk++;\n             else\n                 m_totals.assertions.failed++;\n", "test_patch": "diff --git a/src/catch2/catch_test_macros.hpp b/src/catch2/catch_test_macros.hpp\nindex ae50915026..cd33a65c26 100644\n--- a/src/catch2/catch_test_macros.hpp\n+++ b/src/catch2/catch_test_macros.hpp\n@@ -32,8 +32,8 @@\n \n   #define CATCH_CHECK( ... ) INTERNAL_CATCH_TEST( \"CATCH_CHECK\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n   #define CATCH_CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( \"CATCH_CHECK_FALSE\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )\n-  #define CATCH_CHECKED_IF( ... ) INTERNAL_CATCH_IF( \"CATCH_CHECKED_IF\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n-  #define CATCH_CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( \"CATCH_CHECKED_ELSE\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n+  #define CATCH_CHECKED_IF( ... ) INTERNAL_CATCH_IF( \"CATCH_CHECKED_IF\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\n+  #define CATCH_CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( \"CATCH_CHECKED_ELSE\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\n   #define CATCH_CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( \"CATCH_CHECK_NOFAIL\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\n \n   #define CATCH_CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( \"CATCH_CHECK_THROWS\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n@@ -123,8 +123,8 @@\n \n   #define CHECK( ... ) INTERNAL_CATCH_TEST( \"CHECK\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n   #define CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( \"CHECK_FALSE\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )\n-  #define CHECKED_IF( ... ) INTERNAL_CATCH_IF( \"CHECKED_IF\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n-  #define CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( \"CHECKED_ELSE\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n+  #define CHECKED_IF( ... ) INTERNAL_CATCH_IF( \"CHECKED_IF\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\n+  #define CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( \"CHECKED_ELSE\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\n   #define CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( \"CHECK_NOFAIL\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\n \n   #define CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( \"CHECK_THROWS\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\ndiff --git a/tests/SelfTest/Baselines/automake.sw.approved.txt b/tests/SelfTest/Baselines/automake.sw.approved.txt\nindex 983d976484..c4ad5b1e37 100644\n--- a/tests/SelfTest/Baselines/automake.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/automake.sw.approved.txt\n@@ -231,6 +231,9 @@ Message from section two\n :test-result: PASS Test case with one argument\n :test-result: PASS Test enum bit values\n :test-result: PASS Test with special, characters \"in name\n+:test-result: PASS Testing checked-if\n+:test-result: XFAIL Testing checked-if 2\n+:test-result: XFAIL Testing checked-if 3\n :test-result: FAIL The NO_FAIL macro reports a failure but does not fail the test\n :test-result: PASS The default listing implementation write to provided stream\n :test-result: FAIL This test 'should' fail but doesn't\ndiff --git a/tests/SelfTest/Baselines/compact.sw.approved.txt b/tests/SelfTest/Baselines/compact.sw.approved.txt\nindex e757222db5..92488f5f37 100644\n--- a/tests/SelfTest/Baselines/compact.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/compact.sw.approved.txt\n@@ -1714,6 +1714,16 @@ Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 15 >= 15\n VariadicMacros.tests.cpp:<line number>: passed: with 1 message: 'no assertions'\n Tricky.tests.cpp:<line number>: passed: 0x<hex digits> == bit30and31 for: 3221225472 (0x<hex digits>) == 3221225472\n CmdLine.tests.cpp:<line number>: passed:\n+Misc.tests.cpp:<line number>: passed: true\n+Misc.tests.cpp:<line number>: passed:\n+Misc.tests.cpp:<line number>: failed - but was ok: false\n+Misc.tests.cpp:<line number>: passed: true\n+Misc.tests.cpp:<line number>: failed - but was ok: false\n+Misc.tests.cpp:<line number>: passed:\n+Misc.tests.cpp:<line number>: passed: true\n+Misc.tests.cpp:<line number>: failed: explicitly\n+Misc.tests.cpp:<line number>: failed - but was ok: false\n+Misc.tests.cpp:<line number>: failed: explicitly\n Message.tests.cpp:<line number>: failed - but was ok: 1 == 2\n Reporters.tests.cpp:<line number>: passed: listingString, Contains(\"[fakeTag]\"s) for: \"All available tags:\n    1  [fakeTag]\n@@ -1996,11 +2006,11 @@ InternalBenchmark.tests.cpp:<line number>: passed: called == 1 for: 1 == 1\n Tricky.tests.cpp:<line number>: passed: obj.prop != 0 for: 0x<hex digits> != 0\n Misc.tests.cpp:<line number>: passed: flag for: true\n Misc.tests.cpp:<line number>: passed: testCheckedElse( true ) for: true\n-Misc.tests.cpp:<line number>: failed: flag for: false\n+Misc.tests.cpp:<line number>: failed - but was ok: flag for: false\n Misc.tests.cpp:<line number>: failed: testCheckedElse( false ) for: false\n Misc.tests.cpp:<line number>: passed: flag for: true\n Misc.tests.cpp:<line number>: passed: testCheckedIf( true ) for: true\n-Misc.tests.cpp:<line number>: failed: flag for: false\n+Misc.tests.cpp:<line number>: failed - but was ok: flag for: false\n Misc.tests.cpp:<line number>: failed: testCheckedIf( false ) for: false\n InternalBenchmark.tests.cpp:<line number>: passed: o.samples_seen == static_cast<int>(x.size()) for: 6 == 6\n InternalBenchmark.tests.cpp:<line number>: passed: o.low_severe == los for: 0 == 0\n@@ -2342,5 +2352,5 @@ InternalBenchmark.tests.cpp:<line number>: passed: med == 18. for: 18.0 == 18.0\n InternalBenchmark.tests.cpp:<line number>: passed: q3 == 23. for: 23.0 == 23.0\n Misc.tests.cpp:<line number>: passed:\n Misc.tests.cpp:<line number>: passed:\n-Failed 86 test cases, failed 148 assertions.\n+Failed 86 test cases, failed 146 assertions.\n \ndiff --git a/tests/SelfTest/Baselines/console.std.approved.txt b/tests/SelfTest/Baselines/console.std.approved.txt\nindex f91f4b80f3..d9e8f2b8c7 100644\n--- a/tests/SelfTest/Baselines/console.std.approved.txt\n+++ b/tests/SelfTest/Baselines/console.std.approved.txt\n@@ -922,6 +922,22 @@ with expansion:\n   }\n   \"\n \n+-------------------------------------------------------------------------------\n+Testing checked-if 2\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: FAILED:\n+\n+-------------------------------------------------------------------------------\n+Testing checked-if 3\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: FAILED:\n+\n -------------------------------------------------------------------------------\n Thrown string literals are translated\n -------------------------------------------------------------------------------\n@@ -1135,11 +1151,6 @@ checkedElse, failing\n Misc.tests.cpp:<line number>\n ...............................................................................\n \n-Misc.tests.cpp:<line number>: FAILED:\n-  CHECKED_ELSE( flag )\n-with expansion:\n-  false\n-\n Misc.tests.cpp:<line number>: FAILED:\n   REQUIRE( testCheckedElse( false ) )\n with expansion:\n@@ -1151,11 +1162,6 @@ checkedIf, failing\n Misc.tests.cpp:<line number>\n ...............................................................................\n \n-Misc.tests.cpp:<line number>: FAILED:\n-  CHECKED_IF( flag )\n-with expansion:\n-  false\n-\n Misc.tests.cpp:<line number>: FAILED:\n   REQUIRE( testCheckedIf( false ) )\n with expansion:\n@@ -1380,6 +1386,6 @@ due to unexpected exception with message:\n   Why would you throw a std::string?\n \n ===============================================================================\n-test cases:  356 |  282 passed |  70 failed |  4 failed as expected\n-assertions: 2077 | 1925 passed | 131 failed | 21 failed as expected\n+test cases:  359 |  283 passed |  70 failed |  6 failed as expected\n+assertions: 2082 | 1930 passed | 129 failed | 23 failed as expected\n \ndiff --git a/tests/SelfTest/Baselines/console.sw.approved.txt b/tests/SelfTest/Baselines/console.sw.approved.txt\nindex 5f77647a9d..7e53a539dc 100644\n--- a/tests/SelfTest/Baselines/console.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/console.sw.approved.txt\n@@ -12298,6 +12298,50 @@ CmdLine.tests.cpp:<line number>\n \n CmdLine.tests.cpp:<line number>: PASSED:\n \n+-------------------------------------------------------------------------------\n+Testing checked-if\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  CHECKED_IF( true )\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+\n+Misc.tests.cpp:<line number>: FAILED - but was ok:\n+  CHECKED_IF( false )\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  CHECKED_ELSE( true )\n+\n+Misc.tests.cpp:<line number>: FAILED - but was ok:\n+  CHECKED_ELSE( false )\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+\n+-------------------------------------------------------------------------------\n+Testing checked-if 2\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  CHECKED_IF( true )\n+\n+Misc.tests.cpp:<line number>: FAILED:\n+\n+-------------------------------------------------------------------------------\n+Testing checked-if 3\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: FAILED - but was ok:\n+  CHECKED_ELSE( false )\n+\n+Misc.tests.cpp:<line number>: FAILED:\n+\n -------------------------------------------------------------------------------\n The NO_FAIL macro reports a failure but does not fail the test\n -------------------------------------------------------------------------------\n@@ -14176,7 +14220,7 @@ checkedElse, failing\n Misc.tests.cpp:<line number>\n ...............................................................................\n \n-Misc.tests.cpp:<line number>: FAILED:\n+Misc.tests.cpp:<line number>: FAILED - but was ok:\n   CHECKED_ELSE( flag )\n with expansion:\n   false\n@@ -14208,7 +14252,7 @@ checkedIf, failing\n Misc.tests.cpp:<line number>\n ...............................................................................\n \n-Misc.tests.cpp:<line number>: FAILED:\n+Misc.tests.cpp:<line number>: FAILED - but was ok:\n   CHECKED_IF( flag )\n with expansion:\n   false\n@@ -16722,6 +16766,6 @@ Misc.tests.cpp:<line number>\n Misc.tests.cpp:<line number>: PASSED:\n \n ===============================================================================\n-test cases:  356 |  266 passed |  86 failed |  4 failed as expected\n-assertions: 2094 | 1925 passed | 148 failed | 21 failed as expected\n+test cases:  359 |  267 passed |  86 failed |  6 failed as expected\n+assertions: 2099 | 1930 passed | 146 failed | 23 failed as expected\n \ndiff --git a/tests/SelfTest/Baselines/junit.sw.approved.txt b/tests/SelfTest/Baselines/junit.sw.approved.txt\nindex 12a1456f8e..d90b164554 100644\n--- a/tests/SelfTest/Baselines/junit.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/junit.sw.approved.txt\n@@ -1,7 +1,7 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <testsuitesloose text artifact\n >\n-  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"132\" tests=\"2095\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n+  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"130\" tests=\"2100\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n     <properties>\n       <property name=\"filters\" value=\"~[!nonportable]~[!benchmark]~[approvals] *\"/>\n       <property name=\"random-seed\" value=\"1\"/>\n@@ -1276,6 +1276,19 @@ Misc.tests.cpp:<line number>\n     <testcase classname=\"<exe-name>.global\" name=\"Test case with one argument\" time=\"{duration}\" status=\"run\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Test enum bit values\" time=\"{duration}\" status=\"run\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Test with special, characters &quot;in name\" time=\"{duration}\" status=\"run\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"Testing checked-if\" time=\"{duration}\" status=\"run\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"Testing checked-if 2\" time=\"{duration}\" status=\"run\">\n+      <failure type=\"FAIL\">\n+FAILED:\n+Misc.tests.cpp:<line number>\n+      </failure>\n+    </testcase>\n+    <testcase classname=\"<exe-name>.global\" name=\"Testing checked-if 3\" time=\"{duration}\" status=\"run\">\n+      <failure type=\"FAIL\">\n+FAILED:\n+Misc.tests.cpp:<line number>\n+      </failure>\n+    </testcase>\n     <testcase classname=\"<exe-name>.global\" name=\"The NO_FAIL macro reports a failure but does not fail the test\" time=\"{duration}\" status=\"run\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"The default listing implementation write to provided stream/Listing tags\" time=\"{duration}\" status=\"run\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"The default listing implementation write to provided stream/Listing reporters\" time=\"{duration}\" status=\"run\"/>\n@@ -1505,13 +1518,6 @@ Exception.tests.cpp:<line number>\n     <testcase classname=\"<exe-name>.global\" name=\"boolean member\" time=\"{duration}\" status=\"run\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"checkedElse\" time=\"{duration}\" status=\"run\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"checkedElse, failing\" time=\"{duration}\" status=\"run\">\n-      <failure message=\"flag\" type=\"CHECKED_ELSE\">\n-FAILED:\n-  CHECKED_ELSE( flag )\n-with expansion:\n-  false\n-Misc.tests.cpp:<line number>\n-      </failure>\n       <failure message=\"testCheckedElse( false )\" type=\"REQUIRE\">\n FAILED:\n   REQUIRE( testCheckedElse( false ) )\n@@ -1522,13 +1528,6 @@ Misc.tests.cpp:<line number>\n     </testcase>\n     <testcase classname=\"<exe-name>.global\" name=\"checkedIf\" time=\"{duration}\" status=\"run\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"checkedIf, failing\" time=\"{duration}\" status=\"run\">\n-      <failure message=\"flag\" type=\"CHECKED_IF\">\n-FAILED:\n-  CHECKED_IF( flag )\n-with expansion:\n-  false\n-Misc.tests.cpp:<line number>\n-      </failure>\n       <failure message=\"testCheckedIf( false )\" type=\"REQUIRE\">\n FAILED:\n   REQUIRE( testCheckedIf( false ) )\ndiff --git a/tests/SelfTest/Baselines/sonarqube.sw.approved.txt b/tests/SelfTest/Baselines/sonarqube.sw.approved.txt\nindex 1f0cc5dad5..b900a55cbb 100644\n--- a/tests/SelfTest/Baselines/sonarqube.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/sonarqube.sw.approved.txt\n@@ -1583,17 +1583,23 @@ Misc.tests.cpp:<line number>\n     <testCase name=\"TemplateTestSig: vectors can be sized and resized - std::string,15/resizing smaller changes size but not capacity/We can use the 'swap trick' to reset the capacity\" duration=\"{duration}\"/>\n     <testCase name=\"TemplateTestSig: vectors can be sized and resized - std::string,15/reserving bigger changes capacity but not size\" duration=\"{duration}\"/>\n     <testCase name=\"TemplateTestSig: vectors can be sized and resized - std::string,15/reserving smaller does not change size or capacity\" duration=\"{duration}\"/>\n+    <testCase name=\"Testing checked-if\" duration=\"{duration}\"/>\n+    <testCase name=\"Testing checked-if 2\" duration=\"{duration}\">\n+      <skipped message=\"FAIL()\">\n+FAILED:\n+Misc.tests.cpp:<line number>\n+      </skipped>\n+    </testCase>\n+    <testCase name=\"Testing checked-if 3\" duration=\"{duration}\">\n+      <skipped message=\"FAIL()\">\n+FAILED:\n+Misc.tests.cpp:<line number>\n+      </skipped>\n+    </testCase>\n     <testCase name=\"This test 'should' fail but doesn't\" duration=\"{duration}\"/>\n     <testCase name=\"atomic if\" duration=\"{duration}\"/>\n     <testCase name=\"checkedElse\" duration=\"{duration}\"/>\n     <testCase name=\"checkedElse, failing\" duration=\"{duration}\">\n-      <failure message=\"CHECKED_ELSE(flag)\">\n-FAILED:\n-\tCHECKED_ELSE( flag )\n-with expansion:\n-\tfalse\n-Misc.tests.cpp:<line number>\n-      </failure>\n       <failure message=\"REQUIRE(testCheckedElse( false ))\">\n FAILED:\n \tREQUIRE( testCheckedElse( false ) )\n@@ -1604,13 +1610,6 @@ Misc.tests.cpp:<line number>\n     </testCase>\n     <testCase name=\"checkedIf\" duration=\"{duration}\"/>\n     <testCase name=\"checkedIf, failing\" duration=\"{duration}\">\n-      <failure message=\"CHECKED_IF(flag)\">\n-FAILED:\n-\tCHECKED_IF( flag )\n-with expansion:\n-\tfalse\n-Misc.tests.cpp:<line number>\n-      </failure>\n       <failure message=\"REQUIRE(testCheckedIf( false ))\">\n FAILED:\n \tREQUIRE( testCheckedIf( false ) )\ndiff --git a/tests/SelfTest/Baselines/tap.sw.approved.txt b/tests/SelfTest/Baselines/tap.sw.approved.txt\nindex 8bb648f5eb..a6e63f6da4 100644\n--- a/tests/SelfTest/Baselines/tap.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/tap.sw.approved.txt\n@@ -3073,6 +3073,26 @@ ok {test-number} - with 1 message: 'no assertions'\n ok {test-number} - 0x<hex digits> == bit30and31 for: 3221225472 (0x<hex digits>) == 3221225472\n # Test with special, characters \"in name\n ok {test-number} -\n+# Testing checked-if\n+ok {test-number} - true\n+# Testing checked-if\n+ok {test-number} -\n+# Testing checked-if\n+ok {test-number} - false  # TODO\n+# Testing checked-if\n+ok {test-number} - true\n+# Testing checked-if\n+ok {test-number} - false  # TODO\n+# Testing checked-if\n+ok {test-number} -\n+# Testing checked-if 2\n+ok {test-number} - true\n+# Testing checked-if 2\n+not ok {test-number} - explicitly\n+# Testing checked-if 3\n+ok {test-number} - false  # TODO\n+# Testing checked-if 3\n+not ok {test-number} - explicitly\n # The NO_FAIL macro reports a failure but does not fail the test\n ok {test-number} - 1 == 2  # TODO\n # The default listing implementation write to provided stream\n@@ -3570,7 +3590,7 @@ ok {test-number} - flag for: true\n # checkedElse\n ok {test-number} - testCheckedElse( true ) for: true\n # checkedElse, failing\n-not ok {test-number} - flag for: false\n+ok {test-number} - flag for: false  # TODO\n # checkedElse, failing\n not ok {test-number} - testCheckedElse( false ) for: false\n # checkedIf\n@@ -3578,7 +3598,7 @@ ok {test-number} - flag for: true\n # checkedIf\n ok {test-number} - testCheckedIf( true ) for: true\n # checkedIf, failing\n-not ok {test-number} - flag for: false\n+ok {test-number} - flag for: false  # TODO\n # checkedIf, failing\n not ok {test-number} - testCheckedIf( false ) for: false\n # classify_outliers\n@@ -4180,5 +4200,5 @@ ok {test-number} - q3 == 23. for: 23.0 == 23.0\n ok {test-number} -\n # xmlentitycheck\n ok {test-number} -\n-1..2094\n+1..2099\n \ndiff --git a/tests/SelfTest/Baselines/teamcity.sw.approved.txt b/tests/SelfTest/Baselines/teamcity.sw.approved.txt\nindex e64c984fb1..2c1a8c5c29 100644\n--- a/tests/SelfTest/Baselines/teamcity.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/teamcity.sw.approved.txt\n@@ -563,6 +563,14 @@ Misc.tests.cpp:<line number>|nexpression failed|n  CHECK( s1 == s2 )|nwith expan\n ##teamcity[testFinished name='Test enum bit values' duration=\"{duration}\"]\n ##teamcity[testStarted name='Test with special, characters \"in name']\n ##teamcity[testFinished name='Test with special, characters \"in name' duration=\"{duration}\"]\n+##teamcity[testStarted name='Testing checked-if']\n+##teamcity[testFinished name='Testing checked-if' duration=\"{duration}\"]\n+##teamcity[testStarted name='Testing checked-if 2']\n+Misc.tests.cpp:<line number>|nexplicit failure- failure ignore as test marked as |'ok to fail|'|n']\n+##teamcity[testFinished name='Testing checked-if 2' duration=\"{duration}\"]\n+##teamcity[testStarted name='Testing checked-if 3']\n+Misc.tests.cpp:<line number>|nexplicit failure- failure ignore as test marked as |'ok to fail|'|n']\n+##teamcity[testFinished name='Testing checked-if 3' duration=\"{duration}\"]\n ##teamcity[testStarted name='The NO_FAIL macro reports a failure but does not fail the test']\n ##teamcity[testFinished name='The NO_FAIL macro reports a failure but does not fail the test' duration=\"{duration}\"]\n ##teamcity[testStarted name='The default listing implementation write to provided stream']\n@@ -661,13 +669,11 @@ Exception.tests.cpp:<line number>|nunexpected exception with message:|n  \"unexpe\n ##teamcity[testStarted name='checkedElse']\n ##teamcity[testFinished name='checkedElse' duration=\"{duration}\"]\n ##teamcity[testStarted name='checkedElse, failing']\n-Misc.tests.cpp:<line number>|nexpression failed|n  CHECKED_ELSE( flag )|nwith expansion:|n  false|n']\n Misc.tests.cpp:<line number>|nexpression failed|n  REQUIRE( testCheckedElse( false ) )|nwith expansion:|n  false|n']\n ##teamcity[testFinished name='checkedElse, failing' duration=\"{duration}\"]\n ##teamcity[testStarted name='checkedIf']\n ##teamcity[testFinished name='checkedIf' duration=\"{duration}\"]\n ##teamcity[testStarted name='checkedIf, failing']\n-Misc.tests.cpp:<line number>|nexpression failed|n  CHECKED_IF( flag )|nwith expansion:|n  false|n']\n Misc.tests.cpp:<line number>|nexpression failed|n  REQUIRE( testCheckedIf( false ) )|nwith expansion:|n  false|n']\n ##teamcity[testFinished name='checkedIf, failing' duration=\"{duration}\"]\n ##teamcity[testStarted name='classify_outliers']\ndiff --git a/tests/SelfTest/Baselines/xml.sw.approved.txt b/tests/SelfTest/Baselines/xml.sw.approved.txt\nindex a624d5bdbf..4aecb91e3b 100644\n--- a/tests/SelfTest/Baselines/xml.sw.approved.txt\n+++ b/tests/SelfTest/Baselines/xml.sw.approved.txt\n@@ -14425,6 +14425,65 @@ Message from section two\n     <TestCase name=\"Test with special, characters &quot;in name\" tags=\"[cli][regression]\" filename=\"tests/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n       <OverallResult success=\"true\"/>\n     </TestCase>\n+    <TestCase name=\"Testing checked-if\" tags=\"[checked-if]\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+      <Expression success=\"true\" type=\"CHECKED_IF\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          true\n+        </Original>\n+        <Expanded>\n+          true\n+        </Expanded>\n+      </Expression>\n+      <Expression success=\"false\" type=\"CHECKED_IF\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          false\n+        </Original>\n+        <Expanded>\n+          false\n+        </Expanded>\n+      </Expression>\n+      <Expression success=\"true\" type=\"CHECKED_ELSE\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          true\n+        </Original>\n+        <Expanded>\n+          true\n+        </Expanded>\n+      </Expression>\n+      <Expression success=\"false\" type=\"CHECKED_ELSE\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          false\n+        </Original>\n+        <Expanded>\n+          false\n+        </Expanded>\n+      </Expression>\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n+    <TestCase name=\"Testing checked-if 2\" tags=\"[!shouldfail][checked-if]\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+      <Expression success=\"true\" type=\"CHECKED_IF\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          true\n+        </Original>\n+        <Expanded>\n+          true\n+        </Expanded>\n+      </Expression>\n+      <Failure filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" />\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n+    <TestCase name=\"Testing checked-if 3\" tags=\"[!shouldfail][checked-if]\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+      <Expression success=\"false\" type=\"CHECKED_ELSE\" filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          false\n+        </Original>\n+        <Expanded>\n+          false\n+        </Expanded>\n+      </Expression>\n+      <Failure filename=\"tests/<exe-name>/UsageTests/Misc.tests.cpp\" />\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n     <TestCase name=\"The NO_FAIL macro reports a failure but does not fail the test\" tags=\"[messages]\" filename=\"tests/<exe-name>/UsageTests/Message.tests.cpp\" >\n       <Expression success=\"false\" type=\"CHECK_NOFAIL\" filename=\"tests/<exe-name>/UsageTests/Message.tests.cpp\" >\n         <Original>\n@@ -19667,9 +19726,9 @@ loose text artifact\n       </Section>\n       <OverallResult success=\"true\"/>\n     </TestCase>\n-    <OverallResults successes=\"1925\" failures=\"149\" expectedFailures=\"21\"/>\n-    <OverallResultsCases successes=\"266\" failures=\"86\" expectedFailures=\"4\"/>\n+    <OverallResults successes=\"1930\" failures=\"147\" expectedFailures=\"23\"/>\n+    <OverallResultsCases successes=\"267\" failures=\"86\" expectedFailures=\"6\"/>\n   </Group>\n-  <OverallResults successes=\"1925\" failures=\"148\" expectedFailures=\"21\"/>\n-  <OverallResultsCases successes=\"266\" failures=\"86\" expectedFailures=\"4\"/>\n+  <OverallResults successes=\"1930\" failures=\"146\" expectedFailures=\"23\"/>\n+  <OverallResultsCases successes=\"267\" failures=\"86\" expectedFailures=\"6\"/>\n </Catch>\ndiff --git a/tests/SelfTest/UsageTests/Misc.tests.cpp b/tests/SelfTest/UsageTests/Misc.tests.cpp\nindex 277723a8b7..5dfef6b19a 100644\n--- a/tests/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Misc.tests.cpp\n@@ -182,6 +182,39 @@ TEST_CASE( \"checkedElse, failing\", \"[failing][.]\" ) {\n     REQUIRE( testCheckedElse( false ) );\n }\n \n+TEST_CASE(\"Testing checked-if\", \"[checked-if]\") {\n+    CHECKED_IF(true) {\n+        SUCCEED();\n+    }\n+    CHECKED_IF(false) {\n+        FAIL();\n+    }\n+    CHECKED_ELSE(true) {\n+        FAIL();\n+    }\n+    CHECKED_ELSE(false) {\n+        SUCCEED();\n+    }\n+}\n+\n+TEST_CASE(\"Testing checked-if 2\", \"[checked-if][!shouldfail]\") {\n+    CHECKED_IF(true) {\n+        FAIL();\n+    }\n+    // If the checked if is not entered, this passes and the test\n+    // fails, because of the [!shouldfail] tag.\n+    SUCCEED();\n+}\n+\n+TEST_CASE(\"Testing checked-if 3\", \"[checked-if][!shouldfail]\") {\n+    CHECKED_ELSE(false) {\n+        FAIL();\n+    }\n+    // If the checked false is not entered, this passes and the test\n+    // fails, because of the [!shouldfail] tag.\n+    SUCCEED();\n+}\n+\n TEST_CASE( \"xmlentitycheck\" ) {\n     SECTION( \"embedded xml: <test>it should be possible to embed xml characters, such as <, \\\" or &, or even whole <xml>documents</xml> within an attribute</test>\" ) {\n         SUCCEED(); // We need this here to stop it failing due to no tests\n", "fixed_tests": {"approvaltests": {"run": "PASS", "test": "FAIL", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "FAIL", "fix": "PASS"}}, "p2p_tests": {"randomtestordering": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::reporters::output": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "libidentitytest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "unmatchedoutputfilter": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "checkconvenienceheaders": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wmisleading-indentation": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::tags::output": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::tests::xmloutput": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::tags::exitcode": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "filenameastagsmatching": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "notest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wdeprecated": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::tests::output": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "escapespecialcharactersintestnames": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "testsinfile::invalidtestnames-2": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wunreachable-code": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "noassertions": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "negativespecnohiddentests": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wshadow": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "filteredsection::generatorsdontcauseinfiniteloop-2": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "versioncheck": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wextra": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::tests::exitcode": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wunused-function": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "warnaboutnotests": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wmissing-noreturn": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::tests::quiet": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wmissing-braces": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wpedantic": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "testsinfile::simplespecs": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "regressioncheck-1670": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wparentheses": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wall": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "testsinfile::escapespecialcharacters": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wold-style-cast": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::tags::xmloutput": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "filteredsection-2": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::reporters::exitcode": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "filenameastagstest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "testsinfile::invalidtestnames-1": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wvla": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wundef": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wunused-parameter": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "filteredsection-1": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wmissing-declarations": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "tagalias": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "list::reporters::xmloutput": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wstrict-aliasing": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wsuggest-override": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "filteredsection::generatorsdontcauseinfiniteloop-1": {"run": "PASS", "test": "PASS", "fix": "PASS"}}, "f2p_tests": {"approvaltests": {"run": "PASS", "test": "FAIL", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "FAIL", "fix": "PASS"}}, "s2p_tests": {}, "n2p_tests": {}, "run_result": {"passed_count": 52, "failed_count": 9, "skipped_count": 0, "passed_tests": ["randomtestordering", "list::reporters::output", "libidentitytest", "unmatchedoutputfilter", "checkconvenienceheaders", "have_flag_-wmisleading-indentation", "list::tags::output", "list::tests::xmloutput", "list::tags::exitcode", "list::reporters::xmloutput", "filenameastagsmatching", "notest", "have_flag_-wdeprecated", "list::tests::output", "approvaltests", "escapespecialcharactersintestnames", "testsinfile::invalidtestnames-2", "have_flag_-wunreachable-code", "noassertions", "negativespecnohiddentests", "have_flag_-wshadow", "filteredsection::generatorsdontcauseinfiniteloop-2", "versioncheck", "have_flag_-wextra", "list::tests::exitcode", "warnaboutnotests", "have_flag_-wmissing-noreturn", "list::tests::quiet", "have_flag_-wmissing-braces", "runtests", "have_flag_-wpedantic", "testsinfile::simplespecs", "regressioncheck-1670", "have_flag_-wparentheses", "have_flag_-wall", "testsinfile::escapespecialcharacters", "have_flag_-wold-style-cast", "list::tags::xmloutput", "filteredsection-2", "list::reporters::exitcode", "filenameastagstest", "testsinfile::invalidtestnames-1", "have_flag_-wvla", "have_flag_-wundef", "have_flag_-wunused-parameter", "filteredsection-1", "have_flag_-wmissing-declarations", "tagalias", "have_flag_-wunused-function", "have_flag_-wstrict-aliasing", "have_flag_-wsuggest-override", "filteredsection::generatorsdontcauseinfiniteloop-1"], "failed_tests": ["have_flag_-wglobal-constructors", "have_flag_-wreturn-std-move", "have_flag_-wcall-to-pure-virtual-from-ctor-dtor", "have_flag_-wweak-vtables", "have_flag_-wdeprecated-register", "have_flag_-wexit-time-destructors", "have_flag_-wabsolute-value", "have_flag_-wextra-semi-stmt", "have_flag_-wcatch-value"], "skipped_tests": []}, "test_patch_result": {"passed_count": 50, "failed_count": 11, "skipped_count": 0, "passed_tests": ["randomtestordering", "list::reporters::output", "libidentitytest", "unmatchedoutputfilter", "checkconvenienceheaders", "have_flag_-wmisleading-indentation", "list::tags::output", "list::tests::xmloutput", "list::tags::exitcode", "list::reporters::xmloutput", "filenameastagsmatching", "notest", "have_flag_-wdeprecated", "list::tests::output", "escapespecialcharactersintestnames", "testsinfile::invalidtestnames-2", "have_flag_-wunreachable-code", "noassertions", "negativespecnohiddentests", "have_flag_-wshadow", "filteredsection::generatorsdontcauseinfiniteloop-2", "versioncheck", "have_flag_-wextra", "list::tests::exitcode", "warnaboutnotests", "have_flag_-wmissing-noreturn", "list::tests::quiet", "have_flag_-wmissing-braces", "have_flag_-wpedantic", "testsinfile::simplespecs", "regressioncheck-1670", "have_flag_-wparentheses", "have_flag_-wall", "testsinfile::escapespecialcharacters", "have_flag_-wold-style-cast", "list::tags::xmloutput", "filteredsection-2", "list::reporters::exitcode", "filenameastagstest", "testsinfile::invalidtestnames-1", "have_flag_-wvla", "have_flag_-wundef", "have_flag_-wunused-parameter", "filteredsection-1", "have_flag_-wmissing-declarations", "tagalias", "have_flag_-wunused-function", "have_flag_-wstrict-aliasing", "have_flag_-wsuggest-override", "filteredsection::generatorsdontcauseinfiniteloop-1"], "failed_tests": ["approvaltests", "have_flag_-wglobal-constructors", "have_flag_-wreturn-std-move", "have_flag_-wcall-to-pure-virtual-from-ctor-dtor", "have_flag_-wweak-vtables", "have_flag_-wdeprecated-register", "runtests", "have_flag_-wexit-time-destructors", "have_flag_-wabsolute-value", "have_flag_-wextra-semi-stmt", "have_flag_-wcatch-value"], "skipped_tests": []}, "fix_patch_result": {"passed_count": 52, "failed_count": 9, "skipped_count": 0, "passed_tests": ["randomtestordering", "list::reporters::output", "libidentitytest", "unmatchedoutputfilter", "checkconvenienceheaders", "have_flag_-wmisleading-indentation", "list::tags::output", "list::tests::xmloutput", "list::tags::exitcode", "list::reporters::xmloutput", "filenameastagsmatching", "notest", "have_flag_-wdeprecated", "list::tests::output", "approvaltests", "escapespecialcharactersintestnames", "testsinfile::invalidtestnames-2", "have_flag_-wunreachable-code", "noassertions", "negativespecnohiddentests", "have_flag_-wshadow", "filteredsection::generatorsdontcauseinfiniteloop-2", "versioncheck", "have_flag_-wextra", "list::tests::exitcode", "warnaboutnotests", "have_flag_-wmissing-noreturn", "list::tests::quiet", "have_flag_-wmissing-braces", "runtests", "have_flag_-wpedantic", "testsinfile::simplespecs", "regressioncheck-1670", "have_flag_-wparentheses", "have_flag_-wall", "testsinfile::escapespecialcharacters", "have_flag_-wold-style-cast", "list::tags::xmloutput", "filteredsection-2", "list::reporters::exitcode", "filenameastagstest", "testsinfile::invalidtestnames-1", "have_flag_-wvla", "have_flag_-wundef", "have_flag_-wunused-parameter", "filteredsection-1", "have_flag_-wmissing-declarations", "tagalias", "have_flag_-wunused-function", "have_flag_-wstrict-aliasing", "have_flag_-wsuggest-override", "filteredsection::generatorsdontcauseinfiniteloop-1"], "failed_tests": ["have_flag_-wglobal-constructors", "have_flag_-wreturn-std-move", "have_flag_-wcall-to-pure-virtual-from-ctor-dtor", "have_flag_-wweak-vtables", "have_flag_-wdeprecated-register", "have_flag_-wexit-time-destructors", "have_flag_-wabsolute-value", "have_flag_-wextra-semi-stmt", "have_flag_-wcatch-value"], "skipped_tests": []}, "instance_id": "catchorg__Catch2-2187"}
{"org": "catchorg", "repo": "Catch2", "number": 2128, "state": "closed", "title": "Comparison expression creation fix", "body": "## Description\r\nWhy.\r\nThis PR fixes the issue that user-defined operators can be a better match than the ones used to create Catch2 expression (defined in `Decomposer` and `ExprLhs`).\r\n\r\nWhat.\r\n- Overload with forwarding reference is added for all the comparison operators used in expressions.\r\n- This overload doesn't compile for bit field non-const reference, so another overload that takes all arithmetic types by value is added. It replaces `bool` overload where it existed before.\r\n- Operators are now defined as hidden friends to fix compilation on GCC.\r\n\r\n## GitHub Issues\r\nCloses #2121\r\n\r\n## Note\r\nI'm sorry for not fully reading the contribution guidelines. I just have a problem and propose a solution. Feel free to edit my code.", "base": {"label": "catchorg:devel", "ref": "devel", "sha": "65c9a1d31a338f28ef93cd61c475efc40f6cc42e"}, "resolved_issues": [{"number": 2121, "title": "Problem with user provided operator == (with proposed fix)", "body": "**Describe the bug**\r\nThe test doesn't compile when the user provides a more general `operator ==` overload than `ExprLhs`.\r\n`operator ==` in the code sample below is a better match when r-value reference is passed because it accepts forwarding reference (`U&&`) and `ExprLhs` accepts only const reference (`RhsT const& rhs`) https://github.com/catchorg/Catch2/blob/devel/src/catch2/internal/catch_decomposer.hpp#L187\r\n```\r\n        template<typename RhsT>\r\n        auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\r\n            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\"_sr, rhs };\r\n        }\r\n```\r\n\r\n**Expected behavior**\r\nThe test should compile.\r\n\r\n**Reproduction steps**\r\n```\r\nnamespace adl {\r\n\r\nstruct activate_adl {};\r\n\r\nstruct equality_expression {\r\n    operator bool() const { return true; }\r\n};\r\n\r\ntemplate <class T, class U>\r\nconstexpr auto operator == (T&&, U&&) {\r\n    return equality_expression{};\r\n}\r\n\r\n}\r\n\r\nTEST_CASE(\"User provided equality operator\", \"[compilation]\") {\r\n    REQUIRE(0 == adl::activate_adl{});\r\n}\r\n```\r\nerror: no matching member function for call to 'handleExpr' REQUIRE(0 == adl::activate_adl{});\r\n\r\n**Fix**\r\nMy first attempt was to change the `operator == ` definition (and similarly all other operators) to\r\n```\r\n        template<typename RhsT>\r\n        auto operator == ( RhsT && rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\r\n            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\"_sr, rhs };\r\n        }\r\n```\r\nHowever, this broke a test for bitfields\r\nerror: non-const reference cannot bind to bit-field 'v' REQUIRE(0 == y.v);\r\n\r\nThis can be resolved by two not so clean overloads, maybe you know a better way:\r\n```\r\n        template<typename RhsT>\r\n        auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\r\n            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\"_sr, rhs };\r\n        }\r\n        template<typename RhsT, std::enable_if_t<!std::is_arithmetic<std::decay_t<RhsT>>::value, int> = 0>\r\n        auto operator == ( RhsT && rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\r\n            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\"_sr, rhs };\r\n        }\r\n```\r\n\r\n**Unrelated note**\r\nI don't think const reference here prolongs the lifetime of rhs, because it's not local but stored in a class: `BinaryExpr<LhsT, RhsT const&>`. Not sure if it's a problem."}], "fix_patch": "diff --git a/src/catch2/internal/catch_decomposer.hpp b/src/catch2/internal/catch_decomposer.hpp\nindex 9af5c19f70..a747c34cd6 100644\n--- a/src/catch2/internal/catch_decomposer.hpp\n+++ b/src/catch2/internal/catch_decomposer.hpp\n@@ -183,60 +183,53 @@ namespace Catch {\n     public:\n         explicit ExprLhs( LhsT lhs ) : m_lhs( lhs ) {}\n \n-        template<typename RhsT>\n-        auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\"_sr, rhs };\n+        template<typename RhsT, std::enable_if_t<!std::is_arithmetic<std::remove_reference_t<RhsT>>::value, int> = 0>\n+        friend auto operator == ( ExprLhs && lhs, RhsT && rhs ) -> BinaryExpr<LhsT, RhsT const&> {\n+            return { compareEqual( lhs.m_lhs, rhs ), lhs.m_lhs, \"==\"_sr, rhs };\n         }\n-        auto operator == ( bool rhs ) -> BinaryExpr<LhsT, bool> const {\n-            return { m_lhs == rhs, m_lhs, \"==\"_sr, rhs };\n+        template<typename RhsT, std::enable_if_t<std::is_arithmetic<RhsT>::value, int> = 0>\n+        friend auto operator == ( ExprLhs && lhs, RhsT rhs ) -> BinaryExpr<LhsT, RhsT> {\n+            return { compareEqual( lhs.m_lhs, rhs ), lhs.m_lhs, \"==\"_sr, rhs };\n         }\n \n-        template<typename RhsT>\n-        auto operator != ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { compareNotEqual( m_lhs, rhs ), m_lhs, \"!=\"_sr, rhs };\n+        template<typename RhsT, std::enable_if_t<!std::is_arithmetic<std::remove_reference_t<RhsT>>::value, int> = 0>\n+        friend auto operator != ( ExprLhs && lhs, RhsT && rhs ) -> BinaryExpr<LhsT, RhsT const&> {\n+            return { compareNotEqual( lhs.m_lhs, rhs ), lhs.m_lhs, \"!=\"_sr, rhs };\n         }\n-        auto operator != ( bool rhs ) -> BinaryExpr<LhsT, bool> const {\n-            return { m_lhs != rhs, m_lhs, \"!=\"_sr, rhs };\n+        template<typename RhsT, std::enable_if_t<std::is_arithmetic<RhsT>::value, int> = 0>\n+        friend auto operator != ( ExprLhs && lhs, RhsT rhs ) -> BinaryExpr<LhsT, RhsT> {\n+            return { compareNotEqual( lhs.m_lhs, rhs ), lhs.m_lhs, \"!=\"_sr, rhs };\n         }\n \n-        template<typename RhsT>\n-        auto operator > ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs > rhs), m_lhs, \">\"_sr, rhs };\n-        }\n-        template<typename RhsT>\n-        auto operator < ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs < rhs), m_lhs, \"<\"_sr, rhs };\n-        }\n-        template<typename RhsT>\n-        auto operator >= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs >= rhs), m_lhs, \">=\"_sr, rhs };\n-        }\n-        template<typename RhsT>\n-        auto operator <= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs <= rhs), m_lhs, \"<=\"_sr, rhs };\n-        }\n-        template <typename RhsT>\n-        auto operator | (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs | rhs), m_lhs, \"|\"_sr, rhs };\n-        }\n-        template <typename RhsT>\n-        auto operator & (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs & rhs), m_lhs, \"&\"_sr, rhs };\n-        }\n-        template <typename RhsT>\n-        auto operator ^ (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs ^ rhs), m_lhs, \"^\"_sr, rhs };\n+    #define CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(op) \\\n+        template<typename RhsT, std::enable_if_t<!std::is_arithmetic<std::remove_reference_t<RhsT>>::value, int> = 0> \\\n+        friend auto operator op ( ExprLhs && lhs, RhsT && rhs ) -> BinaryExpr<LhsT, RhsT const&> { \\\n+            return { static_cast<bool>(lhs.m_lhs op rhs), lhs.m_lhs, #op##_sr, rhs }; \\\n+        } \\\n+        template<typename RhsT, std::enable_if_t<std::is_arithmetic<RhsT>::value, int> = 0> \\\n+        friend auto operator op ( ExprLhs && lhs, RhsT rhs ) -> BinaryExpr<LhsT, RhsT> { \\\n+            return { static_cast<bool>(lhs.m_lhs op rhs), lhs.m_lhs, #op##_sr, rhs }; \\\n         }\n \n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(<)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(>)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(<=)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(>=)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(|)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(&)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(^)\n+\n+    #undef CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR\n+\n         template<typename RhsT>\n-        auto operator && ( RhsT const& ) -> BinaryExpr<LhsT, RhsT const&> const {\n+        friend auto operator && ( ExprLhs &&, RhsT && ) -> BinaryExpr<LhsT, RhsT const&> {\n             static_assert(always_false<RhsT>::value,\n             \"operator&& is not supported inside assertions, \"\n             \"wrap the expression inside parentheses, or decompose it\");\n         }\n \n         template<typename RhsT>\n-        auto operator || ( RhsT const& ) -> BinaryExpr<LhsT, RhsT const&> const {\n+        friend auto operator || ( ExprLhs &&, RhsT && ) -> BinaryExpr<LhsT, RhsT const&> {\n             static_assert(always_false<RhsT>::value,\n             \"operator|| is not supported inside assertions, \"\n             \"wrap the expression inside parentheses, or decompose it\");\n@@ -247,21 +240,15 @@ namespace Catch {\n         }\n     };\n \n-    void handleExpression( ITransientExpression const& expr );\n-\n-    template<typename T>\n-    void handleExpression( ExprLhs<T> const& expr ) {\n-        handleExpression( expr.makeUnaryExpr() );\n-    }\n-\n     struct Decomposer {\n-        template<typename T>\n-        auto operator <= ( T const& lhs ) -> ExprLhs<T const&> {\n-            return ExprLhs<T const&>{ lhs };\n+        template<typename T, std::enable_if_t<!std::is_arithmetic<std::remove_reference_t<T>>::value, int> = 0>\n+        friend auto operator <= ( Decomposer &&, T && lhs ) -> ExprLhs<T const&> {\n+            return ExprLhs<const T&>{ lhs };\n         }\n \n-        auto operator <=( bool value ) -> ExprLhs<bool> {\n-            return ExprLhs<bool>{ value };\n+        template<typename T, std::enable_if_t<std::is_arithmetic<T>::value, int> = 0>\n+        friend auto operator <= ( Decomposer &&, T value ) -> ExprLhs<T> {\n+            return ExprLhs<T>{ value };\n         }\n     };\n \n", "test_patch": "diff --git a/tests/SelfTest/UsageTests/Compilation.tests.cpp b/tests/SelfTest/UsageTests/Compilation.tests.cpp\nindex 5f8c82a38a..cce190f2cb 100644\n--- a/tests/SelfTest/UsageTests/Compilation.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Compilation.tests.cpp\n@@ -277,3 +277,42 @@ namespace {\n TEST_CASE(\"Immovable types are supported in basic assertions\", \"[compilation][.approvals]\") {\n     REQUIRE(ImmovableType{} == ImmovableType{});\n }\n+\n+namespace adl {\n+\n+struct always_true {\n+    explicit operator bool() const { return true; }\n+};\n+\n+#define COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(op) \\\n+template <class T, class U> \\\n+auto operator op (T&&, U&&) { \\\n+    return always_true{}; \\\n+}\n+\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(==)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(!=)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(<)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(>)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(<=)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(>=)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(|)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(&)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(^)\n+\n+#undef COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR\n+\n+}\n+\n+TEST_CASE(\"ADL universal operators don't hijack expression deconstruction\", \"[compilation][.approvals]\") {\n+    REQUIRE(adl::always_true{});\n+    REQUIRE(0 == adl::always_true{});\n+    REQUIRE(0 != adl::always_true{});\n+    REQUIRE(0 < adl::always_true{});\n+    REQUIRE(0 > adl::always_true{});\n+    REQUIRE(0 <= adl::always_true{});\n+    REQUIRE(0 >= adl::always_true{});\n+    REQUIRE(0 | adl::always_true{});\n+    REQUIRE(0 & adl::always_true{});\n+    REQUIRE(0 ^ adl::always_true{});\n+}\n", "fixed_tests": {"randomtestordering": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::reporters::output": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "libidentitytest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "unmatchedoutputfilter": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "checkconvenienceheaders": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tags::output": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::xmloutput": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tags::exitcode": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filenameastagsmatching": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "notest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::output": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "approvaltests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "escapespecialcharactersintestnames": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::invalidtestnames-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "noassertions": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "negativespecnohiddentests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection::generatorsdontcauseinfiniteloop-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "versioncheck": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::exitcode": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "warnaboutnotests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::quiet": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::simplespecs": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "regressioncheck-1670": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::escapespecialcharacters": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tags::xmloutput": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::reporters::exitcode": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filenameastagstest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::invalidtestnames-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "tagalias": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::reporters::xmloutput": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection::generatorsdontcauseinfiniteloop-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "p2p_tests": {"have_flag_-wmisleading-indentation": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wdeprecated": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wunreachable-code": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wshadow": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wextra": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wunused-function": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wmissing-noreturn": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wmissing-braces": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wpedantic": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wparentheses": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wall": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wold-style-cast": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wvla": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wundef": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wunused-parameter": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wmissing-declarations": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wstrict-aliasing": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "have_flag_-wsuggest-override": {"run": "PASS", "test": "PASS", "fix": "PASS"}}, "f2p_tests": {}, "s2p_tests": {}, "n2p_tests": {"randomtestordering": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::reporters::output": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "libidentitytest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "unmatchedoutputfilter": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "checkconvenienceheaders": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tags::output": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::xmloutput": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tags::exitcode": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filenameastagsmatching": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "notest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::output": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "approvaltests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "escapespecialcharactersintestnames": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::invalidtestnames-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "noassertions": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "negativespecnohiddentests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection::generatorsdontcauseinfiniteloop-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "versioncheck": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::exitcode": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "warnaboutnotests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tests::quiet": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::simplespecs": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "regressioncheck-1670": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::escapespecialcharacters": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::tags::xmloutput": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::reporters::exitcode": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filenameastagstest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "testsinfile::invalidtestnames-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "tagalias": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "list::reporters::xmloutput": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection::generatorsdontcauseinfiniteloop-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "run_result": {"passed_count": 52, "failed_count": 9, "skipped_count": 0, "passed_tests": ["randomtestordering", "list::reporters::output", "libidentitytest", "unmatchedoutputfilter", "checkconvenienceheaders", "have_flag_-wmisleading-indentation", "list::tags::output", "list::tests::xmloutput", "list::tags::exitcode", "list::reporters::xmloutput", "filenameastagsmatching", "notest", "have_flag_-wdeprecated", "list::tests::output", "approvaltests", "escapespecialcharactersintestnames", "testsinfile::invalidtestnames-2", "have_flag_-wunreachable-code", "noassertions", "negativespecnohiddentests", "have_flag_-wshadow", "filteredsection::generatorsdontcauseinfiniteloop-2", "versioncheck", "have_flag_-wextra", "list::tests::exitcode", "warnaboutnotests", "have_flag_-wmissing-noreturn", "list::tests::quiet", "have_flag_-wmissing-braces", "runtests", "have_flag_-wpedantic", "testsinfile::simplespecs", "regressioncheck-1670", "have_flag_-wparentheses", "have_flag_-wall", "testsinfile::escapespecialcharacters", "have_flag_-wold-style-cast", "list::tags::xmloutput", "filteredsection-2", "list::reporters::exitcode", "filenameastagstest", "testsinfile::invalidtestnames-1", "have_flag_-wvla", "have_flag_-wundef", "have_flag_-wunused-parameter", "filteredsection-1", "have_flag_-wmissing-declarations", "tagalias", "have_flag_-wunused-function", "have_flag_-wstrict-aliasing", "have_flag_-wsuggest-override", "filteredsection::generatorsdontcauseinfiniteloop-1"], "failed_tests": ["have_flag_-wglobal-constructors", "have_flag_-wreturn-std-move", "have_flag_-wcall-to-pure-virtual-from-ctor-dtor", "have_flag_-wweak-vtables", "have_flag_-wdeprecated-register", "have_flag_-wexit-time-destructors", "have_flag_-wabsolute-value", "have_flag_-wextra-semi-stmt", "have_flag_-wcatch-value"], "skipped_tests": []}, "test_patch_result": {"passed_count": 18, "failed_count": 9, "skipped_count": 0, "passed_tests": ["have_flag_-wold-style-cast", "have_flag_-wextra", "have_flag_-wshadow", "have_flag_-wvla", "have_flag_-wunused-function", "have_flag_-wmissing-noreturn", "have_flag_-wdeprecated", "have_flag_-wunreachable-code", "have_flag_-wmisleading-indentation", "have_flag_-wmissing-braces", "have_flag_-wundef", "have_flag_-wpedantic", "have_flag_-wunused-parameter", "have_flag_-wmissing-declarations", "have_flag_-wparentheses", "have_flag_-wall", "have_flag_-wstrict-aliasing", "have_flag_-wsuggest-override"], "failed_tests": ["have_flag_-wglobal-constructors", "have_flag_-wreturn-std-move", "have_flag_-wcall-to-pure-virtual-from-ctor-dtor", "have_flag_-wweak-vtables", "have_flag_-wdeprecated-register", "have_flag_-wexit-time-destructors", "have_flag_-wabsolute-value", "have_flag_-wextra-semi-stmt", "have_flag_-wcatch-value"], "skipped_tests": []}, "fix_patch_result": {"passed_count": 52, "failed_count": 9, "skipped_count": 0, "passed_tests": ["randomtestordering", "list::reporters::output", "libidentitytest", "unmatchedoutputfilter", "checkconvenienceheaders", "have_flag_-wmisleading-indentation", "list::tags::output", "list::tests::xmloutput", "list::tags::exitcode", "list::reporters::xmloutput", "filenameastagsmatching", "notest", "have_flag_-wdeprecated", "list::tests::output", "approvaltests", "escapespecialcharactersintestnames", "testsinfile::invalidtestnames-2", "have_flag_-wunreachable-code", "noassertions", "negativespecnohiddentests", "have_flag_-wshadow", "filteredsection::generatorsdontcauseinfiniteloop-2", "versioncheck", "have_flag_-wextra", "list::tests::exitcode", "warnaboutnotests", "have_flag_-wmissing-noreturn", "list::tests::quiet", "have_flag_-wmissing-braces", "runtests", "have_flag_-wpedantic", "testsinfile::simplespecs", "regressioncheck-1670", "have_flag_-wparentheses", "have_flag_-wall", "testsinfile::escapespecialcharacters", "have_flag_-wold-style-cast", "list::tags::xmloutput", "filteredsection-2", "list::reporters::exitcode", "filenameastagstest", "testsinfile::invalidtestnames-1", "have_flag_-wvla", "have_flag_-wundef", "have_flag_-wunused-parameter", "filteredsection-1", "have_flag_-wmissing-declarations", "tagalias", "have_flag_-wunused-function", "have_flag_-wstrict-aliasing", "have_flag_-wsuggest-override", "filteredsection::generatorsdontcauseinfiniteloop-1"], "failed_tests": ["have_flag_-wglobal-constructors", "have_flag_-wreturn-std-move", "have_flag_-wcall-to-pure-virtual-from-ctor-dtor", "have_flag_-wweak-vtables", "have_flag_-wdeprecated-register", "have_flag_-wexit-time-destructors", "have_flag_-wabsolute-value", "have_flag_-wextra-semi-stmt", "have_flag_-wcatch-value"], "skipped_tests": []}, "instance_id": "catchorg__Catch2-2128"}
{"org": "catchorg", "repo": "Catch2", "number": 1616, "state": "closed", "title": "Integrate nonius to provide more advanced benchmarking", "body": "Integrates nonius benchmark library to catch to make benchmarks a good bit more advanced.\r\n\r\nThis implementation nearly works as a drop-in replacement for the old `BENCHMARK` macro - just a `;` needs to be added - and adds a whole lot of improvements:\r\n- proper warming-up\r\n- avoiding the benchmark to be optimized away\r\n- analysis of the runs (with mean, std deviation, outlier classification)\r\n\r\nI guess this is a appropriate fix for #852 and also resolves #1186.\r\n\r\nLeft tasks/questions:\r\n- [x] not sure if the functionality of `internal/benchmark/catch_constructor.hpp` is really needed, or I should remove it?\r\n- [x] some more reporters should probably be supported. Added reporting to xml reporter. ~~(juint has been supported by nonius, so for example output see [there](https://github.com/libnonius/nonius/blob/devel/include/nonius/reporters/junit_reporter.h%2B%2B#L88)..)~~\r\n- [x] need to do approval testing..\r\n\r\nTo collect feedback about the reported info, here's some output from the `Benchmark.tests.cpp`:\r\n![image](https://user-images.githubusercontent.com/5982050/56852779-a1257500-691f-11e9-830e-37e20713ad46.png)\r\n", "base": {"label": "catchorg:master", "ref": "master", "sha": "00347f1e79260e76d5072cca5b3636868397dda5"}, "resolved_issues": [{"number": 1186, "title": "Rename #define BENCHMARK or allow disabling benchmark feature", "body": "## Description\r\n\r\nThe `#define BENCHMARK` in https://github.com/catchorg/Catch2/commit/a9b6813ad9e423ddcd6559f52b503a68fe0f624c#diff-c06d59fb4f39c13fb9a355b49d321fcfR52 is an unfortunate name, with high potential of clashes.\r\n\r\nFor example, it clashes with (older) benchmarking framework, see https://github.com/DigitalInBlue/Celero/commit/dc6853478aece4da17e177f285896648b23dc2fd#diff-f1b66ca763828028068774e33319efb4R137 The generic `BENCHMARK` name issue also reported to Celero https://github.com/DigitalInBlue/Celero/issues/114\r\n\r\nIt would be extremely helpful Catch offers a `#define` to allow disabling the whole benchmarking feature all the way.\r\n\r\n"}], "fix_patch": "diff --git a/docs/benchmarks.md b/docs/benchmarks.md\nnew file mode 100644\nindex 0000000000..3426b365a9\n--- /dev/null\n+++ b/docs/benchmarks.md\n@@ -0,0 +1,249 @@\n+# Authoring benchmarks\n+\n+Writing benchmarks is not easy. Catch simplifies certain aspects but you'll\n+always need to take care about various aspects. Understanding a few things about\n+the way Catch runs your code will be very helpful when writing your benchmarks.\n+\n+First off, let's go over some terminology that will be used throughout this\n+guide.\n+\n+- *User code*: user code is the code that the user provides to be measured.\n+- *Run*: one run is one execution of the user code.\n+- *Sample*: one sample is one data point obtained by measuring the time it takes\n+  to perform a certain number of runs. One sample can consist of more than one\n+  run if the clock available does not have enough resolution to accurately\n+  measure a single run. All samples for a given benchmark execution are obtained\n+  with the same number of runs.\n+\n+## Execution procedure\n+\n+Now I can explain how a benchmark is executed in Catch. There are three main\n+steps, though the first does not need to be repeated for every benchmark.\n+\n+1. *Environmental probe*: before any benchmarks can be executed, the clock's\n+resolution is estimated. A few other environmental artifacts are also estimated\n+at this point, like the cost of calling the clock function, but they almost\n+never have any impact in the results.\n+\n+2. *Estimation*: the user code is executed a few times to obtain an estimate of\n+the amount of runs that should be in each sample. This also has the potential\n+effect of bringing relevant code and data into the caches before the actual\n+measurement starts.\n+\n+3. *Measurement*: all the samples are collected sequentially by performing the\n+number of runs estimated in the previous step for each sample.\n+\n+This already gives us one important rule for writing benchmarks for Catch: the\n+benchmarks must be repeatable. The user code will be executed several times, and\n+the number of times it will be executed during the estimation step cannot be\n+known beforehand since it depends on the time it takes to execute the code.\n+User code that cannot be executed repeatedly will lead to bogus results or\n+crashes.\n+\n+## Benchmark specification\n+\n+Benchmarks can be specified anywhere inside a Catch test case.\n+There is a simple and a slightly more advanced version of the `BENCHMARK` macro.\n+\n+Let's have a look how a naive Fibonacci implementation could be benchmarked:\n+```c++\n+std::uint64_t Fibonacci(std::uint64_t number) {\n+    return number < 2 ? 1 : Fibonacci(number - 1) + Fibonacci(number - 2);\n+}\n+```\n+Now the most straight forward way to benchmark this function, is just adding a `BENCHMARK` macro to our test case:\n+```c++\n+TEST_CASE(\"Fibonacci\") {\n+    CHECK(Fibonacci(0) == 1);\n+    // some more asserts..\n+    CHECK(Fibonacci(5) == 8);\n+    // some more asserts..\n+\n+    // now let's benchmark:\n+    BENCHMARK(\"Fibonacci 20\") {\n+        return Fibonacci(20);\n+    };\n+\n+    BENCHMARK(\"Fibonacci 25\") {\n+        return Fibonacci(25);\n+    };\n+\n+    BENCHMARK(\"Fibonacci 30\") {\n+        return Fibonacci(30);\n+    };\n+\n+    BENCHMARK(\"Fibonacci 35\") {\n+        return Fibonacci(35);\n+    };\n+}\n+```\n+There's a few things to note:\n+- As `BENCHMARK` expands to a lambda expression it is necessary to add a semicolon after\n+ the closing brace (as opposed to the first experimental version).\n+- The `return` is a handy way to avoid the compiler optimizing away the benchmark code.\n+\n+Running this already runs the benchmarks and outputs something similar to:\n+```\n+-------------------------------------------------------------------------------\n+Fibonacci\n+-------------------------------------------------------------------------------\n+C:\\path\\to\\Catch2\\Benchmark.tests.cpp(10)\n+...............................................................................\n+benchmark name                                  samples       iterations    estimated\n+                                                mean          low mean      high mean\n+                                                std dev       low std dev   high std dev\n+-------------------------------------------------------------------------------\n+Fibonacci 20                                            100       416439   83.2878 ms\n+                                                       2 ns         2 ns         2 ns\n+                                                       0 ns         0 ns         0 ns\n+\n+Fibonacci 25                                            100       400776   80.1552 ms\n+                                                       3 ns         3 ns         3 ns\n+                                                       0 ns         0 ns         0 ns\n+\n+Fibonacci 30                                            100       396873   79.3746 ms\n+                                                      17 ns        17 ns        17 ns\n+                                                       0 ns         0 ns         0 ns\n+\n+Fibonacci 35                                            100       145169   87.1014 ms\n+                                                     468 ns       464 ns       473 ns\n+                                                      21 ns        15 ns        34 ns\n+```\n+\n+### Advanced benchmarking\n+The simplest use case shown above, takes no arguments and just runs the user code that needs to be measured.\n+However, if using the `BENCHMARK_ADVANCED` macro and adding a `Catch::Benchmark::Chronometer` argument after\n+the macro, some advanced features are available. The contents of the simple benchmarks are invoked once per run,\n+while the blocks of the advanced benchmarks are invoked exactly twice:\n+once during the estimation phase, and another time during the execution phase.\n+\n+```c++\n+BENCHMARK(\"simple\"){ return long_computation(); };\n+\n+BENCHMARK_ADVANCED(\"advanced\")(Catch::Benchmark::Chronometer meter) {\n+    set_up();\n+    meter.measure([] { return long_computation(); });\n+};\n+```\n+\n+These advanced benchmarks no longer consist entirely of user code to be measured.\n+In these cases, the code to be measured is provided via the\n+`Catch::Benchmark::Chronometer::measure` member function. This allows you to set up any\n+kind of state that might be required for the benchmark but is not to be included\n+in the measurements, like making a vector of random integers to feed to a\n+sorting algorithm.\n+\n+A single call to `Catch::Benchmark::Chronometer::measure` performs the actual measurements\n+by invoking the callable object passed in as many times as necessary. Anything\n+that needs to be done outside the measurement can be done outside the call to\n+`measure`.\n+\n+The callable object passed in to `measure` can optionally accept an `int`\n+parameter.\n+\n+```c++\n+meter.measure([](int i) { return long_computation(i); });\n+```\n+\n+If it accepts an `int` parameter, the sequence number of each run will be passed\n+in, starting with 0. This is useful if you want to measure some mutating code,\n+for example. The number of runs can be known beforehand by calling\n+`Catch::Benchmark::Chronometer::runs`; with this one can set up a different instance to be\n+mutated by each run.\n+\n+```c++\n+std::vector<std::string> v(meter.runs());\n+std::fill(v.begin(), v.end(), test_string());\n+meter.measure([&v](int i) { in_place_escape(v[i]); });\n+```\n+\n+Note that it is not possible to simply use the same instance for different runs\n+and resetting it between each run since that would pollute the measurements with\n+the resetting code.\n+\n+It is also possible to just provide an argument name to the simple `BENCHMARK` macro to get \n+the same semantics as providing a callable to `meter.measure` with `int` argument:\n+\n+```c++\n+BENCHMARK(\"indexed\", i){ return long_computation(i); };\n+```\n+\n+### Constructors and destructors\n+\n+All of these tools give you a lot mileage, but there are two things that still\n+need special handling: constructors and destructors. The problem is that if you\n+use automatic objects they get destroyed by the end of the scope, so you end up\n+measuring the time for construction and destruction together. And if you use\n+dynamic allocation instead, you end up including the time to allocate memory in\n+the measurements.\n+\n+To solve this conundrum, Catch provides class templates that let you manually\n+construct and destroy objects without dynamic allocation and in a way that lets\n+you measure construction and destruction separately.\n+\n+```c++\n+BENCHMARK_ADVANCED(\"construct\")(Catch::Benchmark::Chronometer meter)\n+{\n+    std::vector<Catch::Benchmark::storage_for<std::string>> storage(meter.runs());\n+    meter.measure([&](int i) { storage[i].construct(\"thing\"); });\n+})\n+\n+BENCHMARK_ADVANCED(\"destroy\", [](Catch::Benchmark::Chronometer meter)\n+{\n+    std::vector<Catch::Benchmark::destructable_object<std::string>> storage(meter.runs());\n+    for(auto&& o : storage)\n+        o.construct(\"thing\");\n+    meter.measure([&](int i) { storage[i].destruct(); });\n+})\n+```\n+\n+`Catch::Benchmark::storage_for<T>` objects are just pieces of raw storage suitable for `T`\n+objects. You can use the `Catch::Benchmark::storage_for::construct` member function to call a constructor and\n+create an object in that storage. So if you want to measure the time it takes\n+for a certain constructor to run, you can just measure the time it takes to run\n+this function.\n+\n+When the lifetime of a `Catch::Benchmark::storage_for<T>` object ends, if an actual object was\n+constructed there it will be automatically destroyed, so nothing leaks.\n+\n+If you want to measure a destructor, though, we need to use\n+`Catch::Benchmark::destructable_object<T>`. These objects are similar to\n+`Catch::Benchmark::storage_for<T>` in that construction of the `T` object is manual, but\n+it does not destroy anything automatically. Instead, you are required to call\n+the `Catch::Benchmark::destructable_object::destruct` member function, which is what you\n+can use to measure the destruction time.\n+\n+### The optimizer\n+\n+Sometimes the optimizer will optimize away the very code that you want to\n+measure. There are several ways to use results that will prevent the optimiser\n+from removing them. You can use the `volatile` keyword, or you can output the\n+value to standard output or to a file, both of which force the program to\n+actually generate the value somehow.\n+\n+Catch adds a third option. The values returned by any function provided as user\n+code are guaranteed to be evaluated and not optimised out. This means that if\n+your user code consists of computing a certain value, you don't need to bother\n+with using `volatile` or forcing output. Just `return` it from the function.\n+That helps with keeping the code in a natural fashion.\n+\n+Here's an example:\n+\n+```c++\n+// may measure nothing at all by skipping the long calculation since its\n+// result is not used\n+BENCHMARK(\"no return\"){ long_calculation(); };\n+\n+// the result of long_calculation() is guaranteed to be computed somehow\n+BENCHMARK(\"with return\"){ return long_calculation(); };\n+```\n+\n+However, there's no other form of control over the optimizer whatsoever. It is\n+up to you to write a benchmark that actually measures what you want and doesn't\n+just measure the time to do a whole bunch of nothing.\n+\n+To sum up, there are two simple rules: whatever you would do in handwritten code\n+to control optimization still works in Catch; and Catch makes return values\n+from user code into observable effects that can't be optimized away.\n+\n+<i>Adapted from nonius' documentation.</i>\ndiff --git a/docs/command-line.md b/docs/command-line.md\nindex f68c84ca83..d52d437ec2 100644\n--- a/docs/command-line.md\n+++ b/docs/command-line.md\n@@ -20,7 +20,10 @@\n [Specify a seed for the Random Number Generator](#specify-a-seed-for-the-random-number-generator)<br>\n [Identify framework and version according to the libIdentify standard](#identify-framework-and-version-according-to-the-libidentify-standard)<br>\n [Wait for key before continuing](#wait-for-key-before-continuing)<br>\n-[Specify multiples of clock resolution to run benchmarks for](#specify-multiples-of-clock-resolution-to-run-benchmarks-for)<br>\n+[Specify the number of benchmark samples to collect](#specify-the-number-of-benchmark-samples-to-collect)<br>\n+[Specify the number of benchmark resamples for bootstrapping](#specify-the-number-of-resamples-for-bootstrapping)<br>\n+[Specify the confidence interval for bootstrapping](#specify-the-confidence-interval-for-bootstrapping)<br>\n+[Disable statistical analysis of collected benchmark samples](#disable-statistical-analysis-of-collected-benchmark-samples)<br>\n [Usage](#usage)<br>\n [Specify the section to run](#specify-the-section-to-run)<br>\n [Filenames as tags](#filenames-as-tags)<br>\n@@ -57,7 +60,10 @@ Click one of the following links to take you straight to that option - or scroll\n <a href=\"#rng-seed\">                                    `    --rng-seed`</a><br />\n <a href=\"#libidentify\">                                 `    --libidentify`</a><br />\n <a href=\"#wait-for-keypress\">                           `    --wait-for-keypress`</a><br />\n-<a href=\"#benchmark-resolution-multiple\">               `    --benchmark-resolution-multiple`</a><br />\n+<a href=\"#benchmark-samples\">                           `    --benchmark-samples`</a><br />\n+<a href=\"#benchmark-resamples\">                         `    --benchmark-resamples`</a><br />\n+<a href=\"#benchmark-confidence-interval\">               `    --benchmark-confidence-interval`</a><br />\n+<a href=\"#benchmark-no-analysis\">                       `    --benchmark-no-analysis`</a><br />\n <a href=\"#use-colour\">                                  `    --use-colour`</a><br />\n \n </br>\n@@ -267,13 +273,40 @@ See [The LibIdentify repo for more information and examples](https://github.com/\n Will cause the executable to print a message and wait until the return/ enter key is pressed before continuing -\n either before running any tests, after running all tests - or both, depending on the argument.\n \n-<a id=\"benchmark-resolution-multiple\"></a>\n-## Specify multiples of clock resolution to run benchmarks for\n-<pre>--benchmark-resolution-multiple &lt;multiplier&gt;</pre>\n+<a id=\"benchmark-samples\"></a>\n+## Specify the number of benchmark samples to collect\n+<pre>--benchmark-samples &lt;# of samples&gt;</pre>\n \n-When running benchmarks the clock resolution is estimated. Benchmarks are then run for exponentially increasing\n-numbers of iterations until some multiple of the estimated resolution is exceed. By default that multiple is 100, but \n-it can be overridden here.\n+When running benchmarks a number of \"samples\" is collected. This is the base data for later statistical analysis.\n+Per sample a clock resolution dependent number of iterations of the user code is run, which is independent of the number of samples. Defaults to 100.\n+\n+<a id=\"benchmark-resamples\"></a>\n+## Specify the number of resamples for bootstrapping\n+<pre>--benchmark-resamples &lt;# of resamples&gt;</pre>\n+\n+After the measurements are performed, statistical [bootstrapping] is performed\n+on the samples. The number of resamples for that bootstrapping is configurable\n+but defaults to 100000. Due to the bootstrapping it is possible to give\n+estimates for the mean and standard deviation. The estimates come with a lower\n+bound and an upper bound, and the confidence interval (which is configurable but\n+defaults to 95%).\n+\n+ [bootstrapping]: http://en.wikipedia.org/wiki/Bootstrapping_%28statistics%29\n+\n+<a id=\"benchmark-confidence-interval\"></a>\n+## Specify the confidence-interval for bootstrapping\n+<pre>--benchmark-confidence-interval &lt;confidence-interval&gt;</pre>\n+\n+The confidence-interval is used for statistical bootstrapping on the samples to\n+calculate the upper and lower bounds of mean and standard deviation.\n+Must be between 0 and 1 and defaults to 0.95.\n+\n+<a id=\"benchmark-no-analysis\"></a>\n+## Disable statistical analysis of collected benchmark samples\n+<pre>--benchmark-no-analysis</pre>\n+\n+When this flag is specified no bootstrapping or any other statistical analysis is performed.\n+Instead the user code is only measured and the plain mean from the samples is reported.\n \n <a id=\"usage\"></a>\n ## Usage\ndiff --git a/docs/configuration.md b/docs/configuration.md\nindex c01d7f5e63..cfe4b9a0ff 100644\n--- a/docs/configuration.md\n+++ b/docs/configuration.md\n@@ -149,6 +149,7 @@ by using `_NO_` in the macro, e.g. `CATCH_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS`.\n     CATCH_CONFIG_DISABLE                    // Disables assertions and test case registration\n     CATCH_CONFIG_WCHAR                      // Enables use of wchart_t\n     CATCH_CONFIG_EXPERIMENTAL_REDIRECT      // Enables the new (experimental) way of capturing stdout/stderr\n+    CATCH_CONFIG_ENABLE_BENCHMARKING        // Enables the integrated benchmarking features (has a significant effect on compilation speed)\n \n Currently Catch enables `CATCH_CONFIG_WINDOWS_SEH` only when compiled with MSVC, because some versions of MinGW do not have the necessary Win32 API support.\n \ndiff --git a/include/catch.hpp b/include/catch.hpp\nindex 947957f57b..eebc470cae 100644\n--- a/include/catch.hpp\n+++ b/include/catch.hpp\n@@ -53,7 +53,6 @@\n #include \"internal/catch_test_registry.h\"\n #include \"internal/catch_capture.hpp\"\n #include \"internal/catch_section.h\"\n-#include \"internal/catch_benchmark.h\"\n #include \"internal/catch_interfaces_exception.h\"\n #include \"internal/catch_approx.h\"\n #include \"internal/catch_compiler_capabilities.h\"\n@@ -79,6 +78,10 @@\n #include \"internal/catch_external_interfaces.h\"\n #endif\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+#include \"internal/benchmark/catch_benchmark.hpp\"\n+#endif\n+\n #endif // ! CATCH_CONFIG_IMPL_ONLY\n \n #ifdef CATCH_IMPL\n@@ -89,6 +92,7 @@\n #include \"internal/catch_default_main.hpp\"\n #endif\n \n+\n #if !defined(CATCH_CONFIG_IMPL_ONLY)\n \n #ifdef CLARA_CONFIG_MAIN_NOT_DEFINED\n@@ -188,6 +192,13 @@\n #define CATCH_THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( \"     Then: \" << desc )\n #define CATCH_AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( \"      And: \" << desc )\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+#define CATCH_BENCHMARK(...) \\\n+    INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))\n+#define CATCH_BENCHMARK_ADVANCED(name) \\\n+    INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n+\n // If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required\n #else\n \n@@ -283,6 +294,13 @@\n #define THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( \"     Then: \" << desc )\n #define AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( \"      And: \" << desc )\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+#define BENCHMARK(...) \\\n+    INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))\n+#define BENCHMARK_ADVANCED(name) \\\n+    INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n+\n using Catch::Detail::Approx;\n \n #else // CATCH_CONFIG_DISABLE\ndiff --git a/include/internal/benchmark/catch_benchmark.hpp b/include/internal/benchmark/catch_benchmark.hpp\nnew file mode 100644\nindex 0000000000..3c06121079\n--- /dev/null\n+++ b/include/internal/benchmark/catch_benchmark.hpp\n@@ -0,0 +1,122 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+ // Benchmark\n+#ifndef TWOBLUECUBES_CATCH_BENCHMARK_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_BENCHMARK_HPP_INCLUDED\n+\n+#include \"../catch_config.hpp\"\n+#include \"../catch_context.h\"\n+#include \"../catch_interfaces_reporter.h\"\n+#include \"../catch_test_registry.h\"\n+\n+#include \"catch_chronometer.hpp\"\n+#include \"catch_clock.hpp\"\n+#include \"catch_environment.hpp\"\n+#include \"catch_execution_plan.hpp\"\n+#include \"detail/catch_estimate_clock.hpp\"\n+#include \"detail/catch_complete_invoke.hpp\"\n+#include \"detail/catch_analyse.hpp\"\n+#include \"detail/catch_benchmark_function.hpp\"\n+#include \"detail/catch_run_for_at_least.hpp\"\n+\n+#include <algorithm>\n+#include <functional>\n+#include <string>\n+#include <vector>\n+#include <cmath>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        struct Benchmark {\n+            Benchmark(std::string &&name)\n+                : name(std::move(name)) {}\n+\n+            template <class FUN>\n+            Benchmark(std::string &&name, FUN &&func)\n+                : fun(std::move(func)), name(std::move(name)) {}\n+\n+            template <typename Clock>\n+            ExecutionPlan<FloatDuration<Clock>> prepare(const IConfig &cfg, Environment<FloatDuration<Clock>> env) const {\n+                auto min_time = env.clock_resolution.mean * Detail::minimum_ticks;\n+                auto run_time = std::max(min_time, std::chrono::duration_cast<decltype(min_time)>(Detail::warmup_time));\n+                auto&& test = Detail::run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(run_time), 1, fun);\n+                int new_iters = static_cast<int>(std::ceil(min_time * test.iterations / test.elapsed));\n+                return { new_iters, test.elapsed / test.iterations * new_iters * cfg.benchmarkSamples(), fun, std::chrono::duration_cast<FloatDuration<Clock>>(Detail::warmup_time), Detail::warmup_iterations };\n+            }\n+\n+            template <typename Clock = default_clock>\n+            void run() {\n+                IConfigPtr cfg = getCurrentContext().getConfig();\n+\n+                auto env = Detail::measure_environment<Clock>();\n+\n+                getResultCapture().benchmarkPreparing(name);\n+                CATCH_TRY{\n+                    auto plan = user_code([&] {\n+                        return prepare<Clock>(*cfg, env);\n+                    });\n+\n+                    BenchmarkInfo info {\n+                        name,\n+                        plan.estimated_duration.count(),\n+                        plan.iterations_per_sample,\n+                        cfg->benchmarkSamples(),\n+                        cfg->benchmarkResamples(),\n+                        env.clock_resolution.mean.count(),\n+                        env.clock_cost.mean.count()\n+                    };\n+\n+                    getResultCapture().benchmarkStarting(info);\n+\n+                    auto samples = user_code([&] {\n+                        return plan.template run<Clock>(*cfg, env);\n+                    });\n+\n+                    auto analysis = Detail::analyse(*cfg, env, samples.begin(), samples.end());\n+                    BenchmarkStats<std::chrono::duration<double, std::nano>> stats{ info, analysis.samples, analysis.mean, analysis.standard_deviation, analysis.outliers, analysis.outlier_variance };\n+                    getResultCapture().benchmarkEnded(stats);\n+\n+                } CATCH_CATCH_ALL{\n+                    if (translateActiveException() != Detail::benchmarkErrorMsg) // benchmark errors have been reported, otherwise rethrow.\n+                        std::rethrow_exception(std::current_exception());\n+                }\n+            }\n+\n+            // sets lambda to be used in fun *and* executes benchmark!\n+            template <typename Fun,\n+                typename std::enable_if<!Detail::is_related<Fun, Benchmark>::value, int>::type = 0>\n+                Benchmark & operator=(Fun func) {\n+                fun = Detail::BenchmarkFunction(func);\n+                run();\n+                return *this;\n+            }\n+\n+            explicit operator bool() {\n+                return true;\n+            }\n+\n+        private:\n+            Detail::BenchmarkFunction fun;\n+            std::string name;\n+        };\n+    }\n+} // namespace Catch\n+\n+#define INTERNAL_CATCH_GET_1_ARG(arg1, arg2, ...) arg1\n+#define INTERNAL_CATCH_GET_2_ARG(arg1, arg2, ...) arg2\n+\n+#define INTERNAL_CATCH_BENCHMARK(BenchmarkName, name, benchmarkIndex)\\\n+    if( Catch::Benchmark::Benchmark BenchmarkName{name} ) \\\n+        BenchmarkName = [&](int benchmarkIndex)\n+\n+#define INTERNAL_CATCH_BENCHMARK_ADVANCED(BenchmarkName, name)\\\n+    if( Catch::Benchmark::Benchmark BenchmarkName{name} ) \\\n+        BenchmarkName = [&]\n+\n+#endif // TWOBLUECUBES_CATCH_BENCHMARK_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_chronometer.hpp b/include/internal/benchmark/catch_chronometer.hpp\nnew file mode 100644\nindex 0000000000..1022017d08\n--- /dev/null\n+++ b/include/internal/benchmark/catch_chronometer.hpp\n@@ -0,0 +1,71 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// User-facing chronometer\n+\n+#ifndef TWOBLUECUBES_CATCH_CHRONOMETER_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_CHRONOMETER_HPP_INCLUDED\n+\n+#include \"catch_clock.hpp\"\n+#include \"catch_optimizer.hpp\"\n+#include \"detail/catch_complete_invoke.hpp\"\n+#include \"../catch_meta.hpp\"\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            struct ChronometerConcept {\n+                virtual void start() = 0;\n+                virtual void finish() = 0;\n+                virtual ~ChronometerConcept() = default;\n+            };\n+            template <typename Clock>\n+            struct ChronometerModel final : public ChronometerConcept {\n+                void start() override { started = Clock::now(); }\n+                void finish() override { finished = Clock::now(); }\n+\n+                ClockDuration<Clock> elapsed() const { return finished - started; }\n+\n+                TimePoint<Clock> started;\n+                TimePoint<Clock> finished;\n+            };\n+        } // namespace Detail\n+\n+        struct Chronometer {\n+        public:\n+            template <typename Fun>\n+            void measure(Fun&& fun) { measure(std::forward<Fun>(fun), is_callable<Fun(int)>()); }\n+\n+            int runs() const { return k; }\n+\n+            Chronometer(Detail::ChronometerConcept& meter, int k)\n+                : impl(&meter)\n+                , k(k) {}\n+\n+        private:\n+            template <typename Fun>\n+            void measure(Fun&& fun, std::false_type) {\n+                measure([&fun](int) { return fun(); }, std::true_type());\n+            }\n+\n+            template <typename Fun>\n+            void measure(Fun&& fun, std::true_type) {\n+                Detail::optimizer_barrier();\n+                impl->start();\n+                for (int i = 0; i < k; ++i) invoke_deoptimized(fun, i);\n+                impl->finish();\n+                Detail::optimizer_barrier();\n+            }\n+\n+            Detail::ChronometerConcept* impl;\n+            int k;\n+        };\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_CHRONOMETER_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_clock.hpp b/include/internal/benchmark/catch_clock.hpp\nnew file mode 100644\nindex 0000000000..32a3e868b9\n--- /dev/null\n+++ b/include/internal/benchmark/catch_clock.hpp\n@@ -0,0 +1,40 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Clocks\n+\n+#ifndef TWOBLUECUBES_CATCH_CLOCK_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_CLOCK_HPP_INCLUDED\n+\n+#include <chrono>\n+#include <ratio>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        template <typename Clock>\n+        using ClockDuration = typename Clock::duration;\n+        template <typename Clock>\n+        using FloatDuration = std::chrono::duration<double, typename Clock::period>;\n+\n+        template <typename Clock>\n+        using TimePoint = typename Clock::time_point;\n+\n+        using default_clock = std::chrono::steady_clock;\n+\n+        template <typename Clock>\n+        struct now {\n+            TimePoint<Clock> operator()() const {\n+                return Clock::now();\n+            }\n+        };\n+\n+        using fp_seconds = std::chrono::duration<double, std::ratio<1>>;\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_CLOCK_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_constructor.hpp b/include/internal/benchmark/catch_constructor.hpp\nnew file mode 100644\nindex 0000000000..bf6dfec990\n--- /dev/null\n+++ b/include/internal/benchmark/catch_constructor.hpp\n@@ -0,0 +1,73 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Constructor and destructor helpers\n+\n+#ifndef TWOBLUECUBES_CATCH_CONSTRUCTOR_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_CONSTRUCTOR_HPP_INCLUDED\n+\n+#include <type_traits>\n+\n+namespace Catch {\n+    namespace Detail {\n+        template <typename T, bool Destruct>\n+        struct ObjectStorage\n+        {\n+            using TStorage = typename std::aligned_storage<sizeof(T), std::alignment_of<T>::value>::type;\n+\n+            ObjectStorage() : data() {}\n+\n+            ObjectStorage(const ObjectStorage& other)\n+            {\n+                new(&data) T(other.stored_object());\n+            }\n+\n+            ObjectStorage(ObjectStorage&& other)\n+            {\n+                new(&data) T(std::move(other.stored_object()));\n+            }\n+\n+            ~ObjectStorage() { destruct_on_exit<T>(); }\n+\n+            template <typename... Args>\n+            void construct(Args&&... args)\n+            {\n+                new (&data) T(std::forward<Args>(args)...);\n+            }\n+\n+            template <bool AllowManualDestruction = !Destruct>\n+            typename std::enable_if<AllowManualDestruction>::type destruct()\n+            {\n+                stored_object().~T();\n+            }\n+\n+        private:\n+            // If this is a constructor benchmark, destruct the underlying object\n+            template <typename U>\n+            void destruct_on_exit(typename std::enable_if<Destruct, U>::type* = 0) { destruct<true>(); }\n+            // Otherwise, don't\n+            template <typename U>\n+            void destruct_on_exit(typename std::enable_if<!Destruct, U>::type* = 0) { }\n+\n+            T& stored_object()\n+            {\n+                return *static_cast<T*>(static_cast<void*>(&data));\n+            }\n+\n+            TStorage data;\n+        };\n+    }\n+\n+    template <typename T>\n+    using storage_for = Detail::ObjectStorage<T, true>;\n+\n+    template <typename T>\n+    using destructable_object = Detail::ObjectStorage<T, false>;\n+}\n+\n+#endif // TWOBLUECUBES_CATCH_CONSTRUCTOR_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_environment.hpp b/include/internal/benchmark/catch_environment.hpp\nnew file mode 100644\nindex 0000000000..5595124987\n--- /dev/null\n+++ b/include/internal/benchmark/catch_environment.hpp\n@@ -0,0 +1,38 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Environment information\n+\n+#ifndef TWOBLUECUBES_CATCH_ENVIRONMENT_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_ENVIRONMENT_HPP_INCLUDED\n+\n+#include \"catch_clock.hpp\"\n+#include \"catch_outlier_classification.hpp\"\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        template <typename Duration>\n+        struct EnvironmentEstimate {\n+            Duration mean;\n+            OutlierClassification outliers;\n+\n+            template <typename Duration2>\n+            operator EnvironmentEstimate<Duration2>() const {\n+                return { mean, outliers };\n+            }\n+        };\n+        template <typename Clock>\n+        struct Environment {\n+            using clock_type = Clock;\n+            EnvironmentEstimate<FloatDuration<Clock>> clock_resolution;\n+            EnvironmentEstimate<FloatDuration<Clock>> clock_cost;\n+        };\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_ENVIRONMENT_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_estimate.hpp b/include/internal/benchmark/catch_estimate.hpp\nnew file mode 100644\nindex 0000000000..a3c913ce69\n--- /dev/null\n+++ b/include/internal/benchmark/catch_estimate.hpp\n@@ -0,0 +1,31 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+ // Statistics estimates\n+\n+#ifndef TWOBLUECUBES_CATCH_ESTIMATE_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_ESTIMATE_HPP_INCLUDED\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        template <typename Duration>\n+        struct Estimate {\n+            Duration point;\n+            Duration lower_bound;\n+            Duration upper_bound;\n+            double confidence_interval;\n+\n+            template <typename Duration2>\n+            operator Estimate<Duration2>() const {\n+                return { point, lower_bound, upper_bound, confidence_interval };\n+            }\n+        };\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_ESTIMATE_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_execution_plan.hpp b/include/internal/benchmark/catch_execution_plan.hpp\nnew file mode 100644\nindex 0000000000..e56c83aa7c\n--- /dev/null\n+++ b/include/internal/benchmark/catch_execution_plan.hpp\n@@ -0,0 +1,58 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+ // Execution plan\n+\n+#ifndef TWOBLUECUBES_CATCH_EXECUTION_PLAN_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_EXECUTION_PLAN_HPP_INCLUDED\n+\n+#include \"../catch_config.hpp\"\n+#include \"catch_clock.hpp\"\n+#include \"catch_environment.hpp\"\n+#include \"detail/catch_benchmark_function.hpp\"\n+#include \"detail/catch_repeat.hpp\"\n+#include \"detail/catch_run_for_at_least.hpp\"\n+\n+#include <algorithm>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        template <typename Duration>\n+        struct ExecutionPlan {\n+            int iterations_per_sample;\n+            Duration estimated_duration;\n+            Detail::BenchmarkFunction benchmark;\n+            Duration warmup_time;\n+            int warmup_iterations;\n+\n+            template <typename Duration2>\n+            operator ExecutionPlan<Duration2>() const {\n+                return { iterations_per_sample, estimated_duration, benchmark, warmup_time, warmup_iterations };\n+            }\n+\n+            template <typename Clock>\n+            std::vector<FloatDuration<Clock>> run(const IConfig &cfg, Environment<FloatDuration<Clock>> env) const {\n+                // warmup a bit\n+                Detail::run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(warmup_time), warmup_iterations, Detail::repeat(now<Clock>{}));\n+\n+                std::vector<FloatDuration<Clock>> times;\n+                times.reserve(cfg.benchmarkSamples());\n+                std::generate_n(std::back_inserter(times), cfg.benchmarkSamples(), [this, env] {\n+                    Detail::ChronometerModel<Clock> model;\n+                    this->benchmark(Chronometer(model, iterations_per_sample));\n+                    auto sample_time = model.elapsed() - env.clock_cost.mean;\n+                    if (sample_time < FloatDuration<Clock>::zero()) sample_time = FloatDuration<Clock>::zero();\n+                    return sample_time / iterations_per_sample;\n+                });\n+                return times;\n+            }\n+        };\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_EXECUTION_PLAN_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_optimizer.hpp b/include/internal/benchmark/catch_optimizer.hpp\nnew file mode 100644\nindex 0000000000..bda7c6d7e9\n--- /dev/null\n+++ b/include/internal/benchmark/catch_optimizer.hpp\n@@ -0,0 +1,68 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+ // Hinting the optimizer\n+\n+#ifndef TWOBLUECUBES_CATCH_OPTIMIZER_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_OPTIMIZER_HPP_INCLUDED\n+\n+#if defined(_MSC_VER)\n+#   include <atomic> // atomic_thread_fence\n+#endif\n+\n+namespace Catch {\n+    namespace Benchmark {\n+#if defined(__GNUC__) || defined(__clang__)\n+        template <typename T>\n+        inline void keep_memory(T* p) {\n+            asm volatile(\"\" : : \"g\"(p) : \"memory\");\n+        }\n+        inline void keep_memory() {\n+            asm volatile(\"\" : : : \"memory\");\n+        }\n+\n+        namespace Detail {\n+            inline void optimizer_barrier() { keep_memory(); }\n+        } // namespace Detail\n+#elif defined(_MSC_VER)\n+\n+#pragma optimize(\"\", off)\n+        template <typename T>\n+        inline void keep_memory(T* p) {\n+            // thanks @milleniumbug\n+            *reinterpret_cast<char volatile*>(p) = *reinterpret_cast<char const volatile*>(p);\n+        }\n+        // TODO equivalent keep_memory()\n+#pragma optimize(\"\", on)\n+\n+        namespace Detail {\n+            inline void optimizer_barrier() {\n+                std::atomic_thread_fence(std::memory_order_seq_cst);\n+            }\n+        } // namespace Detail\n+\n+#endif\n+\n+        template <typename T>\n+        inline void deoptimize_value(T&& x) {\n+            keep_memory(&x);\n+        }\n+\n+        template <typename Fn, typename... Args>\n+        inline auto invoke_deoptimized(Fn&& fn, Args&&... args) -> typename std::enable_if<!std::is_same<void, decltype(fn(args...))>::value>::type {\n+            deoptimize_value(std::forward<Fn>(fn) (std::forward<Args...>(args...)));\n+        }\n+\n+        template <typename Fn, typename... Args>\n+        inline auto invoke_deoptimized(Fn&& fn, Args&&... args) -> typename std::enable_if<std::is_same<void, decltype(fn(args...))>::value>::type {\n+            std::forward<Fn>(fn) (std::forward<Args...>(args...));\n+        }\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_OPTIMIZER_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_outlier_classification.hpp b/include/internal/benchmark/catch_outlier_classification.hpp\nnew file mode 100644\nindex 0000000000..66a0adf579\n--- /dev/null\n+++ b/include/internal/benchmark/catch_outlier_classification.hpp\n@@ -0,0 +1,29 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Outlier information\n+#ifndef TWOBLUECUBES_CATCH_OUTLIERS_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_OUTLIERS_HPP_INCLUDED\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        struct OutlierClassification {\n+            int samples_seen = 0;\n+            int low_severe = 0;     // more than 3 times IQR below Q1\n+            int low_mild = 0;       // 1.5 to 3 times IQR below Q1\n+            int high_mild = 0;      // 1.5 to 3 times IQR above Q3\n+            int high_severe = 0;    // more than 3 times IQR above Q3\n+\n+            int total() const {\n+                return low_severe + low_mild + high_mild + high_severe;\n+            }\n+        };\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_OUTLIERS_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_sample_analysis.hpp b/include/internal/benchmark/catch_sample_analysis.hpp\nnew file mode 100644\nindex 0000000000..4550d0bc4e\n--- /dev/null\n+++ b/include/internal/benchmark/catch_sample_analysis.hpp\n@@ -0,0 +1,50 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Benchmark results\n+\n+#ifndef TWOBLUECUBES_CATCH_BENCHMARK_RESULTS_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_BENCHMARK_RESULTS_HPP_INCLUDED\n+\n+#include \"catch_clock.hpp\"\n+#include \"catch_estimate.hpp\"\n+#include \"catch_outlier_classification.hpp\"\n+\n+#include <algorithm>\n+#include <vector>\n+#include <string>\n+#include <iterator>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        template <typename Duration>\n+        struct SampleAnalysis {\n+            std::vector<Duration> samples;\n+            Estimate<Duration> mean;\n+            Estimate<Duration> standard_deviation;\n+            OutlierClassification outliers;\n+            double outlier_variance;\n+\n+            template <typename Duration2>\n+            operator SampleAnalysis<Duration2>() const {\n+                std::vector<Duration2> samples2;\n+                samples2.reserve(samples.size());\n+                std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](Duration d) { return Duration2(d); });\n+                return {\n+                    std::move(samples2),\n+                    mean,\n+                    standard_deviation,\n+                    outliers,\n+                    outlier_variance,\n+                };\n+            }\n+        };\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_BENCHMARK_RESULTS_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_analyse.hpp b/include/internal/benchmark/detail/catch_analyse.hpp\nnew file mode 100644\nindex 0000000000..a3becbe4d8\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_analyse.hpp\n@@ -0,0 +1,78 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+ // Run and analyse one benchmark\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_ANALYSE_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_ANALYSE_HPP_INCLUDED\n+\n+#include \"../catch_clock.hpp\"\n+#include \"../catch_sample_analysis.hpp\"\n+#include \"catch_stats.hpp\"\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <vector>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            template <typename Duration, typename Iterator>\n+            SampleAnalysis<Duration> analyse(const IConfig &cfg, Environment<Duration>, Iterator first, Iterator last) {\n+                if (!cfg.benchmarkNoAnalysis()) {\n+                    std::vector<double> samples;\n+                    samples.reserve(last - first);\n+                    std::transform(first, last, std::back_inserter(samples), [](Duration d) { return d.count(); });\n+\n+                    auto analysis = Catch::Benchmark::Detail::analyse_samples(cfg.benchmarkConfidenceInterval(), cfg.benchmarkResamples(), samples.begin(), samples.end());\n+                    auto outliers = Catch::Benchmark::Detail::classify_outliers(samples.begin(), samples.end());\n+\n+                    auto wrap_estimate = [](Estimate<double> e) {\n+                        return Estimate<Duration> {\n+                            Duration(e.point),\n+                                Duration(e.lower_bound),\n+                                Duration(e.upper_bound),\n+                                e.confidence_interval,\n+                        };\n+                    };\n+                    std::vector<Duration> samples2;\n+                    samples2.reserve(samples.size());\n+                    std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](double d) { return Duration(d); });\n+                    return {\n+                        std::move(samples2),\n+                        wrap_estimate(analysis.mean),\n+                        wrap_estimate(analysis.standard_deviation),\n+                        outliers,\n+                        analysis.outlier_variance,\n+                    };\n+                } else {\n+                    std::vector<Duration> samples; \n+                    samples.reserve(last - first);\n+\n+                    Duration mean = Duration(0);\n+                    int i = 0;\n+                    for (auto it = first; it < last; ++it, ++i) {\n+                        samples.push_back(Duration(*it));\n+                        mean += Duration(*it);\n+                    }\n+                    mean /= i;\n+\n+                    return {\n+                        std::move(samples),\n+                        Estimate<Duration>{mean, mean, mean, 0.0},\n+                        Estimate<Duration>{Duration(0), Duration(0), Duration(0), 0.0},\n+                        OutlierClassification{},\n+                        0.0\n+                    };\n+                }\n+            }\n+        } // namespace Detail\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_ANALYSE_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_benchmark_function.hpp b/include/internal/benchmark/detail/catch_benchmark_function.hpp\nnew file mode 100644\nindex 0000000000..60c7f1d692\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_benchmark_function.hpp\n@@ -0,0 +1,105 @@\n+    /*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+ // Dumb std::function implementation for consistent call overhead\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_BENCHMARK_FUNCTION_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_BENCHMARK_FUNCTION_HPP_INCLUDED\n+\n+#include \"../catch_chronometer.hpp\"\n+#include \"catch_complete_invoke.hpp\"\n+#include \"../../catch_meta.hpp\"\n+\n+#include <cassert>\n+#include <type_traits>\n+#include <utility>\n+#include <memory>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            template <typename T>\n+            using Decay = typename std::decay<T>::type;\n+            template <typename T, typename U>\n+            struct is_related\n+                : std::is_same<Decay<T>, Decay<U>> {};\n+\n+            /// We need to reinvent std::function because every piece of code that might add overhead\n+            /// in a measurement context needs to have consistent performance characteristics so that we\n+            /// can account for it in the measurement.\n+            /// Implementations of std::function with optimizations that aren't always applicable, like\n+            /// small buffer optimizations, are not uncommon.\n+            /// This is effectively an implementation of std::function without any such optimizations;\n+            /// it may be slow, but it is consistently slow.\n+            struct BenchmarkFunction {\n+            private:\n+                struct callable {\n+                    virtual void call(Chronometer meter) const = 0;\n+                    virtual callable* clone() const = 0;\n+                    virtual ~callable() = default;\n+                };\n+                template <typename Fun>\n+                struct model : public callable {\n+                    model(Fun&& fun) : fun(std::move(fun)) {}\n+                    model(Fun const& fun) : fun(fun) {}\n+\n+                    model<Fun>* clone() const override { return new model<Fun>(*this); }\n+\n+                    void call(Chronometer meter) const override {\n+                        call(meter, is_callable<Fun(Chronometer)>());\n+                    }\n+                    void call(Chronometer meter, std::true_type) const {\n+                        fun(meter);\n+                    }\n+                    void call(Chronometer meter, std::false_type) const {\n+                        meter.measure(fun);\n+                    }\n+\n+                    Fun fun;\n+                };\n+\n+                struct do_nothing { void operator()() const {} };\n+\n+                template <typename T>\n+                BenchmarkFunction(model<T>* c) : f(c) {}\n+\n+            public:\n+                BenchmarkFunction()\n+                    : f(new model<do_nothing>{ {} }) {}\n+\n+                template <typename Fun,\n+                    typename std::enable_if<!is_related<Fun, BenchmarkFunction>::value, int>::type = 0>\n+                    BenchmarkFunction(Fun&& fun)\n+                    : f(new model<typename std::decay<Fun>::type>(std::forward<Fun>(fun))) {}\n+\n+                BenchmarkFunction(BenchmarkFunction&& that)\n+                    : f(std::move(that.f)) {}\n+\n+                BenchmarkFunction(BenchmarkFunction const& that)\n+                    : f(that.f->clone()) {}\n+\n+                BenchmarkFunction& operator=(BenchmarkFunction&& that) {\n+                    f = std::move(that.f);\n+                    return *this;\n+                }\n+\n+                BenchmarkFunction& operator=(BenchmarkFunction const& that) {\n+                    f.reset(that.f->clone());\n+                    return *this;\n+                }\n+\n+                void operator()(Chronometer meter) const { f->call(meter); }\n+\n+            private:\n+                std::unique_ptr<callable> f;\n+            };\n+        } // namespace Detail\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_BENCHMARK_FUNCTION_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_complete_invoke.hpp b/include/internal/benchmark/detail/catch_complete_invoke.hpp\nnew file mode 100644\nindex 0000000000..abeb2ac71d\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_complete_invoke.hpp\n@@ -0,0 +1,69 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Invoke with a special case for void\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_COMPLETE_INVOKE_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_COMPLETE_INVOKE_HPP_INCLUDED\n+\n+#include \"../../catch_enforce.h\"\n+\n+#include <type_traits>\n+#include <utility>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            template <typename T>\n+            struct CompleteType { using type = T; };\n+            template <>\n+            struct CompleteType<void> { struct type {}; };\n+\n+            template <typename T>\n+            using CompleteType_t = typename CompleteType<T>::type;\n+\n+            template <typename Result>\n+            struct CompleteInvoker {\n+                template <typename Fun, typename... Args>\n+                static Result invoke(Fun&& fun, Args&&... args) {\n+                    return std::forward<Fun>(fun)(std::forward<Args>(args)...);\n+                }\n+            };\n+            template <>\n+            struct CompleteInvoker<void> {\n+                template <typename Fun, typename... Args>\n+                static CompleteType_t<void> invoke(Fun&& fun, Args&&... args) {\n+                    std::forward<Fun>(fun)(std::forward<Args>(args)...);\n+                    return {};\n+                }\n+            };\n+            template <typename Sig>\n+            using ResultOf_t = typename std::result_of<Sig>::type;\n+\n+            // invoke and not return void :(\n+            template <typename Fun, typename... Args>\n+            CompleteType_t<ResultOf_t<Fun(Args...)>> complete_invoke(Fun&& fun, Args&&... args) {\n+                return CompleteInvoker<ResultOf_t<Fun(Args...)>>::invoke(std::forward<Fun>(fun), std::forward<Args>(args)...);\n+            }\n+\n+            const std::string benchmarkErrorMsg = \"a benchmark failed to run successfully\";\n+        } // namespace Detail\n+\n+        template <typename Fun>\n+        Detail::CompleteType_t<Detail::ResultOf_t<Fun()>> user_code(Fun&& fun) {\n+            CATCH_TRY{\n+                return Detail::complete_invoke(std::forward<Fun>(fun));\n+            } CATCH_CATCH_ALL{\n+                getResultCapture().benchmarkFailed(translateActiveException());\n+                CATCH_RUNTIME_ERROR(Detail::benchmarkErrorMsg);\n+            }\n+        }\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_COMPLETE_INVOKE_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_estimate_clock.hpp b/include/internal/benchmark/detail/catch_estimate_clock.hpp\nnew file mode 100644\nindex 0000000000..055c582500\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_estimate_clock.hpp\n@@ -0,0 +1,113 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+ // Environment measurement\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_ESTIMATE_CLOCK_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_ESTIMATE_CLOCK_HPP_INCLUDED\n+\n+#include \"../catch_clock.hpp\"\n+#include \"../catch_environment.hpp\"\n+#include \"catch_stats.hpp\"\n+#include \"catch_measure.hpp\"\n+#include \"catch_run_for_at_least.hpp\"\n+#include \"../catch_clock.hpp\"\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <tuple>\n+#include <vector>\n+#include <cmath>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            template <typename Clock>\n+            std::vector<double> resolution(int k) {\n+                std::vector<TimePoint<Clock>> times;\n+                times.reserve(k + 1);\n+                std::generate_n(std::back_inserter(times), k + 1, now<Clock>{});\n+\n+                std::vector<double> deltas;\n+                deltas.reserve(k);\n+                std::transform(std::next(times.begin()), times.end(), times.begin(),\n+                    std::back_inserter(deltas),\n+                    [](TimePoint<Clock> a, TimePoint<Clock> b) { return static_cast<double>((a - b).count()); });\n+\n+                return deltas;\n+            }\n+\n+            const auto warmup_iterations = 10000;\n+            const auto warmup_time = std::chrono::milliseconds(100);\n+            const auto minimum_ticks = 1000;\n+            const auto warmup_seed = 10000;\n+            const auto clock_resolution_estimation_time = std::chrono::milliseconds(500);\n+            const auto clock_cost_estimation_time_limit = std::chrono::seconds(1);\n+            const auto clock_cost_estimation_tick_limit = 100000;\n+            const auto clock_cost_estimation_time = std::chrono::milliseconds(10);\n+            const auto clock_cost_estimation_iterations = 10000;\n+\n+            template <typename Clock>\n+            int warmup() {\n+                return run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(warmup_time), warmup_seed, &resolution<Clock>)\n+                    .iterations;\n+            }\n+            template <typename Clock>\n+            EnvironmentEstimate<FloatDuration<Clock>> estimate_clock_resolution(int iterations) {\n+                auto r = run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(clock_resolution_estimation_time), iterations, &resolution<Clock>)\n+                    .result;\n+                return {\n+                    FloatDuration<Clock>(mean(r.begin(), r.end())),\n+                    classify_outliers(r.begin(), r.end()),\n+                };\n+            }\n+            template <typename Clock>\n+            EnvironmentEstimate<FloatDuration<Clock>> estimate_clock_cost(FloatDuration<Clock> resolution) {\n+                auto time_limit = std::min(resolution * clock_cost_estimation_tick_limit, FloatDuration<Clock>(clock_cost_estimation_time_limit));\n+                auto time_clock = [](int k) {\n+                    return Detail::measure<Clock>([k] {\n+                        for (int i = 0; i < k; ++i) {\n+                            volatile auto ignored = Clock::now();\n+                            (void)ignored;\n+                        }\n+                    }).elapsed;\n+                };\n+                time_clock(1);\n+                int iters = clock_cost_estimation_iterations;\n+                auto&& r = run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(clock_cost_estimation_time), iters, time_clock);\n+                std::vector<double> times;\n+                int nsamples = static_cast<int>(std::ceil(time_limit / r.elapsed));\n+                times.reserve(nsamples);\n+                std::generate_n(std::back_inserter(times), nsamples, [time_clock, &r] {\n+                    return static_cast<double>((time_clock(r.iterations) / r.iterations).count());\n+                });\n+                return {\n+                    FloatDuration<Clock>(mean(times.begin(), times.end())),\n+                    classify_outliers(times.begin(), times.end()),\n+                };\n+            }\n+\n+            template <typename Clock>\n+            Environment<FloatDuration<Clock>> measure_environment() {\n+                static Environment<FloatDuration<Clock>>* env = nullptr;\n+                if (env) {\n+                    return *env;\n+                }\n+\n+                auto iters = Detail::warmup<Clock>();\n+                auto resolution = Detail::estimate_clock_resolution<Clock>(iters);\n+                auto cost = Detail::estimate_clock_cost<Clock>(resolution.mean);\n+\n+                env = new Environment<FloatDuration<Clock>>{ resolution, cost };\n+                return *env;\n+            }\n+        } // namespace Detail\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_ESTIMATE_CLOCK_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_measure.hpp b/include/internal/benchmark/detail/catch_measure.hpp\nnew file mode 100644\nindex 0000000000..62ed280963\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_measure.hpp\n@@ -0,0 +1,35 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Measure\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_MEASURE_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_MEASURE_HPP_INCLUDED\n+\n+#include \"../catch_clock.hpp\"\n+#include \"catch_complete_invoke.hpp\"\n+#include \"catch_timing.hpp\"\n+\n+#include <utility>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            template <typename Clock, typename Fun, typename... Args>\n+            TimingOf<Clock, Fun(Args...)> measure(Fun&& fun, Args&&... args) {\n+                auto start = Clock::now();\n+                auto&& r = Detail::complete_invoke(fun, std::forward<Args>(args)...);\n+                auto end = Clock::now();\n+                auto delta = end - start;\n+                return { delta, std::forward<decltype(r)>(r), 1 };\n+            }\n+        } // namespace Detail\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_MEASURE_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_repeat.hpp b/include/internal/benchmark/detail/catch_repeat.hpp\nnew file mode 100644\nindex 0000000000..ab240792b7\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_repeat.hpp\n@@ -0,0 +1,37 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// repeat algorithm\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_REPEAT_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_REPEAT_HPP_INCLUDED\n+\n+#include <type_traits>\n+#include <utility>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            template <typename Fun>\n+            struct repeater {\n+                void operator()(int k) const {\n+                    for (int i = 0; i < k; ++i) {\n+                        fun();\n+                    }\n+                }\n+                Fun fun;\n+            };\n+            template <typename Fun>\n+            repeater<typename std::decay<Fun>::type> repeat(Fun&& fun) {\n+                return { std::forward<Fun>(fun) };\n+            }\n+        } // namespace Detail\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_REPEAT_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_run_for_at_least.hpp b/include/internal/benchmark/detail/catch_run_for_at_least.hpp\nnew file mode 100644\nindex 0000000000..a41c6b4611\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_run_for_at_least.hpp\n@@ -0,0 +1,65 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Run a function for a minimum amount of time\n+\n+#ifndef TWOBLUECUBES_CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED\n+\n+#include \"../catch_clock.hpp\"\n+#include \"../catch_chronometer.hpp\"\n+#include \"catch_measure.hpp\"\n+#include \"catch_complete_invoke.hpp\"\n+#include \"catch_timing.hpp\"\n+#include \"../../catch_meta.hpp\"\n+\n+#include <utility>\n+#include <type_traits>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            template <typename Clock, typename Fun>\n+            TimingOf<Clock, Fun(int)> measure_one(Fun&& fun, int iters, std::false_type) {\n+                return Detail::measure<Clock>(fun, iters);\n+            }\n+            template <typename Clock, typename Fun>\n+            TimingOf<Clock, Fun(Chronometer)> measure_one(Fun&& fun, int iters, std::true_type) {\n+                Detail::ChronometerModel<Clock> meter;\n+                auto&& result = Detail::complete_invoke(fun, Chronometer(meter, iters));\n+\n+                return { meter.elapsed(), std::move(result), iters };\n+            }\n+\n+            template <typename Clock, typename Fun>\n+            using run_for_at_least_argument_t = typename std::conditional<is_callable<Fun(Chronometer)>::value, Chronometer, int>::type;\n+\n+            struct optimized_away_error : std::exception {\n+                const char* what() const noexcept override {\n+                    return \"could not measure benchmark, maybe it was optimized away\";\n+                }\n+            };\n+\n+            template <typename Clock, typename Fun>\n+            TimingOf<Clock, Fun(run_for_at_least_argument_t<Clock, Fun>)> run_for_at_least(ClockDuration<Clock> how_long, int seed, Fun&& fun) {\n+                auto iters = seed;\n+                while (iters < (1 << 30)) {\n+                    auto&& Timing = measure_one<Clock>(fun, iters, is_callable<Fun(Chronometer)>());\n+\n+                    if (Timing.elapsed >= how_long) {\n+                        return { Timing.elapsed, std::move(Timing.result), iters };\n+                    }\n+                    iters *= 2;\n+                }\n+                throw optimized_away_error{};\n+            }\n+        } // namespace Detail\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_stats.hpp b/include/internal/benchmark/detail/catch_stats.hpp\nnew file mode 100644\nindex 0000000000..25fb964012\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_stats.hpp\n@@ -0,0 +1,342 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Statistical analysis tools\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_ANALYSIS_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_ANALYSIS_HPP_INCLUDED\n+\n+#include \"../catch_clock.hpp\"\n+#include \"../catch_estimate.hpp\"\n+#include \"../catch_outlier_classification.hpp\"\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <functional>\n+#include <iterator>\n+#include <vector>\n+#include <array>\n+#include <random>\n+#include <numeric>\n+#include <tuple>\n+#include <cmath>\n+#include <utility>\n+#include <cstddef>\n+\n+#ifdef CATCH_USE_ASYNC\n+#include <future>\n+#endif\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            using sample = std::vector<double>;\n+\n+            template <typename Iterator>\n+            double weighted_average_quantile(int k, int q, Iterator first, Iterator last) {\n+                auto count = last - first;\n+                double idx = (count - 1) * k / static_cast<double>(q);\n+                int j = static_cast<int>(idx);\n+                double g = idx - j;\n+                std::nth_element(first, first + j, last);\n+                auto xj = first[j];\n+                if (g == 0) return xj;\n+\n+                auto xj1 = *std::min_element(first + (j + 1), last);\n+                return xj + g * (xj1 - xj);\n+            }\n+\n+            template <typename Iterator>\n+            OutlierClassification classify_outliers(Iterator first, Iterator last) {\n+                std::vector<double> copy(first, last);\n+\n+                auto q1 = weighted_average_quantile(1, 4, copy.begin(), copy.end());\n+                auto q3 = weighted_average_quantile(3, 4, copy.begin(), copy.end());\n+                auto iqr = q3 - q1;\n+                auto los = q1 - (iqr * 3.);\n+                auto lom = q1 - (iqr * 1.5);\n+                auto him = q3 + (iqr * 1.5);\n+                auto his = q3 + (iqr * 3.);\n+\n+                OutlierClassification o;\n+                for (; first != last; ++first) {\n+                    auto&& t = *first;\n+                    if (t < los) ++o.low_severe;\n+                    else if (t < lom) ++o.low_mild;\n+                    else if (t > his) ++o.high_severe;\n+                    else if (t > him) ++o.high_mild;\n+                    ++o.samples_seen;\n+                }\n+                return o;\n+            }\n+\n+            template <typename Iterator>\n+            double mean(Iterator first, Iterator last) {\n+                auto count = last - first;\n+                double sum = std::accumulate(first, last, 0.);\n+                return sum / count;\n+            }\n+\n+            template <typename Iterator>\n+            double standard_deviation(Iterator first, Iterator last) {\n+                auto m = mean(first, last);\n+                double variance = std::accumulate(first, last, 0., [m](double a, double b) {\n+                    double diff = b - m;\n+                    return a + diff * diff;\n+                }) / (last - first);\n+                return std::sqrt(variance);\n+            }\n+\n+            template <typename URng, typename Iterator, typename Estimator>\n+            sample resample(URng& rng, int resamples, Iterator first, Iterator last, Estimator& estimator) {\n+                auto n = last - first;\n+                std::uniform_int_distribution<decltype(n)> dist(0, n - 1);\n+\n+                sample out;\n+                out.reserve(resamples);\n+                std::generate_n(std::back_inserter(out), resamples, [n, first, &estimator, &dist, &rng] {\n+                    std::vector<double> resampled;\n+                    resampled.reserve(n);\n+                    std::generate_n(std::back_inserter(resampled), n, [first, &dist, &rng] { return first[dist(rng)]; });\n+                    return estimator(resampled.begin(), resampled.end());\n+                });\n+                std::sort(out.begin(), out.end());\n+                return out;\n+            }\n+\n+            template <typename Estimator, typename Iterator>\n+            sample jackknife(Estimator&& estimator, Iterator first, Iterator last) {\n+                auto n = last - first;\n+                auto second = std::next(first);\n+                sample results;\n+                results.reserve(n);\n+\n+                for (auto it = first; it != last; ++it) {\n+                    std::iter_swap(it, first);\n+                    results.push_back(estimator(second, last));\n+                }\n+\n+                return results;\n+            }\n+\n+            inline double normal_cdf(double x) {\n+                return std::erfc(-x / std::sqrt(2.0)) / 2.0;\n+            }\n+\n+            inline double erf_inv(double x) {\n+                // Code accompanying the article \"Approximating the erfinv function\" in GPU Computing Gems, Volume 2\n+                double w, p;\n+\n+                w = -log((1.0 - x)*(1.0 + x));\n+\n+                if (w < 6.250000) {\n+                    w = w - 3.125000;\n+                    p = -3.6444120640178196996e-21;\n+                    p = -1.685059138182016589e-19 + p * w;\n+                    p = 1.2858480715256400167e-18 + p * w;\n+                    p = 1.115787767802518096e-17 + p * w;\n+                    p = -1.333171662854620906e-16 + p * w;\n+                    p = 2.0972767875968561637e-17 + p * w;\n+                    p = 6.6376381343583238325e-15 + p * w;\n+                    p = -4.0545662729752068639e-14 + p * w;\n+                    p = -8.1519341976054721522e-14 + p * w;\n+                    p = 2.6335093153082322977e-12 + p * w;\n+                    p = -1.2975133253453532498e-11 + p * w;\n+                    p = -5.4154120542946279317e-11 + p * w;\n+                    p = 1.051212273321532285e-09 + p * w;\n+                    p = -4.1126339803469836976e-09 + p * w;\n+                    p = -2.9070369957882005086e-08 + p * w;\n+                    p = 4.2347877827932403518e-07 + p * w;\n+                    p = -1.3654692000834678645e-06 + p * w;\n+                    p = -1.3882523362786468719e-05 + p * w;\n+                    p = 0.0001867342080340571352 + p * w;\n+                    p = -0.00074070253416626697512 + p * w;\n+                    p = -0.0060336708714301490533 + p * w;\n+                    p = 0.24015818242558961693 + p * w;\n+                    p = 1.6536545626831027356 + p * w;\n+                } else if (w < 16.000000) {\n+                    w = sqrt(w) - 3.250000;\n+                    p = 2.2137376921775787049e-09;\n+                    p = 9.0756561938885390979e-08 + p * w;\n+                    p = -2.7517406297064545428e-07 + p * w;\n+                    p = 1.8239629214389227755e-08 + p * w;\n+                    p = 1.5027403968909827627e-06 + p * w;\n+                    p = -4.013867526981545969e-06 + p * w;\n+                    p = 2.9234449089955446044e-06 + p * w;\n+                    p = 1.2475304481671778723e-05 + p * w;\n+                    p = -4.7318229009055733981e-05 + p * w;\n+                    p = 6.8284851459573175448e-05 + p * w;\n+                    p = 2.4031110387097893999e-05 + p * w;\n+                    p = -0.0003550375203628474796 + p * w;\n+                    p = 0.00095328937973738049703 + p * w;\n+                    p = -0.0016882755560235047313 + p * w;\n+                    p = 0.0024914420961078508066 + p * w;\n+                    p = -0.0037512085075692412107 + p * w;\n+                    p = 0.005370914553590063617 + p * w;\n+                    p = 1.0052589676941592334 + p * w;\n+                    p = 3.0838856104922207635 + p * w;\n+                } else {\n+                    w = sqrt(w) - 5.000000;\n+                    p = -2.7109920616438573243e-11;\n+                    p = -2.5556418169965252055e-10 + p * w;\n+                    p = 1.5076572693500548083e-09 + p * w;\n+                    p = -3.7894654401267369937e-09 + p * w;\n+                    p = 7.6157012080783393804e-09 + p * w;\n+                    p = -1.4960026627149240478e-08 + p * w;\n+                    p = 2.9147953450901080826e-08 + p * w;\n+                    p = -6.7711997758452339498e-08 + p * w;\n+                    p = 2.2900482228026654717e-07 + p * w;\n+                    p = -9.9298272942317002539e-07 + p * w;\n+                    p = 4.5260625972231537039e-06 + p * w;\n+                    p = -1.9681778105531670567e-05 + p * w;\n+                    p = 7.5995277030017761139e-05 + p * w;\n+                    p = -0.00021503011930044477347 + p * w;\n+                    p = -0.00013871931833623122026 + p * w;\n+                    p = 1.0103004648645343977 + p * w;\n+                    p = 4.8499064014085844221 + p * w;\n+                }\n+                return p * x;\n+            }\n+\n+            inline double erfc_inv(double x) {\n+                return erf_inv(1.0 - x);\n+            }\n+\n+            inline double normal_quantile(double p) {\n+                static const double ROOT_TWO = std::sqrt(2.0);\n+\n+                double result = 0.0;\n+                assert(p >= 0 && p <= 1);\n+                if (p < 0 || p > 1) {\n+                    return result;\n+                }\n+\n+                result = -erfc_inv(2.0 * p);\n+                // result *= normal distribution standard deviation (1.0) * sqrt(2)\n+                result *= /*sd * */ ROOT_TWO;\n+                // result += normal disttribution mean (0)\n+                return result;\n+            }\n+\n+            template <typename Iterator, typename Estimator>\n+            Estimate<double> bootstrap(double confidence_level, Iterator first, Iterator last, sample const& resample, Estimator&& estimator) {\n+                auto n_samples = last - first;\n+\n+                double point = estimator(first, last);\n+                // Degenerate case with a single sample\n+                if (n_samples == 1) return { point, point, point, confidence_level };\n+\n+                sample jack = jackknife(estimator, first, last);\n+                double jack_mean = mean(jack.begin(), jack.end());\n+                double sum_squares, sum_cubes;\n+                std::tie(sum_squares, sum_cubes) = std::accumulate(jack.begin(), jack.end(), std::make_pair(0., 0.), [jack_mean](std::pair<double, double> sqcb, double x) -> std::pair<double, double> {\n+                    auto d = jack_mean - x;\n+                    auto d2 = d * d;\n+                    auto d3 = d2 * d;\n+                    return { sqcb.first + d2, sqcb.second + d3 };\n+                });\n+\n+                double accel = sum_cubes / (6 * std::pow(sum_squares, 1.5));\n+                int n = static_cast<int>(resample.size());\n+                double prob_n = std::count_if(resample.begin(), resample.end(), [point](double x) { return x < point; }) / (double)n;\n+                // degenerate case with uniform samples\n+                if (prob_n == 0) return { point, point, point, confidence_level };\n+\n+                double bias = normal_quantile(prob_n);\n+                double z1 = normal_quantile((1. - confidence_level) / 2.);\n+\n+                auto cumn = [n](double x) -> int {\n+                    return std::lround(normal_cdf(x) * n); };\n+                auto a = [bias, accel](double b) { return bias + b / (1. - accel * b); };\n+                double b1 = bias + z1;\n+                double b2 = bias - z1;\n+                double a1 = a(b1);\n+                double a2 = a(b2);\n+                auto lo = std::max(cumn(a1), 0);\n+                auto hi = std::min(cumn(a2), n - 1);\n+\n+                return { point, resample[lo], resample[hi], confidence_level };\n+            }\n+\n+            inline double outlier_variance(Estimate<double> mean, Estimate<double> stddev, int n) {\n+                double sb = stddev.point;\n+                double mn = mean.point / n;\n+                double mg_min = mn / 2.;\n+                double sg = std::min(mg_min / 4., sb / std::sqrt(n));\n+                double sg2 = sg * sg;\n+                double sb2 = sb * sb;\n+\n+                auto c_max = [n, mn, sb2, sg2](double x) -> double {\n+                    double k = mn - x;\n+                    double d = k * k;\n+                    double nd = n * d;\n+                    double k0 = -n * nd;\n+                    double k1 = sb2 - n * sg2 + nd;\n+                    double det = k1 * k1 - 4 * sg2 * k0;\n+                    return (int)(-2. * k0 / (k1 + std::sqrt(det)));\n+                };\n+\n+                auto var_out = [n, sb2, sg2](double c) {\n+                    double nc = n - c;\n+                    return (nc / n) * (sb2 - nc * sg2);\n+                };\n+\n+                return std::min(var_out(1), var_out(std::min(c_max(0.), c_max(mg_min)))) / sb2;\n+            }\n+\n+            struct bootstrap_analysis {\n+                Estimate<double> mean;\n+                Estimate<double> standard_deviation;\n+                double outlier_variance;\n+            };\n+\n+            template <typename Iterator>\n+            bootstrap_analysis analyse_samples(double confidence_level, int n_resamples, Iterator first, Iterator last) {\n+                static std::random_device entropy;\n+\n+                auto n = static_cast<int>(last - first); // seriously, one can't use integral types without hell in C++\n+\n+                auto mean = &Detail::mean<Iterator>;\n+                auto stddev = &Detail::standard_deviation<Iterator>;\n+\n+#ifdef CATCH_USE_ASYNC\n+                auto Estimate = [=](double(*f)(Iterator, Iterator)) {\n+                    auto seed = entropy();\n+                    return std::async(std::launch::async, [=] {\n+                        std::mt19937 rng(seed);\n+                        auto resampled = resample(rng, n_resamples, first, last, f);\n+                        return bootstrap(confidence_level, first, last, resampled, f);\n+                    });\n+                };\n+\n+                auto mean_future = Estimate(mean);\n+                auto stddev_future = Estimate(stddev);\n+\n+                auto mean_estimate = mean_future.get();\n+                auto stddev_estimate = stddev_future.get();\n+#else\n+                auto Estimate = [=](double(*f)(Iterator, Iterator)) {\n+                    auto seed = entropy();\n+                    std::mt19937 rng(seed);\n+                    auto resampled = resample(rng, n_resamples, first, last, f);\n+                    return bootstrap(confidence_level, first, last, resampled, f);\n+                };\n+\n+                auto mean_estimate = Estimate(mean);\n+                auto stddev_estimate = Estimate(stddev);\n+#endif // CATCH_USE_ASYNC\n+\n+                double outlier_variance = Detail::outlier_variance(mean_estimate, stddev_estimate, n);\n+\n+                return { mean_estimate, stddev_estimate, outlier_variance };\n+            }\n+        } // namespace Detail\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_ANALYSIS_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_timing.hpp b/include/internal/benchmark/detail/catch_timing.hpp\nnew file mode 100644\nindex 0000000000..073cb74274\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_timing.hpp\n@@ -0,0 +1,33 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Timing\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_TIMING_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_TIMING_HPP_INCLUDED\n+\n+#include \"../catch_clock.hpp\"\n+#include \"catch_complete_invoke.hpp\"\n+\n+#include <tuple>\n+#include <type_traits>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        template <typename Duration, typename Result>\n+        struct Timing {\n+            Duration elapsed;\n+            Result result;\n+            int iterations;\n+        };\n+        template <typename Clock, typename Sig>\n+        using TimingOf = Timing<ClockDuration<Clock>, Detail::CompleteType_t<Detail::ResultOf_t<Sig>>>;\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_TIMING_HPP_INCLUDED\ndiff --git a/include/internal/catch_benchmark.cpp b/include/internal/catch_benchmark.cpp\ndeleted file mode 100644\nindex 742418f7fb..0000000000\n--- a/include/internal/catch_benchmark.cpp\n+++ /dev/null\n@@ -1,36 +0,0 @@\n-/*\n- *  Created by Phil on 04/07/2017.\n- *  Copyright 2017 Two Blue Cubes Ltd. All rights reserved.\n- *\n- *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n- *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n- */\n-\n-#include \"catch_benchmark.h\"\n-#include \"catch_capture.hpp\"\n-#include \"catch_interfaces_reporter.h\"\n-#include \"catch_context.h\"\n-\n-namespace Catch {\n-\n-    auto BenchmarkLooper::getResolution() -> uint64_t {\n-        return getEstimatedClockResolution() * getCurrentContext().getConfig()->benchmarkResolutionMultiple();\n-    }\n-\n-    void BenchmarkLooper::reportStart() {\n-        getResultCapture().benchmarkStarting( { m_name } );\n-    }\n-    auto BenchmarkLooper::needsMoreIterations() -> bool {\n-        auto elapsed = m_timer.getElapsedNanoseconds();\n-\n-        // Exponentially increasing iterations until we're confident in our timer resolution\n-        if( elapsed < m_resolution ) {\n-            m_iterationsToRun *= 10;\n-            return true;\n-        }\n-\n-        getResultCapture().benchmarkEnded( { { m_name }, m_count, elapsed } );\n-        return false;\n-    }\n-\n-} // end namespace Catch\ndiff --git a/include/internal/catch_benchmark.h b/include/internal/catch_benchmark.h\ndeleted file mode 100644\nindex e546713cf9..0000000000\n--- a/include/internal/catch_benchmark.h\n+++ /dev/null\n@@ -1,57 +0,0 @@\n-/*\n- *  Created by Phil on 04/07/2017.\n- *  Copyright 2017 Two Blue Cubes Ltd. All rights reserved.\n- *\n- *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n- *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n- */\n-#ifndef TWOBLUECUBES_CATCH_BENCHMARK_H_INCLUDED\n-#define TWOBLUECUBES_CATCH_BENCHMARK_H_INCLUDED\n-\n-#include \"catch_stringref.h\"\n-#include \"catch_timer.h\"\n-\n-#include <cstdint>\n-#include <string>\n-\n-namespace Catch {\n-\n-    class BenchmarkLooper {\n-\n-        std::string m_name;\n-        std::size_t m_count = 0;\n-        std::size_t m_iterationsToRun = 1;\n-        uint64_t m_resolution;\n-        Timer m_timer;\n-\n-        static auto getResolution() -> uint64_t;\n-    public:\n-        // Keep most of this inline as it's on the code path that is being timed\n-        BenchmarkLooper( StringRef name )\n-        :   m_name( name ),\n-            m_resolution( getResolution() )\n-        {\n-            reportStart();\n-            m_timer.start();\n-        }\n-\n-        explicit operator bool() {\n-            if( m_count < m_iterationsToRun )\n-                return true;\n-            return needsMoreIterations();\n-        }\n-\n-        void increment() {\n-            ++m_count;\n-        }\n-\n-        void reportStart();\n-        auto needsMoreIterations() -> bool;\n-    };\n-\n-} // end namespace Catch\n-\n-#define BENCHMARK( name ) \\\n-    for( Catch::BenchmarkLooper looper( name ); looper; looper.increment() )\n-\n-#endif // TWOBLUECUBES_CATCH_BENCHMARK_H_INCLUDED\ndiff --git a/include/internal/catch_commandline.cpp b/include/internal/catch_commandline.cpp\nindex 66759ebbf1..0359272cb3 100644\n--- a/include/internal/catch_commandline.cpp\n+++ b/include/internal/catch_commandline.cpp\n@@ -196,11 +196,19 @@ namespace Catch {\n             | Opt( setWaitForKeypress, \"start|exit|both\" )\n                 [\"--wait-for-keypress\"]\n                 ( \"waits for a keypress before exiting\" )\n-            | Opt( config.benchmarkResolutionMultiple, \"multiplier\" )\n-                [\"--benchmark-resolution-multiple\"]\n-                ( \"multiple of clock resolution to run benchmarks\" )\n-\n-            | Arg( config.testsOrTags, \"test name|pattern|tags\" )\n+            | Opt( config.benchmarkSamples, \"samples\" )\n+                [\"--benchmark-samples\"]\n+                ( \"number of samples to collect (default: 100)\" )\n+            | Opt( config.benchmarkResamples, \"resamples\" )\n+                [\"--benchmark-resamples\"]\n+                ( \"number of resamples for the bootstrap (default: 100000)\" )\n+            | Opt( config.benchmarkConfidenceInterval, \"confidence interval\" )\n+                [\"--benchmark-confidence-interval\"]\n+                ( \"confidence interval for the bootstrap (between 0 and 1, default: 0.95)\" )\n+            | Opt( config.benchmarkNoAnalysis )\n+                [\"--benchmark-no-analysis\"]\n+                ( \"perform only measurements; do not perform any analysis\" )\n+\t\t\t| Arg( config.testsOrTags, \"test name|pattern|tags\" )\n                 ( \"which test or tests to use\" );\n \n         return cli;\ndiff --git a/include/internal/catch_compiler_capabilities.h b/include/internal/catch_compiler_capabilities.h\nindex 8d5af618c0..018aefba81 100644\n--- a/include/internal/catch_compiler_capabilities.h\n+++ b/include/internal/catch_compiler_capabilities.h\n@@ -118,9 +118,9 @@\n // some versions of cygwin (most) do not support std::to_string. Use the libstd check. \n // https://gcc.gnu.org/onlinedocs/gcc-4.8.2/libstdc++/api/a01053_source.html line 2812-2813\n # if !((__cplusplus >= 201103L) && defined(_GLIBCXX_USE_C99) \\\n-\t       && !defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF))\n+           && !defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF))\n \n-#\tdefine CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING\n+#    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING\n \n # endif\n #endif // __CYGWIN__\n@@ -148,7 +148,11 @@\n #  if !defined(_MSVC_TRADITIONAL) || (defined(_MSVC_TRADITIONAL) && _MSVC_TRADITIONAL)\n #    define CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #  endif\n+#endif // _MSC_VER\n \n+#if defined(_REENTRANT) || defined(_MSC_VER)\n+// Enable async processing, as -pthread is specified or no additional linking is required\n+# define CATCH_USE_ASYNC\n #endif // _MSC_VER\n \n ////////////////////////////////////////////////////////////////////////////////\ndiff --git a/include/internal/catch_config.cpp b/include/internal/catch_config.cpp\nindex d9ee9182b2..076ae71878 100644\n--- a/include/internal/catch_config.cpp\n+++ b/include/internal/catch_config.cpp\n@@ -32,7 +32,7 @@ namespace Catch {\n     bool Config::listTestNamesOnly() const  { return m_data.listTestNamesOnly; }\n     bool Config::listTags() const           { return m_data.listTags; }\n     bool Config::listReporters() const      { return m_data.listReporters; }\n-\n+\t\n     std::string Config::getProcessName() const { return m_data.processName; }\n     std::string const& Config::getReporterName() const { return m_data.reporterName; }\n \n@@ -54,13 +54,17 @@ namespace Catch {\n     ShowDurations::OrNot Config::showDurations() const { return m_data.showDurations; }\n     RunTests::InWhatOrder Config::runOrder() const     { return m_data.runOrder; }\n     unsigned int Config::rngSeed() const               { return m_data.rngSeed; }\n-    int Config::benchmarkResolutionMultiple() const    { return m_data.benchmarkResolutionMultiple; }\n     UseColour::YesOrNo Config::useColour() const       { return m_data.useColour; }\n     bool Config::shouldDebugBreak() const              { return m_data.shouldDebugBreak; }\n     int Config::abortAfter() const                     { return m_data.abortAfter; }\n     bool Config::showInvisibles() const                { return m_data.showInvisibles; }\n     Verbosity Config::verbosity() const                { return m_data.verbosity; }\n \n+    bool Config::benchmarkNoAnalysis() const           { return m_data.benchmarkNoAnalysis; }\n+    int Config::benchmarkSamples() const               { return m_data.benchmarkSamples; }\n+    double Config::benchmarkConfidenceInterval() const { return m_data.benchmarkConfidenceInterval; }\n+    unsigned int Config::benchmarkResamples() const    { return m_data.benchmarkResamples; }\n+\n     IStream const* Config::openStream() {\n         return Catch::makeStream(m_data.outputFilename);\n     }\ndiff --git a/include/internal/catch_config.hpp b/include/internal/catch_config.hpp\nindex a9850233b0..95b67d25fc 100644\n--- a/include/internal/catch_config.hpp\n+++ b/include/internal/catch_config.hpp\n@@ -42,7 +42,11 @@ namespace Catch {\n \n         int abortAfter = -1;\n         unsigned int rngSeed = 0;\n-        int benchmarkResolutionMultiple = 100;\n+\n+        bool benchmarkNoAnalysis = false;\n+        unsigned int benchmarkSamples = 100;\n+        double benchmarkConfidenceInterval = 0.95;\n+        unsigned int benchmarkResamples = 100000;\n \n         Verbosity verbosity = Verbosity::Normal;\n         WarnAbout::What warnings = WarnAbout::Nothing;\n@@ -100,12 +104,15 @@ namespace Catch {\n         ShowDurations::OrNot showDurations() const override;\n         RunTests::InWhatOrder runOrder() const override;\n         unsigned int rngSeed() const override;\n-        int benchmarkResolutionMultiple() const override;\n         UseColour::YesOrNo useColour() const override;\n         bool shouldDebugBreak() const override;\n         int abortAfter() const override;\n         bool showInvisibles() const override;\n         Verbosity verbosity() const override;\n+        bool benchmarkNoAnalysis() const override;\n+        int benchmarkSamples() const override;\n+        double benchmarkConfidenceInterval() const override;\n+        unsigned int benchmarkResamples() const override;\n \n     private:\n \ndiff --git a/include/internal/catch_interfaces_capture.h b/include/internal/catch_interfaces_capture.h\nindex 36f27a331b..8c25c8cf76 100644\n--- a/include/internal/catch_interfaces_capture.h\n+++ b/include/internal/catch_interfaces_capture.h\n@@ -9,6 +9,7 @@\n #define TWOBLUECUBES_CATCH_INTERFACES_CAPTURE_H_INCLUDED\n \n #include <string>\n+#include <chrono>\n \n #include \"catch_stringref.h\"\n #include \"catch_result_type.h\"\n@@ -22,14 +23,18 @@ namespace Catch {\n     struct MessageInfo;\n     struct MessageBuilder;\n     struct Counts;\n-    struct BenchmarkInfo;\n-    struct BenchmarkStats;\n     struct AssertionReaction;\n     struct SourceLineInfo;\n \n     struct ITransientExpression;\n     struct IGeneratorTracker;\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+    struct BenchmarkInfo;\n+    template <typename Duration = std::chrono::duration<double, std::nano>>\n+    struct BenchmarkStats;\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n+\n     struct IResultCapture {\n \n         virtual ~IResultCapture();\n@@ -41,8 +46,12 @@ namespace Catch {\n \n         virtual auto acquireGeneratorTracker( SourceLineInfo const& lineInfo ) -> IGeneratorTracker& = 0;\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+        virtual void benchmarkPreparing( std::string const& name ) = 0;\n         virtual void benchmarkStarting( BenchmarkInfo const& info ) = 0;\n-        virtual void benchmarkEnded( BenchmarkStats const& stats ) = 0;\n+        virtual void benchmarkEnded( BenchmarkStats<> const& stats ) = 0;\n+        virtual void benchmarkFailed( std::string const& error ) = 0;\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n         virtual void pushScopedMessage( MessageInfo const& message ) = 0;\n         virtual void popScopedMessage( MessageInfo const& message ) = 0;\ndiff --git a/include/internal/catch_interfaces_config.h b/include/internal/catch_interfaces_config.h\nindex 341bb74205..f8cbf71c86 100644\n--- a/include/internal/catch_interfaces_config.h\n+++ b/include/internal/catch_interfaces_config.h\n@@ -9,6 +9,7 @@\n #define TWOBLUECUBES_CATCH_INTERFACES_CONFIG_H_INCLUDED\n \n #include \"catch_common.h\"\n+#include \"catch_option.hpp\"\n \n #include <iosfwd>\n #include <string>\n@@ -50,7 +51,7 @@ namespace Catch {\n         BeforeExit = 2,\n         BeforeStartAndExit = BeforeStart | BeforeExit\n     }; };\n-\n+    \n     class TestSpec;\n \n     struct IConfig : NonCopyable {\n@@ -72,10 +73,14 @@ namespace Catch {\n         virtual std::vector<std::string> const& getTestsOrTags() const = 0;\n         virtual RunTests::InWhatOrder runOrder() const = 0;\n         virtual unsigned int rngSeed() const = 0;\n-        virtual int benchmarkResolutionMultiple() const = 0;\n         virtual UseColour::YesOrNo useColour() const = 0;\n         virtual std::vector<std::string> const& getSectionsToRun() const = 0;\n         virtual Verbosity verbosity() const = 0;\n+\n+        virtual bool benchmarkNoAnalysis() const = 0;\n+        virtual int benchmarkSamples() const = 0;\n+        virtual double benchmarkConfidenceInterval() const = 0;\n+        virtual unsigned int benchmarkResamples() const = 0;\n     };\n \n     using IConfigPtr = std::shared_ptr<IConfig const>;\ndiff --git a/include/internal/catch_interfaces_reporter.h b/include/internal/catch_interfaces_reporter.h\nindex e5fbf8bb07..e54a24a894 100644\n--- a/include/internal/catch_interfaces_reporter.h\n+++ b/include/internal/catch_interfaces_reporter.h\n@@ -18,12 +18,18 @@\n #include \"catch_option.hpp\"\n #include \"catch_stringref.h\"\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+#include \"benchmark/catch_estimate.hpp\"\n+#include \"benchmark/catch_outlier_classification.hpp\"\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n+\n \n #include <string>\n #include <iosfwd>\n #include <map>\n #include <set>\n #include <memory>\n+#include <algorithm>\n \n namespace Catch {\n \n@@ -159,14 +165,43 @@ namespace Catch {\n         bool aborting;\n     };\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n     struct BenchmarkInfo {\n         std::string name;\n+        double estimatedDuration;\n+        int iterations;\n+        int samples;\n+        unsigned int resamples;\n+        double clockResolution;\n+        double clockCost;\n     };\n+\n+    template <class Duration>\n     struct BenchmarkStats {\n         BenchmarkInfo info;\n-        std::size_t iterations;\n-        uint64_t elapsedTimeInNanoseconds;\n+\n+        std::vector<Duration> samples;\n+        Benchmark::Estimate<Duration> mean;\n+        Benchmark::Estimate<Duration> standardDeviation;\n+        Benchmark::OutlierClassification outliers;\n+        double outlierVariance;\n+\n+        template <typename Duration2>\n+        operator BenchmarkStats<Duration2>() const {\n+            std::vector<Duration2> samples2;\n+            samples2.reserve(samples.size());\n+            std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](Duration d) { return Duration2(d); });\n+            return {\n+                info,\n+                std::move(samples2),\n+                mean,\n+                standardDeviation,\n+                outliers,\n+                outlierVariance,\n+            };\n+        }\n     };\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n     struct IStreamingReporter {\n         virtual ~IStreamingReporter() = default;\n@@ -185,17 +220,18 @@ namespace Catch {\n         virtual void testCaseStarting( TestCaseInfo const& testInfo ) = 0;\n         virtual void sectionStarting( SectionInfo const& sectionInfo ) = 0;\n \n-        // *** experimental ***\n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+        virtual void benchmarkPreparing( std::string const& ) {}\n         virtual void benchmarkStarting( BenchmarkInfo const& ) {}\n+        virtual void benchmarkEnded( BenchmarkStats<> const& ) {}\n+        virtual void benchmarkFailed( std::string const& ) {}\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n         virtual void assertionStarting( AssertionInfo const& assertionInfo ) = 0;\n \n         // The return value indicates if the messages buffer should be cleared:\n         virtual bool assertionEnded( AssertionStats const& assertionStats ) = 0;\n \n-        // *** experimental ***\n-        virtual void benchmarkEnded( BenchmarkStats const& ) {}\n-\n         virtual void sectionEnded( SectionStats const& sectionStats ) = 0;\n         virtual void testCaseEnded( TestCaseStats const& testCaseStats ) = 0;\n         virtual void testGroupEnded( TestGroupStats const& testGroupStats ) = 0;\ndiff --git a/include/internal/catch_meta.hpp b/include/internal/catch_meta.hpp\nindex 686dbb8c07..fe8698dcbc 100644\n--- a/include/internal/catch_meta.hpp\n+++ b/include/internal/catch_meta.hpp\n@@ -12,8 +12,23 @@\n #include <type_traits>\n \n namespace Catch {\n-    template<typename T>\n-    struct always_false : std::false_type {};\n+template<typename T>\n+struct always_false : std::false_type {};\n+\n+template <typename> struct true_given : std::true_type {};\n+struct is_callable_tester {\n+    template <typename Fun, typename... Args>\n+    true_given<decltype(std::declval<Fun>()(std::declval<Args>()...))> static test(int);\n+    template <typename...>\n+    std::false_type static test(...);\n+};\n+\n+template <typename T>\n+struct is_callable;\n+\n+template <typename Fun, typename... Args>\n+struct is_callable<Fun(Args...)> : decltype(is_callable_tester::test<Fun, Args...>(0)) {};\n+\n } // namespace Catch\n \n #endif // TWOBLUECUBES_CATCH_META_HPP_INCLUDED\ndiff --git a/include/internal/catch_run_context.cpp b/include/internal/catch_run_context.cpp\nindex bc3a51512b..d2acc65218 100644\n--- a/include/internal/catch_run_context.cpp\n+++ b/include/internal/catch_run_context.cpp\n@@ -230,12 +230,21 @@ namespace Catch {\n \n         m_unfinishedSections.push_back(endInfo);\n     }\n+\t\n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+    void RunContext::benchmarkPreparing(std::string const& name) {\n+\t\tm_reporter->benchmarkPreparing(name);\n+\t}\n     void RunContext::benchmarkStarting( BenchmarkInfo const& info ) {\n         m_reporter->benchmarkStarting( info );\n     }\n-    void RunContext::benchmarkEnded( BenchmarkStats const& stats ) {\n+    void RunContext::benchmarkEnded( BenchmarkStats<> const& stats ) {\n         m_reporter->benchmarkEnded( stats );\n     }\n+\tvoid RunContext::benchmarkFailed(std::string const & error) {\n+\t\tm_reporter->benchmarkFailed(error);\n+\t}\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n     void RunContext::pushScopedMessage(MessageInfo const & message) {\n         m_messages.push_back(message);\ndiff --git a/include/internal/catch_run_context.h b/include/internal/catch_run_context.h\nindex c530a7b2d9..66a58c5e27 100644\n--- a/include/internal/catch_run_context.h\n+++ b/include/internal/catch_run_context.h\n@@ -82,8 +82,12 @@ namespace Catch {\n \n         auto acquireGeneratorTracker( SourceLineInfo const& lineInfo ) -> IGeneratorTracker& override;\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+        void benchmarkPreparing( std::string const& name ) override;\n         void benchmarkStarting( BenchmarkInfo const& info ) override;\n-        void benchmarkEnded( BenchmarkStats const& stats ) override;\n+        void benchmarkEnded( BenchmarkStats<> const& stats ) override;\n+        void benchmarkFailed( std::string const& error ) override;\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n         void pushScopedMessage( MessageInfo const& message ) override;\n         void popScopedMessage( MessageInfo const& message ) override;\ndiff --git a/include/internal/catch_stream.cpp b/include/internal/catch_stream.cpp\nindex ba2d2be253..3e907c63b2 100644\n--- a/include/internal/catch_stream.cpp\n+++ b/include/internal/catch_stream.cpp\n@@ -25,7 +25,7 @@ namespace Catch {\n \n     Catch::IStream::~IStream() = default;\n \n-    namespace detail { namespace {\n+    namespace Detail { namespace {\n         template<typename WriterF, std::size_t bufferSize=256>\n         class StreamBufImpl : public std::streambuf {\n             char data[bufferSize];\n@@ -124,15 +124,15 @@ namespace Catch {\n \n     auto makeStream( StringRef const &filename ) -> IStream const* {\n         if( filename.empty() )\n-            return new detail::CoutStream();\n+            return new Detail::CoutStream();\n         else if( filename[0] == '%' ) {\n             if( filename == \"%debug\" )\n-                return new detail::DebugOutStream();\n+                return new Detail::DebugOutStream();\n             else\n                 CATCH_ERROR( \"Unrecognised stream: '\" << filename << \"'\" );\n         }\n         else\n-            return new detail::FileStream( filename );\n+            return new Detail::FileStream( filename );\n     }\n \n \ndiff --git a/include/reporters/catch_reporter_console.cpp b/include/reporters/catch_reporter_console.cpp\nindex 53b977eb1f..b88f3b141d 100644\n--- a/include/reporters/catch_reporter_console.cpp\n+++ b/include/reporters/catch_reporter_console.cpp\n@@ -20,10 +20,16 @@\n #if defined(_MSC_VER)\n #pragma warning(push)\n #pragma warning(disable:4061) // Not all labels are EXPLICITLY handled in switch\n- // Note that 4062 (not all labels are handled\n- // and default is missing) is enabled\n+ // Note that 4062 (not all labels are handled and default is missing) is enabled\n #endif\n \n+#if defined(__clang__)\n+#  pragma clang diagnostic push\n+// For simplicity, benchmarking-only helpers are always enabled\n+#  pragma clang diagnostic ignored \"-Wunused-function\"\n+#endif\n+\n+\n \n namespace Catch {\n \n@@ -208,6 +214,10 @@ class Duration {\n     Unit m_units;\n \n public:\n+\texplicit Duration(double inNanoseconds, Unit units = Unit::Auto)\n+        : Duration(static_cast<uint64_t>(inNanoseconds), units) {\n+    }\n+\n     explicit Duration(uint64_t inNanoseconds, Unit units = Unit::Auto)\n         : m_inNanoseconds(inNanoseconds),\n         m_units(units) {\n@@ -283,9 +293,15 @@ class TablePrinter {\n         if (!m_isOpen) {\n             m_isOpen = true;\n             *this << RowBreak();\n-            for (auto const& info : m_columnInfos)\n-                *this << info.name << ColumnBreak();\n-            *this << RowBreak();\n+\n+\t\t\tColumns headerCols;\n+\t\t\tSpacer spacer(2);\n+\t\t\tfor (auto const& info : m_columnInfos) {\n+\t\t\t\theaderCols += Column(info.name).width(static_cast<std::size_t>(info.width - 2));\n+\t\t\t\theaderCols += spacer;\n+\t\t\t}\n+\t\t\tm_os << headerCols << \"\\n\";\n+\n             m_os << Catch::getLineOfChars<'-'>() << \"\\n\";\n         }\n     }\n@@ -340,9 +356,9 @@ ConsoleReporter::ConsoleReporter(ReporterConfig const& config)\n     m_tablePrinter(new TablePrinter(config.stream(),\n     {\n         { \"benchmark name\", CATCH_CONFIG_CONSOLE_WIDTH - 32, ColumnInfo::Left },\n-        { \"iters\", 8, ColumnInfo::Right },\n-        { \"elapsed ns\", 14, ColumnInfo::Right },\n-        { \"average\", 14, ColumnInfo::Right }\n+        { \"samples      mean       std dev\", 14, ColumnInfo::Right },\n+        { \"iterations   low mean   low std dev\", 14, ColumnInfo::Right },\n+        { \"estimated    high mean  high std dev\", 14, ColumnInfo::Right }\n     })) {}\n ConsoleReporter::~ConsoleReporter() = default;\n \n@@ -374,6 +390,7 @@ bool ConsoleReporter::assertionEnded(AssertionStats const& _assertionStats) {\n }\n \n void ConsoleReporter::sectionStarting(SectionInfo const& _sectionInfo) {\n+    m_tablePrinter->close();\n     m_headerPrinted = false;\n     StreamingReporterBase::sectionStarting(_sectionInfo);\n }\n@@ -397,29 +414,45 @@ void ConsoleReporter::sectionEnded(SectionStats const& _sectionStats) {\n     StreamingReporterBase::sectionEnded(_sectionStats);\n }\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+void ConsoleReporter::benchmarkPreparing(std::string const& name) {\n+\tlazyPrintWithoutClosingBenchmarkTable();\n \n-void ConsoleReporter::benchmarkStarting(BenchmarkInfo const& info) {\n-    lazyPrintWithoutClosingBenchmarkTable();\n+\tauto nameCol = Column(name).width(static_cast<std::size_t>(m_tablePrinter->columnInfos()[0].width - 2));\n \n-    auto nameCol = Column( info.name ).width( static_cast<std::size_t>( m_tablePrinter->columnInfos()[0].width - 2 ) );\n+\tbool firstLine = true;\n+\tfor (auto line : nameCol) {\n+\t\tif (!firstLine)\n+\t\t\t(*m_tablePrinter) << ColumnBreak() << ColumnBreak() << ColumnBreak();\n+\t\telse\n+\t\t\tfirstLine = false;\n \n-    bool firstLine = true;\n-    for (auto line : nameCol) {\n-        if (!firstLine)\n-            (*m_tablePrinter) << ColumnBreak() << ColumnBreak() << ColumnBreak();\n-        else\n-            firstLine = false;\n+\t\t(*m_tablePrinter) << line << ColumnBreak();\n+\t}\n+}\n \n-        (*m_tablePrinter) << line << ColumnBreak();\n-    }\n+void ConsoleReporter::benchmarkStarting(BenchmarkInfo const& info) {\n+\t(*m_tablePrinter) << info.samples << ColumnBreak()\n+\t\t<< info.iterations << ColumnBreak()\n+\t\t<< Duration(info.estimatedDuration) << ColumnBreak();\n }\n-void ConsoleReporter::benchmarkEnded(BenchmarkStats const& stats) {\n-    Duration average(stats.elapsedTimeInNanoseconds / stats.iterations);\n+void ConsoleReporter::benchmarkEnded(BenchmarkStats<> const& stats) {\n+\t(*m_tablePrinter) << ColumnBreak()\n+\t\t<< Duration(stats.mean.point.count()) << ColumnBreak()\n+\t\t<< Duration(stats.mean.lower_bound.count()) << ColumnBreak()\n+\t\t<< Duration(stats.mean.upper_bound.count()) << ColumnBreak() << ColumnBreak()\n+\t\t<< Duration(stats.standardDeviation.point.count()) << ColumnBreak()\n+\t\t<< Duration(stats.standardDeviation.lower_bound.count()) << ColumnBreak()\n+\t\t<< Duration(stats.standardDeviation.upper_bound.count()) << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak();\n+}\n+\n+void ConsoleReporter::benchmarkFailed(std::string const& error) {\n+\tColour colour(Colour::Red);\n     (*m_tablePrinter)\n-        << stats.iterations << ColumnBreak()\n-        << stats.elapsedTimeInNanoseconds << ColumnBreak()\n-        << average << ColumnBreak();\n+        << \"Benchmark failed (\" << error << \")\"\n+        << ColumnBreak() << RowBreak();\n }\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n void ConsoleReporter::testCaseEnded(TestCaseStats const& _testCaseStats) {\n     m_tablePrinter->close();\n@@ -638,3 +671,7 @@ CATCH_REGISTER_REPORTER(\"console\", ConsoleReporter)\n #if defined(_MSC_VER)\n #pragma warning(pop)\n #endif\n+\n+#if defined(__clang__)\n+#  pragma clang diagnostic pop\n+#endif\ndiff --git a/include/reporters/catch_reporter_console.h b/include/reporters/catch_reporter_console.h\nindex effa58d343..5d21ffb692 100644\n--- a/include/reporters/catch_reporter_console.h\n+++ b/include/reporters/catch_reporter_console.h\n@@ -39,9 +39,12 @@ namespace Catch {\n         void sectionStarting(SectionInfo const& _sectionInfo) override;\n         void sectionEnded(SectionStats const& _sectionStats) override;\n \n-\n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+        void benchmarkPreparing(std::string const& name) override;\n         void benchmarkStarting(BenchmarkInfo const& info) override;\n-        void benchmarkEnded(BenchmarkStats const& stats) override;\n+        void benchmarkEnded(BenchmarkStats<> const& stats) override;\n+        void benchmarkFailed(std::string const& error) override;\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n         void testCaseEnded(TestCaseStats const& _testCaseStats) override;\n         void testGroupEnded(TestGroupStats const& _testGroupStats) override;\ndiff --git a/include/reporters/catch_reporter_listening.cpp b/include/reporters/catch_reporter_listening.cpp\nindex 9ddae2f2ed..6864e90bc9 100644\n--- a/include/reporters/catch_reporter_listening.cpp\n+++ b/include/reporters/catch_reporter_listening.cpp\n@@ -42,19 +42,34 @@ namespace Catch {\n         m_reporter->noMatchingTestCases( spec );\n     }\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+    void ListeningReporter::benchmarkPreparing( std::string const& name ) {\n+\t\tfor (auto const& listener : m_listeners) {\n+\t\t\tlistener->benchmarkPreparing(name);\n+\t\t}\n+\t\tm_reporter->benchmarkPreparing(name);\n+\t}\n     void ListeningReporter::benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) {\n         for ( auto const& listener : m_listeners ) {\n             listener->benchmarkStarting( benchmarkInfo );\n         }\n         m_reporter->benchmarkStarting( benchmarkInfo );\n     }\n-    void ListeningReporter::benchmarkEnded( BenchmarkStats const& benchmarkStats ) {\n+    void ListeningReporter::benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) {\n         for ( auto const& listener : m_listeners ) {\n             listener->benchmarkEnded( benchmarkStats );\n         }\n         m_reporter->benchmarkEnded( benchmarkStats );\n     }\n \n+\tvoid ListeningReporter::benchmarkFailed( std::string const& error ) {\n+\t\tfor (auto const& listener : m_listeners) {\n+\t\t\tlistener->benchmarkFailed(error);\n+\t\t}\n+\t\tm_reporter->benchmarkFailed(error);\n+\t}\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n+\n     void ListeningReporter::testRunStarting( TestRunInfo const& testRunInfo ) {\n         for ( auto const& listener : m_listeners ) {\n             listener->testRunStarting( testRunInfo );\ndiff --git a/include/reporters/catch_reporter_listening.h b/include/reporters/catch_reporter_listening.h\nindex dddd7a5186..802db446d7 100644\n--- a/include/reporters/catch_reporter_listening.h\n+++ b/include/reporters/catch_reporter_listening.h\n@@ -31,8 +31,12 @@ namespace Catch {\n \n         static std::set<Verbosity> getSupportedVerbosities();\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+        void benchmarkPreparing(std::string const& name) override;\n         void benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) override;\n-        void benchmarkEnded( BenchmarkStats const& benchmarkStats ) override;\n+        void benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) override;\n+        void benchmarkFailed(std::string const&) override;\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n         void testRunStarting( TestRunInfo const& testRunInfo ) override;\n         void testGroupStarting( GroupInfo const& groupInfo ) override;\ndiff --git a/include/reporters/catch_reporter_xml.cpp b/include/reporters/catch_reporter_xml.cpp\nindex c7572d1ebe..f626fb68b0 100644\n--- a/include/reporters/catch_reporter_xml.cpp\n+++ b/include/reporters/catch_reporter_xml.cpp\n@@ -219,6 +219,48 @@ namespace Catch {\n         m_xml.endElement();\n     }\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+    void XmlReporter::benchmarkStarting(BenchmarkInfo const &info) {\n+        m_xml.startElement(\"BenchmarkResults\")\n+            .writeAttribute(\"name\", info.name)\n+            .writeAttribute(\"samples\", info.samples)\n+            .writeAttribute(\"resamples\", info.resamples)\n+            .writeAttribute(\"iterations\", info.iterations)\n+            .writeAttribute(\"clockResolution\", static_cast<uint64_t>(info.clockResolution))\n+            .writeAttribute(\"estimatedDuration\", static_cast<uint64_t>(info.estimatedDuration))\n+            .writeComment(\"All values in nano seconds\");\n+    }\n+\n+    void XmlReporter::benchmarkEnded(BenchmarkStats<> const& benchmarkStats) {\n+        m_xml.startElement(\"mean\")\n+            .writeAttribute(\"value\", static_cast<uint64_t>(benchmarkStats.mean.point.count()))\n+            .writeAttribute(\"lowerBound\", static_cast<uint64_t>(benchmarkStats.mean.lower_bound.count()))\n+            .writeAttribute(\"upperBound\", static_cast<uint64_t>(benchmarkStats.mean.upper_bound.count()))\n+            .writeAttribute(\"ci\", benchmarkStats.mean.confidence_interval);\n+        m_xml.endElement();\n+        m_xml.startElement(\"standardDeviation\")\n+            .writeAttribute(\"value\", benchmarkStats.standardDeviation.point.count())\n+            .writeAttribute(\"lowerBound\", benchmarkStats.standardDeviation.lower_bound.count())\n+            .writeAttribute(\"upperBound\", benchmarkStats.standardDeviation.upper_bound.count())\n+            .writeAttribute(\"ci\", benchmarkStats.standardDeviation.confidence_interval);\n+        m_xml.endElement();\n+        m_xml.startElement(\"outliers\")\n+            .writeAttribute(\"variance\", benchmarkStats.outlierVariance)\n+            .writeAttribute(\"lowMild\", benchmarkStats.outliers.low_mild)\n+            .writeAttribute(\"lowSevere\", benchmarkStats.outliers.low_severe)\n+            .writeAttribute(\"highMild\", benchmarkStats.outliers.high_mild)\n+            .writeAttribute(\"highSevere\", benchmarkStats.outliers.high_severe);\n+        m_xml.endElement();\n+        m_xml.endElement();\n+    }\n+\n+    void XmlReporter::benchmarkFailed(std::string const &error) {\n+        m_xml.scopedElement(\"failed\").\n+            writeAttribute(\"message\", error);\n+        m_xml.endElement();\n+    }\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n+\n     CATCH_REGISTER_REPORTER( \"xml\", XmlReporter )\n \n } // end namespace Catch\ndiff --git a/include/reporters/catch_reporter_xml.h b/include/reporters/catch_reporter_xml.h\nindex 7926f93a85..761f98f1ec 100644\n--- a/include/reporters/catch_reporter_xml.h\n+++ b/include/reporters/catch_reporter_xml.h\n@@ -50,6 +50,12 @@ namespace Catch {\n \n         void testRunEnded(TestRunStats const& testRunStats) override;\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+        void benchmarkStarting(BenchmarkInfo const&) override;\n+        void benchmarkEnded(BenchmarkStats<> const&) override;\n+        void benchmarkFailed(std::string const&) override;\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n+\n     private:\n         Timer m_testCaseTimer;\n         XmlWriter m_xml;\ndiff --git a/projects/CMakeLists.txt b/projects/CMakeLists.txt\nindex 3029e82355..f204ddd449 100644\n--- a/projects/CMakeLists.txt\n+++ b/projects/CMakeLists.txt\n@@ -18,6 +18,7 @@ set(TEST_SOURCES\n         ${SELF_TEST_DIR}/TestMain.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/CmdLine.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/GeneratorsImpl.tests.cpp\n+        ${SELF_TEST_DIR}/IntrospectiveTests/InternalBenchmark.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/PartTracker.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Tag.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/String.tests.cpp\n@@ -79,6 +80,28 @@ CheckFileList(EXTERNAL_HEADERS ${HEADER_DIR}/external)\n \n \n # Please keep these ordered alphabetically\n+set(BENCHMARK_HEADERS\n+\t\t${HEADER_DIR}/internal/benchmark/catch_benchmark.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_chronometer.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_clock.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_constructor.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_environment.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_estimate.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_execution_plan.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_optimizer.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_outlier_classification.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_sample_analysis.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_analyse.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_benchmark_function.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_complete_invoke.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_estimate_clock.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_measure.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_repeat.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_run_for_at_least.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_stats.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_timing.hpp\n+)\n+SOURCE_GROUP(\"benchmark\" FILES ${BENCHMARK_HEADERS})\n set(INTERNAL_HEADERS\n         ${HEADER_DIR}/internal/catch_approx.h\n         ${HEADER_DIR}/internal/catch_assertionhandler.h\n@@ -138,7 +161,6 @@ set(INTERNAL_HEADERS\n         ${HEADER_DIR}/internal/catch_reporter_registry.h\n         ${HEADER_DIR}/internal/catch_result_type.h\n         ${HEADER_DIR}/internal/catch_run_context.h\n-        ${HEADER_DIR}/internal/catch_benchmark.h\n         ${HEADER_DIR}/internal/catch_section.h\n         ${HEADER_DIR}/internal/catch_section_info.h\n         ${HEADER_DIR}/internal/catch_session.h\n@@ -174,7 +196,6 @@ set(IMPL_SOURCES\n         ${HEADER_DIR}/internal/catch_approx.cpp\n         ${HEADER_DIR}/internal/catch_assertionhandler.cpp\n         ${HEADER_DIR}/internal/catch_assertionresult.cpp\n-        ${HEADER_DIR}/internal/catch_benchmark.cpp\n         ${HEADER_DIR}/internal/catch_capture_matchers.cpp\n         ${HEADER_DIR}/internal/catch_commandline.cpp\n         ${HEADER_DIR}/internal/catch_common.cpp\n@@ -269,6 +290,7 @@ set(HEADERS\n         ${EXTERNAL_HEADERS}\n         ${INTERNAL_HEADERS}\n         ${REPORTER_HEADERS}\n+\t\t${BENCHMARK_HEADERS}\n         )\n \n # Provide some groupings for IDEs\ndiff --git a/projects/ExtraTests/CMakeLists.txt b/projects/ExtraTests/CMakeLists.txt\nindex c0dd82d8f0..5a8dd79bcd 100644\n--- a/projects/ExtraTests/CMakeLists.txt\n+++ b/projects/ExtraTests/CMakeLists.txt\n@@ -116,6 +116,17 @@ set_tests_properties(\n )\n \n \n+add_executable(BenchmarkingMacros ${TESTS_DIR}/X20-BenchmarkingMacros.cpp)\n+target_compile_definitions( BenchmarkingMacros PRIVATE CATCH_CONFIG_ENABLE_BENCHMARKING )\n+\n+add_test(NAME BenchmarkingMacros COMMAND BenchmarkingMacros -r console -s)\n+set_tests_properties(\n+    BenchmarkingMacros\n+  PROPERTIES\n+    PASS_REGULAR_EXPRESSION \"benchmark name                                  samples       iterations    estimated\"\n+)\n+\n+\n set( EXTRA_TEST_BINARIES\n     PrefixedMacros\n     DisabledMacros\n@@ -123,6 +134,7 @@ set( EXTRA_TEST_BINARIES\n     DisabledExceptions-CustomHandler\n     FallbackStringifier\n     DisableStringification\n+    BenchmarkingMacros\n )\n \n # Shared config\ndiff --git a/projects/ExtraTests/X20-BenchmarkingMacros.cpp b/projects/ExtraTests/X20-BenchmarkingMacros.cpp\nnew file mode 100644\nindex 0000000000..e76af0c71f\n--- /dev/null\n+++ b/projects/ExtraTests/X20-BenchmarkingMacros.cpp\n@@ -0,0 +1,133 @@\n+// X20-BenchmarkingMacros.cpp\n+// Test that the benchmarking support macros compile properly with the single header\n+\n+#define CATCH_CONFIG_MAIN\n+#include <catch2/catch.hpp>\n+\n+namespace {\n+std::uint64_t factorial(std::uint64_t number) {\n+    if (number < 2) {\n+        return 1;\n+    }\n+    return number * factorial(number - 1);\n+}\n+}\n+\n+TEST_CASE(\"Benchmark factorial\", \"[benchmark]\") {\n+    CHECK(factorial(0) == 1);\n+    // some more asserts..\n+    CHECK(factorial(10) == 3628800);\n+\n+    BENCHMARK(\"factorial 10\") {\n+        return factorial(10);\n+    };\n+\n+    CHECK(factorial(14) == 87178291200ull);\n+    BENCHMARK(\"factorial 14\") {\n+        return factorial(14);\n+    };\n+//\n+//    BENCHMARK(\"factorial 20\") {\n+//        return factorial(20);\n+//    };\n+//\n+//    BENCHMARK(\"factorial 35\") {\n+//        return factorial(35);\n+//    };\n+}\n+\n+TEST_CASE(\"Benchmark containers\", \"[.][benchmark]\") {\n+    static const int size = 100;\n+\n+    std::vector<int> v;\n+    std::map<int, int> m;\n+\n+    SECTION(\"without generator\") {\n+        BENCHMARK(\"Load up a vector\") {\n+            v = std::vector<int>();\n+            for (int i = 0; i < size; ++i)\n+                v.push_back(i);\n+        };\n+        REQUIRE(v.size() == size);\n+\n+        // test optimizer control\n+        BENCHMARK(\"Add up a vector's content\") {\n+            uint64_t add = 0;\n+            for (int i = 0; i < size; ++i)\n+                add += v[i];\n+            return add;\n+        };\n+\n+        BENCHMARK(\"Load up a map\") {\n+            m = std::map<int, int>();\n+            for (int i = 0; i < size; ++i)\n+                m.insert({ i, i + 1 });\n+        };\n+        REQUIRE(m.size() == size);\n+\n+        BENCHMARK(\"Reserved vector\") {\n+            v = std::vector<int>();\n+            v.reserve(size);\n+            for (int i = 0; i < size; ++i)\n+                v.push_back(i);\n+        };\n+        REQUIRE(v.size() == size);\n+\n+        BENCHMARK(\"Resized vector\") {\n+            v = std::vector<int>();\n+            v.resize(size);\n+            for (int i = 0; i < size; ++i)\n+                v[i] = i;\n+        };\n+        REQUIRE(v.size() == size);\n+\n+        int array[size];\n+        BENCHMARK(\"A fixed size array that should require no allocations\") {\n+            for (int i = 0; i < size; ++i)\n+                array[i] = i;\n+        };\n+        int sum = 0;\n+        for (int i = 0; i < size; ++i)\n+            sum += array[i];\n+        REQUIRE(sum > size);\n+\n+        SECTION(\"XYZ\") {\n+\n+            BENCHMARK_ADVANCED(\"Load up vector with chronometer\")(Catch::Benchmark::Chronometer meter) {\n+                std::vector<int> k;\n+                meter.measure([&](int idx) {\n+                    k = std::vector<int>();\n+                    for (int i = 0; i < size; ++i)\n+                        k.push_back(idx);\n+                });\n+                REQUIRE(k.size() == size);\n+            };\n+\n+            int runs = 0;\n+            BENCHMARK(\"Fill vector indexed\", benchmarkIndex) {\n+                v = std::vector<int>();\n+                v.resize(size);\n+                for (int i = 0; i < size; ++i)\n+                    v[i] = benchmarkIndex;\n+                runs = benchmarkIndex;\n+            };\n+\n+            for (size_t i = 0; i < v.size(); ++i) {\n+                REQUIRE(v[i] == runs);\n+            }\n+        }\n+    }\n+\n+    SECTION(\"with generator\") {\n+        auto generated = GENERATE(range(0, 10));\n+        BENCHMARK(\"Fill vector generated\") {\n+            v = std::vector<int>();\n+            v.resize(size);\n+            for (int i = 0; i < size; ++i)\n+                v[i] = generated;\n+        };\n+        for (size_t i = 0; i < v.size(); ++i) {\n+            REQUIRE(v[i] == generated);\n+        }\n+    }\n+}\ndiff --git a/projects/SelfTest/Baselines/compact.sw.approved.txt b/projects/SelfTest/Baselines/compact.sw.approved.txt\nindex 89ebdfb1b5..eb30151f32 100644\n--- a/projects/SelfTest/Baselines/compact.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/compact.sw.approved.txt\n@@ -944,6 +944,14 @@ CmdLine.tests.cpp:<line number>: passed: cli.parse({\"test\", \"--use-colour\", \"no\"\n CmdLine.tests.cpp:<line number>: passed: config.useColour == UseColour::No for: 2 == 2\n CmdLine.tests.cpp:<line number>: passed: !result for: true\n CmdLine.tests.cpp:<line number>: passed: result.errorMessage(), Contains( \"colour mode must be one of\" ) for: \"colour mode must be one of: auto, yes or no. 'wrong' not recognised\" contains: \"colour mode must be one of\"\n+CmdLine.tests.cpp:<line number>: passed: cli.parse({ \"test\", \"--benchmark-samples=200\" }) for: {?}\n+CmdLine.tests.cpp:<line number>: passed: config.benchmarkSamples == 200 for: 200 == 200\n+CmdLine.tests.cpp:<line number>: passed: cli.parse({ \"test\", \"--benchmark-resamples=20000\" }) for: {?}\n+CmdLine.tests.cpp:<line number>: passed: config.benchmarkResamples == 20000 for: 20000 (0x<hex digits>) == 20000 (0x<hex digits>)\n+CmdLine.tests.cpp:<line number>: passed: cli.parse({ \"test\", \"--benchmark-confidence-interval=0.99\" }) for: {?}\n+CmdLine.tests.cpp:<line number>: passed: config.benchmarkConfidenceInterval == Catch::Detail::Approx(0.99) for: 0.99 == Approx( 0.99 )\n+CmdLine.tests.cpp:<line number>: passed: cli.parse({ \"test\", \"--benchmark-no-analysis\" }) for: {?}\n+CmdLine.tests.cpp:<line number>: passed: config.benchmarkNoAnalysis for: true\n Misc.tests.cpp:<line number>: passed: std::tuple_size<TestType>::value >= 1 for: 3 >= 1\n Misc.tests.cpp:<line number>: passed: std::tuple_size<TestType>::value >= 1 for: 2 >= 1\n Misc.tests.cpp:<line number>: passed: std::tuple_size<TestType>::value >= 1 for: 1 >= 1\ndiff --git a/projects/SelfTest/Baselines/console.std.approved.txt b/projects/SelfTest/Baselines/console.std.approved.txt\nindex 5f8e036272..ebbef31344 100644\n--- a/projects/SelfTest/Baselines/console.std.approved.txt\n+++ b/projects/SelfTest/Baselines/console.std.approved.txt\n@@ -1381,5 +1381,5 @@ due to unexpected exception with message:\n \n ===============================================================================\n test cases:  289 |  215 passed |  70 failed |  4 failed as expected\n-assertions: 1539 | 1387 passed | 131 failed | 21 failed as expected\n+assertions: 1547 | 1395 passed | 131 failed | 21 failed as expected\n \ndiff --git a/projects/SelfTest/Baselines/console.sw.approved.txt b/projects/SelfTest/Baselines/console.sw.approved.txt\nindex cd65bc1709..3ff1e189af 100644\n--- a/projects/SelfTest/Baselines/console.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/console.sw.approved.txt\n@@ -6954,6 +6954,78 @@ with expansion:\n   \"colour mode must be one of: auto, yes or no. 'wrong' not recognised\"\n   contains: \"colour mode must be one of\"\n \n+-------------------------------------------------------------------------------\n+Process can be configured on command line\n+  Benchmark options\n+  samples\n+-------------------------------------------------------------------------------\n+CmdLine.tests.cpp:<line number>\n+...............................................................................\n+\n+CmdLine.tests.cpp:<line number>: PASSED:\n+  CHECK( cli.parse({ \"test\", \"--benchmark-samples=200\" }) )\n+with expansion:\n+  {?}\n+\n+CmdLine.tests.cpp:<line number>: PASSED:\n+  REQUIRE( config.benchmarkSamples == 200 )\n+with expansion:\n+  200 == 200\n+\n+-------------------------------------------------------------------------------\n+Process can be configured on command line\n+  Benchmark options\n+  resamples\n+-------------------------------------------------------------------------------\n+CmdLine.tests.cpp:<line number>\n+...............................................................................\n+\n+CmdLine.tests.cpp:<line number>: PASSED:\n+  CHECK( cli.parse({ \"test\", \"--benchmark-resamples=20000\" }) )\n+with expansion:\n+  {?}\n+\n+CmdLine.tests.cpp:<line number>: PASSED:\n+  REQUIRE( config.benchmarkResamples == 20000 )\n+with expansion:\n+  20000 (0x<hex digits>) == 20000 (0x<hex digits>)\n+\n+-------------------------------------------------------------------------------\n+Process can be configured on command line\n+  Benchmark options\n+  resamples\n+-------------------------------------------------------------------------------\n+CmdLine.tests.cpp:<line number>\n+...............................................................................\n+\n+CmdLine.tests.cpp:<line number>: PASSED:\n+  CHECK( cli.parse({ \"test\", \"--benchmark-confidence-interval=0.99\" }) )\n+with expansion:\n+  {?}\n+\n+CmdLine.tests.cpp:<line number>: PASSED:\n+  REQUIRE( config.benchmarkConfidenceInterval == Catch::Detail::Approx(0.99) )\n+with expansion:\n+  0.99 == Approx( 0.99 )\n+\n+-------------------------------------------------------------------------------\n+Process can be configured on command line\n+  Benchmark options\n+  resamples\n+-------------------------------------------------------------------------------\n+CmdLine.tests.cpp:<line number>\n+...............................................................................\n+\n+CmdLine.tests.cpp:<line number>: PASSED:\n+  CHECK( cli.parse({ \"test\", \"--benchmark-no-analysis\" }) )\n+with expansion:\n+  {?}\n+\n+CmdLine.tests.cpp:<line number>: PASSED:\n+  REQUIRE( config.benchmarkNoAnalysis )\n+with expansion:\n+  true\n+\n -------------------------------------------------------------------------------\n Product with differing arities - std::tuple<int, double, float>\n -------------------------------------------------------------------------------\n@@ -12219,5 +12291,5 @@ Misc.tests.cpp:<line number>: PASSED:\n \n ===============================================================================\n test cases:  289 |  199 passed |  86 failed |  4 failed as expected\n-assertions: 1556 | 1387 passed | 148 failed | 21 failed as expected\n+assertions: 1564 | 1395 passed | 148 failed | 21 failed as expected\n \ndiff --git a/projects/SelfTest/Baselines/junit.sw.approved.txt b/projects/SelfTest/Baselines/junit.sw.approved.txt\nindex 94f0138552..4592a90c9a 100644\n--- a/projects/SelfTest/Baselines/junit.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/junit.sw.approved.txt\n@@ -1,7 +1,7 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <testsuitesloose text artifact\n >\n-  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"132\" tests=\"1557\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n+  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"132\" tests=\"1565\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n     <properties>\n       <property name=\"filters\" value=\"~[!nonportable]~[!benchmark]~[approvals]\"/>\n       <property name=\"random-seed\" value=\"1\"/>\n@@ -648,6 +648,10 @@ Message.tests.cpp:<line number>\n     <testcase classname=\"<exe-name>.global\" name=\"Process can be configured on command line/use-colour/yes\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Process can be configured on command line/use-colour/no\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Process can be configured on command line/use-colour/error\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"Process can be configured on command line/Benchmark options/samples\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"Process can be configured on command line/Benchmark options/resamples\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"Process can be configured on command line/Benchmark options/resamples\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"Process can be configured on command line/Benchmark options/resamples\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Product with differing arities - std::tuple&lt;int, double, float>\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Product with differing arities - std::tuple&lt;int, double>\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Product with differing arities - std::tuple&lt;int>\" time=\"{duration}\"/>\ndiff --git a/projects/SelfTest/Baselines/xml.sw.approved.txt b/projects/SelfTest/Baselines/xml.sw.approved.txt\nindex dd2c3f4a96..0d306b2e52 100644\n--- a/projects/SelfTest/Baselines/xml.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/xml.sw.approved.txt\n@@ -8669,6 +8669,94 @@ Nor would this\n         </Section>\n         <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n       </Section>\n+      <Section name=\"Benchmark options\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n+        <Section name=\"samples\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n+          <Expression success=\"true\" type=\"CHECK\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n+            <Original>\n+              cli.parse({ \"test\", \"--benchmark-samples=200\" })\n+            </Original>\n+            <Expanded>\n+              {?}\n+            </Expanded>\n+          </Expression>\n+          <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n+            <Original>\n+              config.benchmarkSamples == 200\n+            </Original>\n+            <Expanded>\n+              200 == 200\n+            </Expanded>\n+          </Expression>\n+          <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+        </Section>\n+        <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n+      <Section name=\"Benchmark options\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n+        <Section name=\"resamples\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n+          <Expression success=\"true\" type=\"CHECK\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n+            <Original>\n+              cli.parse({ \"test\", \"--benchmark-resamples=20000\" })\n+            </Original>\n+            <Expanded>\n+              {?}\n+            </Expanded>\n+          </Expression>\n+          <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n+            <Original>\n+              config.benchmarkResamples == 20000\n+            </Original>\n+            <Expanded>\n+              20000 (0x<hex digits>) == 20000 (0x<hex digits>)\n+            </Expanded>\n+          </Expression>\n+          <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+        </Section>\n+        <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n+      <Section name=\"Benchmark options\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n+        <Section name=\"resamples\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n+          <Expression success=\"true\" type=\"CHECK\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n+            <Original>\n+              cli.parse({ \"test\", \"--benchmark-confidence-interval=0.99\" })\n+            </Original>\n+            <Expanded>\n+              {?}\n+            </Expanded>\n+          </Expression>\n+          <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n+            <Original>\n+              config.benchmarkConfidenceInterval == Catch::Detail::Approx(0.99)\n+            </Original>\n+            <Expanded>\n+              0.99 == Approx( 0.99 )\n+            </Expanded>\n+          </Expression>\n+          <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+        </Section>\n+        <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n+      <Section name=\"Benchmark options\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n+        <Section name=\"resamples\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n+          <Expression success=\"true\" type=\"CHECK\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n+            <Original>\n+              cli.parse({ \"test\", \"--benchmark-no-analysis\" })\n+            </Original>\n+            <Expanded>\n+              {?}\n+            </Expanded>\n+          </Expression>\n+          <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n+            <Original>\n+              config.benchmarkNoAnalysis\n+            </Original>\n+            <Expanded>\n+              true\n+            </Expanded>\n+          </Expression>\n+          <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+        </Section>\n+        <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n       <OverallResult success=\"true\"/>\n     </TestCase>\n     <TestCase name=\"Product with differing arities - std::tuple&lt;int, double, float>\" tags=\"[product][template]\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n@@ -14586,7 +14674,7 @@ loose text artifact\n       </Section>\n       <OverallResult success=\"true\"/>\n     </TestCase>\n-    <OverallResults successes=\"1387\" failures=\"149\" expectedFailures=\"21\"/>\n+    <OverallResults successes=\"1395\" failures=\"149\" expectedFailures=\"21\"/>\n   </Group>\n-  <OverallResults successes=\"1387\" failures=\"148\" expectedFailures=\"21\"/>\n+  <OverallResults successes=\"1395\" failures=\"148\" expectedFailures=\"21\"/>\n </Catch>\n", "test_patch": "diff --git a/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp b/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp\nindex 9b5b0ed7c8..f4d1299ae6 100644\n--- a/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp\n+++ b/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp\n@@ -462,4 +462,30 @@ TEST_CASE( \"Process can be configured on command line\", \"[config][command-line]\"\n #endif\n         }\n     }\n+\n+    SECTION(\"Benchmark options\") {\n+        SECTION(\"samples\") {\n+            CHECK(cli.parse({ \"test\", \"--benchmark-samples=200\" }));\n+\n+            REQUIRE(config.benchmarkSamples == 200);\n+        }\n+        \n+        SECTION(\"resamples\") {\n+            CHECK(cli.parse({ \"test\", \"--benchmark-resamples=20000\" }));\n+\n+            REQUIRE(config.benchmarkResamples == 20000);\n+        }\n+\n+        SECTION(\"resamples\") {\n+            CHECK(cli.parse({ \"test\", \"--benchmark-confidence-interval=0.99\" }));\n+\n+            REQUIRE(config.benchmarkConfidenceInterval == Catch::Detail::Approx(0.99));\n+        }\n+\n+        SECTION(\"resamples\") {\n+            CHECK(cli.parse({ \"test\", \"--benchmark-no-analysis\" }));\n+\n+            REQUIRE(config.benchmarkNoAnalysis);\n+        }\n+    }\n }\ndiff --git a/projects/SelfTest/IntrospectiveTests/InternalBenchmark.tests.cpp b/projects/SelfTest/IntrospectiveTests/InternalBenchmark.tests.cpp\nnew file mode 100644\nindex 0000000000..d17998d870\n--- /dev/null\n+++ b/projects/SelfTest/IntrospectiveTests/InternalBenchmark.tests.cpp\n@@ -0,0 +1,405 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+#include \"catch.hpp\"\n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+namespace {\n+    struct manual_clock {\n+    public:\n+        using duration = std::chrono::nanoseconds;\n+        using time_point = std::chrono::time_point<manual_clock, duration>;\n+        using rep = duration::rep;\n+        using period = duration::period;\n+        enum { is_steady = true };\n+\n+        static time_point now() {\n+            return time_point(duration(tick()));\n+        }\n+\n+        static void advance(int ticks = 1) {\n+            tick() += ticks;\n+        }\n+\n+    private:\n+        static rep& tick() {\n+            static rep the_tick = 0;\n+            return the_tick;\n+        }\n+    };\n+\n+    struct counting_clock {\n+    public:\n+        using duration = std::chrono::nanoseconds;\n+        using time_point = std::chrono::time_point<counting_clock, duration>;\n+        using rep = duration::rep;\n+        using period = duration::period;\n+        enum { is_steady = true };\n+\n+        static time_point now() {\n+            static rep ticks = 0;\n+            return time_point(duration(ticks += rate()));\n+        }\n+\n+        static void set_rate(rep new_rate) { rate() = new_rate; }\n+\n+    private:\n+        static rep& rate() {\n+            static rep the_rate = 1;\n+            return the_rate;\n+        }\n+    };\n+\n+    struct TestChronometerModel : Catch::Benchmark::Detail::ChronometerConcept {\n+        int started = 0;\n+        int finished = 0;\n+\n+        void start() override { ++started; }\n+        void finish() override { ++finished; }\n+    };\n+} // namespace\n+\n+TEST_CASE(\"warmup\", \"[benchmark]\") {\n+    auto rate = 1000;\n+    counting_clock::set_rate(rate);\n+\n+    auto start = counting_clock::now();\n+    auto iterations = Catch::Benchmark::Detail::warmup<counting_clock>();\n+    auto end = counting_clock::now();\n+\n+    REQUIRE((iterations * rate) > Catch::Benchmark::Detail::warmup_time.count());\n+    REQUIRE((end - start) > Catch::Benchmark::Detail::warmup_time);\n+}\n+\n+TEST_CASE(\"resolution\", \"[benchmark]\") {\n+    auto rate = 1000;\n+    counting_clock::set_rate(rate);\n+\n+    size_t count = 10;\n+    auto res = Catch::Benchmark::Detail::resolution<counting_clock>(static_cast<int>(count));\n+\n+    REQUIRE(res.size() == count);\n+\n+    for (size_t i = 1; i < count; ++i) {\n+        REQUIRE(res[i] == rate);\n+    }\n+}\n+\n+TEST_CASE(\"estimate_clock_resolution\", \"[benchmark]\") {\n+    auto rate = 1000;\n+    counting_clock::set_rate(rate);\n+\n+    int iters = 160000;\n+    auto res = Catch::Benchmark::Detail::estimate_clock_resolution<counting_clock>(iters);\n+\n+    REQUIRE(res.mean.count() == rate);\n+    REQUIRE(res.outliers.total() == 0);\n+}\n+\n+TEST_CASE(\"benchmark function call\", \"[benchmark]\") {\n+    SECTION(\"without chronometer\") {\n+        auto called = 0;\n+        auto model = TestChronometerModel{};\n+        auto meter = Catch::Benchmark::Chronometer{ model, 1 };\n+        auto fn = Catch::Benchmark::Detail::BenchmarkFunction{ [&] {\n+                CHECK(model.started == 1);\n+                CHECK(model.finished == 0);\n+                ++called;\n+            } };\n+\n+        fn(meter);\n+\n+        CHECK(model.started == 1);\n+        CHECK(model.finished == 1);\n+        CHECK(called == 1);\n+    }\n+\n+    SECTION(\"with chronometer\") {\n+        auto called = 0;\n+        auto model = TestChronometerModel{};\n+        auto meter = Catch::Benchmark::Chronometer{ model, 1 };\n+        auto fn = Catch::Benchmark::Detail::BenchmarkFunction{ [&](Catch::Benchmark::Chronometer) {\n+                CHECK(model.started == 0);\n+                CHECK(model.finished == 0);\n+                ++called;\n+            } };\n+\n+        fn(meter);\n+\n+        CHECK(model.started == 0);\n+        CHECK(model.finished == 0);\n+        CHECK(called == 1);\n+    }\n+}\n+\n+TEST_CASE(\"uniform samples\", \"[benchmark]\") {\n+    std::vector<double> samples(100);\n+    std::fill(samples.begin(), samples.end(), 23);\n+\n+    using it = std::vector<double>::iterator;\n+    auto e = Catch::Benchmark::Detail::bootstrap(0.95, samples.begin(), samples.end(), samples, [](it a, it b) {\n+        auto sum = std::accumulate(a, b, 0.);\n+        return sum / (b - a);\n+    });\n+    CHECK(e.point == 23);\n+    CHECK(e.upper_bound == 23);\n+    CHECK(e.lower_bound == 23);\n+    CHECK(e.confidence_interval == 0.95);\n+}\n+\n+\n+TEST_CASE(\"normal_cdf\", \"[benchmark]\") {\n+    using Catch::Benchmark::Detail::normal_cdf;\n+    CHECK(normal_cdf(0.000000) == Approx(0.50000000000000000));\n+    CHECK(normal_cdf(1.000000) == Approx(0.84134474606854293));\n+    CHECK(normal_cdf(-1.000000) == Approx(0.15865525393145705));\n+    CHECK(normal_cdf(2.809729) == Approx(0.99752083845315409));\n+    CHECK(normal_cdf(-1.352570) == Approx(0.08809652095066035));\n+}\n+\n+TEST_CASE(\"erfc_inv\", \"[benchmark]\") {\n+    using Catch::Benchmark::Detail::erfc_inv;\n+    CHECK(erfc_inv(1.103560) == Approx(-0.09203687623843015));\n+    CHECK(erfc_inv(1.067400) == Approx(-0.05980291115763361));\n+    CHECK(erfc_inv(0.050000) == Approx(1.38590382434967796));\n+}\n+\n+TEST_CASE(\"normal_quantile\", \"[benchmark]\") {\n+    using Catch::Benchmark::Detail::normal_quantile;\n+    CHECK(normal_quantile(0.551780) == Approx(0.13015979861484198));\n+    CHECK(normal_quantile(0.533700) == Approx(0.08457408802851875));\n+    CHECK(normal_quantile(0.025000) == Approx(-1.95996398454005449));\n+}\n+\n+\n+TEST_CASE(\"mean\", \"[benchmark]\") {\n+    std::vector<double> x{ 10., 20., 14., 16., 30., 24. };\n+\n+    auto m = Catch::Benchmark::Detail::mean(x.begin(), x.end());\n+\n+    REQUIRE(m == 19.);\n+}\n+\n+TEST_CASE(\"weighted_average_quantile\", \"[benchmark]\") {\n+    std::vector<double> x{ 10., 20., 14., 16., 30., 24. };\n+\n+    auto q1 = Catch::Benchmark::Detail::weighted_average_quantile(1, 4, x.begin(), x.end());\n+    auto med = Catch::Benchmark::Detail::weighted_average_quantile(1, 2, x.begin(), x.end());\n+    auto q3 = Catch::Benchmark::Detail::weighted_average_quantile(3, 4, x.begin(), x.end());\n+\n+    REQUIRE(q1 == 14.5);\n+    REQUIRE(med == 18.);\n+    REQUIRE(q3 == 23.);\n+}\n+\n+TEST_CASE(\"classify_outliers\", \"[benchmark]\") {\n+    auto require_outliers = [](Catch::Benchmark::OutlierClassification o, int los, int lom, int him, int his) {\n+        REQUIRE(o.low_severe == los);\n+        REQUIRE(o.low_mild == lom);\n+        REQUIRE(o.high_mild == him);\n+        REQUIRE(o.high_severe == his);\n+        REQUIRE(o.total() == los + lom + him + his);\n+    };\n+\n+    SECTION(\"none\") {\n+        std::vector<double> x{ 10., 20., 14., 16., 30., 24. };\n+\n+        auto o = Catch::Benchmark::Detail::classify_outliers(x.begin(), x.end());\n+\n+        REQUIRE(o.samples_seen == static_cast<int>(x.size()));\n+        require_outliers(o, 0, 0, 0, 0);\n+    }\n+    SECTION(\"low severe\") {\n+        std::vector<double> x{ -12., 20., 14., 16., 30., 24. };\n+\n+        auto o = Catch::Benchmark::Detail::classify_outliers(x.begin(), x.end());\n+\n+        REQUIRE(o.samples_seen == static_cast<int>(x.size()));\n+        require_outliers(o, 1, 0, 0, 0);\n+    }\n+    SECTION(\"low mild\") {\n+        std::vector<double> x{ 1., 20., 14., 16., 30., 24. };\n+\n+        auto o = Catch::Benchmark::Detail::classify_outliers(x.begin(), x.end());\n+\n+        REQUIRE(o.samples_seen == static_cast<int>(x.size()));\n+        require_outliers(o, 0, 1, 0, 0);\n+    }\n+    SECTION(\"high mild\") {\n+        std::vector<double> x{ 10., 20., 14., 16., 36., 24. };\n+\n+        auto o = Catch::Benchmark::Detail::classify_outliers(x.begin(), x.end());\n+\n+        REQUIRE(o.samples_seen == static_cast<int>(x.size()));\n+        require_outliers(o, 0, 0, 1, 0);\n+    }\n+    SECTION(\"high severe\") {\n+        std::vector<double> x{ 10., 20., 14., 16., 49., 24. };\n+\n+        auto o = Catch::Benchmark::Detail::classify_outliers(x.begin(), x.end());\n+\n+        REQUIRE(o.samples_seen == static_cast<int>(x.size()));\n+        require_outliers(o, 0, 0, 0, 1);\n+    }\n+    SECTION(\"mixed\") {\n+        std::vector<double> x{ -20., 20., 14., 16., 39., 24. };\n+\n+        auto o = Catch::Benchmark::Detail::classify_outliers(x.begin(), x.end());\n+\n+        REQUIRE(o.samples_seen == static_cast<int>(x.size()));\n+        require_outliers(o, 1, 0, 1, 0);\n+    }\n+}\n+\n+TEST_CASE(\"analyse\", \"[benchmark]\") {\n+    Catch::ConfigData data{};\n+    data.benchmarkConfidenceInterval = 0.95;\n+    data.benchmarkNoAnalysis = false;\n+    data.benchmarkResamples = 1000;\n+    data.benchmarkSamples = 99;\n+    Catch::Config config{data};\n+\n+    using Duration = Catch::Benchmark::FloatDuration<Catch::Benchmark::default_clock>;\n+\n+    Catch::Benchmark::Environment<Duration> env;\n+    std::vector<Duration> samples(99);\n+    for (size_t i = 0; i < samples.size(); ++i) {\n+        samples[i] = Duration(23 + (i % 3 - 1));\n+    }\n+\n+    auto analysis = Catch::Benchmark::Detail::analyse(config, env, samples.begin(), samples.end());\n+    CHECK(analysis.mean.point.count() == 23);\n+    CHECK(analysis.mean.lower_bound.count() < 23);\n+    CHECK(analysis.mean.lower_bound.count() > 22);\n+    CHECK(analysis.mean.upper_bound.count() > 23);\n+    CHECK(analysis.mean.upper_bound.count() < 24);\n+\n+    CHECK(analysis.standard_deviation.point.count() > 0.5);\n+    CHECK(analysis.standard_deviation.point.count() < 1);\n+    CHECK(analysis.standard_deviation.lower_bound.count() > 0.5);\n+    CHECK(analysis.standard_deviation.lower_bound.count() < 1);\n+    CHECK(analysis.standard_deviation.upper_bound.count() > 0.5);\n+    CHECK(analysis.standard_deviation.upper_bound.count() < 1);\n+\n+    CHECK(analysis.outliers.total() == 0);\n+    CHECK(analysis.outliers.low_mild == 0);\n+    CHECK(analysis.outliers.low_severe == 0);\n+    CHECK(analysis.outliers.high_mild == 0);\n+    CHECK(analysis.outliers.high_severe == 0);\n+    CHECK(analysis.outliers.samples_seen == samples.size());\n+\n+    CHECK(analysis.outlier_variance < 0.5);\n+    CHECK(analysis.outlier_variance > 0);\n+}\n+\n+TEST_CASE(\"analyse no analysis\", \"[benchmark]\") {\n+    Catch::ConfigData data{};\n+    data.benchmarkConfidenceInterval = 0.95;\n+    data.benchmarkNoAnalysis = true;\n+    data.benchmarkResamples = 1000;\n+    data.benchmarkSamples = 99;\n+    Catch::Config config{ data };\n+\n+    using Duration = Catch::Benchmark::FloatDuration<Catch::Benchmark::default_clock>;\n+\n+    Catch::Benchmark::Environment<Duration> env;\n+    std::vector<Duration> samples(99);\n+    for (size_t i = 0; i < samples.size(); ++i) {\n+        samples[i] = Duration(23 + (i % 3 - 1));\n+    }\n+\n+    auto analysis = Catch::Benchmark::Detail::analyse(config, env, samples.begin(), samples.end());\n+    CHECK(analysis.mean.point.count() == 23);\n+    CHECK(analysis.mean.lower_bound.count() == 23);\n+    CHECK(analysis.mean.upper_bound.count() == 23);\n+\n+    CHECK(analysis.standard_deviation.point.count() == 0);\n+    CHECK(analysis.standard_deviation.lower_bound.count() == 0);\n+    CHECK(analysis.standard_deviation.upper_bound.count() == 0);\n+\n+    CHECK(analysis.outliers.total() == 0);\n+    CHECK(analysis.outliers.low_mild == 0);\n+    CHECK(analysis.outliers.low_severe == 0);\n+    CHECK(analysis.outliers.high_mild == 0);\n+    CHECK(analysis.outliers.high_severe == 0);\n+    CHECK(analysis.outliers.samples_seen == 0);\n+\n+    CHECK(analysis.outlier_variance == 0);\n+}\n+\n+TEST_CASE(\"run_for_at_least, int\", \"[benchmark]\") {\n+    manual_clock::duration time(100);\n+\n+    int old_x = 1;\n+    auto Timing = Catch::Benchmark::Detail::run_for_at_least<manual_clock>(time, 1, [&old_x](int x) -> int {\n+        CHECK(x >= old_x);\n+        manual_clock::advance(x);\n+        old_x = x;\n+        return x + 17;\n+    });\n+\n+    REQUIRE(Timing.elapsed >= time);\n+    REQUIRE(Timing.result == Timing.iterations + 17);\n+    REQUIRE(Timing.iterations >= time.count());\n+}\n+\n+TEST_CASE(\"run_for_at_least, chronometer\", \"[benchmark]\") {\n+    manual_clock::duration time(100);\n+\n+    int old_runs = 1;\n+    auto Timing = Catch::Benchmark::Detail::run_for_at_least<manual_clock>(time, 1, [&old_runs](Catch::Benchmark::Chronometer meter) -> int {\n+        CHECK(meter.runs() >= old_runs);\n+        manual_clock::advance(100);\n+        meter.measure([] {\n+            manual_clock::advance(1);\n+        });\n+        old_runs = meter.runs();\n+        return meter.runs() + 17;\n+    });\n+\n+    REQUIRE(Timing.elapsed >= time);\n+    REQUIRE(Timing.result == Timing.iterations + 17);\n+    REQUIRE(Timing.iterations >= time.count());\n+}\n+\n+\n+TEST_CASE(\"measure\", \"[benchmark]\") {\n+    auto r = Catch::Benchmark::Detail::measure<manual_clock>([](int x) -> int {\n+        CHECK(x == 17);\n+        manual_clock::advance(42);\n+        return 23;\n+    }, 17);\n+    auto s = Catch::Benchmark::Detail::measure<manual_clock>([](int x) -> int {\n+        CHECK(x == 23);\n+        manual_clock::advance(69);\n+        return 17;\n+    }, 23);\n+\n+    CHECK(r.elapsed.count() == 42);\n+    CHECK(r.result == 23);\n+    CHECK(r.iterations == 1);\n+\n+    CHECK(s.elapsed.count() == 69);\n+    CHECK(s.result == 17);\n+    CHECK(s.iterations == 1);\n+}\n+\n+TEST_CASE(\"run benchmark\", \"[benchmark]\") {\n+    counting_clock::set_rate(1000);\n+    auto start = counting_clock::now();\n+    \n+    Catch::Benchmark::Benchmark bench{ \"Test Benchmark\", [](Catch::Benchmark::Chronometer meter) {\n+        counting_clock::set_rate(100000);\n+        meter.measure([] { return counting_clock::now(); });\n+    } };\n+\n+    bench.run<counting_clock>();\n+    auto end = counting_clock::now();\n+\n+    CHECK((end - start).count() == 2867251000);\n+}\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\ndiff --git a/projects/SelfTest/UsageTests/Benchmark.tests.cpp b/projects/SelfTest/UsageTests/Benchmark.tests.cpp\nindex ddf6950457..24fda0133b 100644\n--- a/projects/SelfTest/UsageTests/Benchmark.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Benchmark.tests.cpp\n@@ -2,42 +2,129 @@\n \n #include <map>\n \n-TEST_CASE( \"benchmarked\", \"[!benchmark]\" ) {\n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+namespace {\n+    std::uint64_t Fibonacci(std::uint64_t number) {\n+        return number < 2 ? 1 : Fibonacci(number - 1) + Fibonacci(number - 2);\n+    }\n+}\n+\n+TEST_CASE(\"Benchmark Fibonacci\", \"[!benchmark]\") {\n+    CHECK(Fibonacci(0) == 1);\n+    // some more asserts..\n+    CHECK(Fibonacci(5) == 8);\n+    // some more asserts..\n+\n+    BENCHMARK(\"Fibonacci 20\") {\n+        return Fibonacci(20);\n+    };\n+\n+    BENCHMARK(\"Fibonacci 25\") {\n+        return Fibonacci(25);\n+    };\n \n+    BENCHMARK(\"Fibonacci 30\") {\n+        return Fibonacci(30);\n+    };\n+\n+    BENCHMARK(\"Fibonacci 35\") {\n+        return Fibonacci(35);\n+    };\n+}\n+\n+TEST_CASE(\"Benchmark containers\", \"[!benchmark]\") {\n     static const int size = 100;\n \n     std::vector<int> v;\n     std::map<int, int> m;\n \n-    BENCHMARK( \"Load up a vector\" ) {\n-        v = std::vector<int>();\n-        for(int i =0; i < size; ++i )\n-            v.push_back( i );\n-    }\n-    REQUIRE( v.size() == size );\n+    SECTION(\"without generator\") {\n+        BENCHMARK(\"Load up a vector\") {\n+            v = std::vector<int>();\n+            for (int i = 0; i < size; ++i)\n+                v.push_back(i);\n+        };\n+        REQUIRE(v.size() == size);\n \n-    BENCHMARK( \"Load up a map\" ) {\n-        m = std::map<int, int>();\n-        for(int i =0; i < size; ++i )\n-            m.insert( { i, i+1 } );\n-    }\n-    REQUIRE( m.size() == size );\n+        // test optimizer control\n+        BENCHMARK(\"Add up a vector's content\") {\n+            uint64_t add = 0;\n+            for (int i = 0; i < size; ++i)\n+                add += v[i];\n+            return add;\n+        };\n+\n+        BENCHMARK(\"Load up a map\") {\n+            m = std::map<int, int>();\n+            for (int i = 0; i < size; ++i)\n+                m.insert({ i, i + 1 });\n+        };\n+        REQUIRE(m.size() == size);\n+\n+        BENCHMARK(\"Reserved vector\") {\n+            v = std::vector<int>();\n+            v.reserve(size);\n+            for (int i = 0; i < size; ++i)\n+                v.push_back(i);\n+        };\n+        REQUIRE(v.size() == size);\n+\n+        BENCHMARK(\"Resized vector\") {\n+            v = std::vector<int>();\n+            v.resize(size);\n+            for (int i = 0; i < size; ++i)\n+                v[i] = i;\n+        };\n+        REQUIRE(v.size() == size);\n+\n+        int array[size];\n+        BENCHMARK(\"A fixed size array that should require no allocations\") {\n+            for (int i = 0; i < size; ++i)\n+                array[i] = i;\n+        };\n+        int sum = 0;\n+        for (int i = 0; i < size; ++i)\n+            sum += array[i];\n+        REQUIRE(sum > size);\n+\n+        SECTION(\"XYZ\") {\n+\n+            BENCHMARK_ADVANCED(\"Load up vector with chronometer\")(Catch::Benchmark::Chronometer meter) {\n+                std::vector<int> k;\n+                meter.measure([&](int idx) {\n+                    k = std::vector<int>();\n+                    for (int i = 0; i < size; ++i)\n+                        k.push_back(idx);\n+                });\n+                REQUIRE(k.size() == size);\n+            };\n+\n+            int runs = 0;\n+            BENCHMARK(\"Fill vector indexed\", benchmarkIndex) {\n+                v = std::vector<int>();\n+                v.resize(size);\n+                for (int i = 0; i < size; ++i)\n+                    v[i] = benchmarkIndex;\n+                runs = benchmarkIndex;\n+            };\n \n-    BENCHMARK( \"Reserved vector\" ) {\n-        v = std::vector<int>();\n-        v.reserve(size);\n-        for(int i =0; i < size; ++i )\n-            v.push_back( i );\n+            for (size_t i = 0; i < v.size(); ++i) {\n+                REQUIRE(v[i] == runs);\n+            }\n+        }\n     }\n-    REQUIRE( v.size() == size );\n \n-    int array[size];\n-    BENCHMARK( \"A fixed size array that should require no allocations\" ) {\n-        for(int i =0; i < size; ++i )\n-            array[i] = i;\n+    SECTION(\"with generator\") {\n+        auto generated = GENERATE(range(0, 10));\n+        BENCHMARK(\"Fill vector generated\") {\n+            v = std::vector<int>();\n+            v.resize(size);\n+            for (int i = 0; i < size; ++i)\n+                v[i] = generated;\n+        };\n+        for (size_t i = 0; i < v.size(); ++i) {\n+            REQUIRE(v[i] == generated);\n+        }\n     }\n-    int sum = 0;\n-    for(int i =0; i < size; ++i )\n-        sum += array[i];\n-    REQUIRE( sum > size );\n }\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n", "fixed_tests": {"approvaltests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "noassertions": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtags": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "notest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtestnamesonly": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listreporters": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "p2p_tests": {}, "f2p_tests": {}, "s2p_tests": {}, "n2p_tests": {"approvaltests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "noassertions": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtags": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "notest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtestnamesonly": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listreporters": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "run_result": {"passed_count": 10, "failed_count": 0, "skipped_count": 0, "passed_tests": ["approvaltests", "noassertions", "runtests", "listtags", "listreporters", "listtests", "notest", "filteredsection-1", "filteredsection-2", "listtestnamesonly"], "failed_tests": [], "skipped_tests": []}, "test_patch_result": {"passed_count": 0, "failed_count": 0, "skipped_count": 0, "passed_tests": [], "failed_tests": [], "skipped_tests": []}, "fix_patch_result": {"passed_count": 10, "failed_count": 0, "skipped_count": 0, "passed_tests": ["approvaltests", "noassertions", "runtests", "listtags", "listreporters", "listtests", "notest", "filteredsection-1", "filteredsection-2", "listtestnamesonly"], "failed_tests": [], "skipped_tests": []}, "instance_id": "catchorg__Catch2-1616"}
{"org": "catchorg", "repo": "Catch2", "number": 1614, "state": "closed", "title": "Allow custom precision in error reports for floating-point numbers", "body": "## Description\r\nPer #1612, this change allows the user to set custom precision on floating-point test messages. I did implement the unit test gestured at in the issue, but I'm not sure if you want it.\r\n\r\n## GitHub Issues\r\nCloses #1612.\r\n", "base": {"label": "catchorg:master", "ref": "master", "sha": "9c741fe96073ed620ffc032afbed1f3c789d2b68"}, "resolved_issues": [{"number": 1612, "title": "Allow custom precision in error reports for floating-point numbers", "body": "**Description**\r\nAs in [this SO Q&A](https://stackoverflow.com/q/55867570/201787), it would be nice to allow customization of the precision of floating-point values that fail. At present, the precision for float and double are hard-coded within Catch2 to 5 and 10, respectively:\r\n```cpp\r\nstd::string StringMaker<float>::convert(float value) {\r\n    return fpToString(value, 5) + 'f';\r\n}\r\nstd::string StringMaker<double>::convert(double value) {\r\n    return fpToString(value, 10);\r\n}\r\n```\r\nSometimes things will fail (even with `Approx()`), but the precision of the failure message doesn't show enough precision to be meaningful.\r\n```\r\nprog.cc:22: FAILED:\r\n  REQUIRE( TestType(0) == std::numeric_limits<TestType>::epsilon() )\r\nwith expansion:\r\n  0.0f == 0.0f\r\n```\r\nThe proposal here is to add a `setPrecision()` function to allow the user to control this. I have prototyped this, which you can see running [live on Wandbox](https://wandbox.org/permlink/mZXPLEuET5ZeTg1t). Here's the test:\r\n```cpp\r\nTEMPLATE_TEST_CASE( \"Double, double, toil and trouble\", \"[double]\", float, double ) \r\n{\r\n    const auto precision = GENERATE( -1, 0, 3, std::numeric_limits<TestType>::max_digits10 );\r\n\r\n    if( precision >= 0 )\r\n    {\r\n        Catch::StringMaker<TestType>::setPrecision( precision );\r\n    }\r\n    \r\n    // Expected to fail to demonstrate the problem\r\n    REQUIRE( TestType(0) == std::numeric_limits<TestType>::epsilon() ); \r\n}\r\n```\r\nThe output shows as expected for floats and doubles. For instance:\r\n```\r\nprog.cc:15: FAILED:\r\n  REQUIRE( TestType(0) == std::numeric_limits<TestType>::epsilon() )\r\nwith expansion:\r\n  0.0f == 0.000000119f\r\n```\r\nMaking a unit test for this is a little iffy since the actual string values are dependent on the usual floating-point fuzziness. I guess it could compare string length without looking too closely at the value."}], "fix_patch": "diff --git a/docs/tostring.md b/docs/tostring.md\nindex 77322dc6b6..549f8aed9f 100644\n--- a/docs/tostring.md\n+++ b/docs/tostring.md\n@@ -7,6 +7,8 @@\n [Catch::is_range specialisation](#catchis_range-specialisation)<br>\n [Exceptions](#exceptions)<br>\n [Enums](#enums)<br>\n+[Floating point precision](#floating-point-precision)<br>\n+\n \n Catch needs to be able to convert types you use in assertions and logging expressions into strings (for logging and reporting purposes).\n Most built-in or std types are supported out of the box but there are two ways that you can tell Catch how to convert your own types (or other, third-party types) into strings.\n@@ -104,6 +106,22 @@ TEST_CASE() {\n }\n ```\n \n+## Floating point precision\n+\n+Catch provides a built-in `StringMaker` specialization for both `float`\n+`double`. By default, it uses what we think is a reasonable precision,\n+but you can customize it by modifying the `precision` static variable\n+inside the `StringMaker` specialization, like so:\n+\n+```cpp\n+        Catch::StringMaker<float>::precision = 15;\n+        const float testFloat1 = 1.12345678901234567899f;\n+        const float testFloat2 = 1.12345678991234567899f;\n+        REQUIRE(testFloat1 == testFloat2);\n+```\n+\n+This assertion will fail and print out the `testFloat1` and `testFloat2`\n+to 15 decimal places.\n \n ---\n \ndiff --git a/include/internal/catch_tostring.cpp b/include/internal/catch_tostring.cpp\nindex b857d3fbcd..f59676e77b 100644\n--- a/include/internal/catch_tostring.cpp\n+++ b/include/internal/catch_tostring.cpp\n@@ -234,11 +234,16 @@ std::string StringMaker<std::nullptr_t>::convert(std::nullptr_t) {\n     return \"nullptr\";\n }\n \n+int StringMaker<float>::precision = 5;\n+   \n std::string StringMaker<float>::convert(float value) {\n-    return fpToString(value, 5) + 'f';\n+    return fpToString(value, precision) + 'f';\n }\n+\n+int StringMaker<double>::precision = 10;\n+    \n std::string StringMaker<double>::convert(double value) {\n-    return fpToString(value, 10);\n+    return fpToString(value, precision);\n }\n \n std::string ratio_string<std::atto>::symbol() { return \"a\"; }\ndiff --git a/include/internal/catch_tostring.h b/include/internal/catch_tostring.h\nindex 52634a8c9a..cb248ea9ab 100644\n--- a/include/internal/catch_tostring.h\n+++ b/include/internal/catch_tostring.h\n@@ -261,10 +261,13 @@ namespace Catch {\n     template<>\n     struct StringMaker<float> {\n         static std::string convert(float value);\n+        static int precision;\n     };\n+\n     template<>\n     struct StringMaker<double> {\n         static std::string convert(double value);\n+        static int precision;\n     };\n \n     template <typename T>\ndiff --git a/projects/SelfTest/Baselines/compact.sw.approved.txt b/projects/SelfTest/Baselines/compact.sw.approved.txt\nindex 259954e4b8..8447e839fd 100644\n--- a/projects/SelfTest/Baselines/compact.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/compact.sw.approved.txt\n@@ -859,6 +859,10 @@ Condition.tests.cpp:<line number>: passed: cpc != 0 for: 0x<hex digits> != 0\n Condition.tests.cpp:<line number>: passed: returnsNull() == 0 for: {null string} == 0\n Condition.tests.cpp:<line number>: passed: returnsConstNull() == 0 for: {null string} == 0\n Condition.tests.cpp:<line number>: passed: 0 != p for: 0 != 0x<hex digits>\n+ToStringGeneral.tests.cpp:<line number>: passed: str1.size() == 3 + 5 for: 8 == 8\n+ToStringGeneral.tests.cpp:<line number>: passed: str2.size() == 3 + 10 for: 13 == 13\n+ToStringGeneral.tests.cpp:<line number>: passed: str1.size() == 2 + 5 for: 7 == 7\n+ToStringGeneral.tests.cpp:<line number>: passed: str2.size() == 2 + 15 for: 17 == 17\n Matchers.tests.cpp:<line number>: passed: \"foo\", Predicate<const char*>([] (const char* const&) { return true; }) for: \"foo\" matches undescribed predicate\n CmdLine.tests.cpp:<line number>: passed: result for: {?}\n CmdLine.tests.cpp:<line number>: passed: config.processName == \"\" for: \"\" == \"\"\ndiff --git a/projects/SelfTest/Baselines/console.std.approved.txt b/projects/SelfTest/Baselines/console.std.approved.txt\nindex 0a4de92369..aa991bd403 100644\n--- a/projects/SelfTest/Baselines/console.std.approved.txt\n+++ b/projects/SelfTest/Baselines/console.std.approved.txt\n@@ -1299,6 +1299,6 @@ due to unexpected exception with message:\n   Why would you throw a std::string?\n \n ===============================================================================\n-test cases:  266 |  199 passed |  63 failed |  4 failed as expected\n-assertions: 1449 | 1304 passed | 124 failed | 21 failed as expected\n+test cases:  267 |  200 passed |  63 failed |  4 failed as expected\n+assertions: 1453 | 1308 passed | 124 failed | 21 failed as expected\n \ndiff --git a/projects/SelfTest/Baselines/console.sw.approved.txt b/projects/SelfTest/Baselines/console.sw.approved.txt\nindex 2b998afc7e..e13a6c23d1 100644\n--- a/projects/SelfTest/Baselines/console.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/console.sw.approved.txt\n@@ -6192,6 +6192,40 @@ Condition.tests.cpp:<line number>: PASSED:\n with expansion:\n   0 != 0x<hex digits>\n \n+-------------------------------------------------------------------------------\n+Precision of floating point stringification can be set\n+  Floats\n+-------------------------------------------------------------------------------\n+ToStringGeneral.tests.cpp:<line number>\n+...............................................................................\n+\n+ToStringGeneral.tests.cpp:<line number>: PASSED:\n+  CHECK( str1.size() == 3 + 5 )\n+with expansion:\n+  8 == 8\n+\n+ToStringGeneral.tests.cpp:<line number>: PASSED:\n+  REQUIRE( str2.size() == 3 + 10 )\n+with expansion:\n+  13 == 13\n+\n+-------------------------------------------------------------------------------\n+Precision of floating point stringification can be set\n+  Double\n+-------------------------------------------------------------------------------\n+ToStringGeneral.tests.cpp:<line number>\n+...............................................................................\n+\n+ToStringGeneral.tests.cpp:<line number>: PASSED:\n+  CHECK( str1.size() == 2 + 5 )\n+with expansion:\n+  7 == 7\n+\n+ToStringGeneral.tests.cpp:<line number>: PASSED:\n+  REQUIRE( str2.size() == 2 + 15 )\n+with expansion:\n+  17 == 17\n+\n -------------------------------------------------------------------------------\n Predicate matcher can accept const char*\n -------------------------------------------------------------------------------\n@@ -11389,6 +11423,6 @@ Misc.tests.cpp:<line number>\n Misc.tests.cpp:<line number>: PASSED:\n \n ===============================================================================\n-test cases:  266 |  183 passed |  79 failed |  4 failed as expected\n-assertions: 1466 | 1304 passed | 141 failed | 21 failed as expected\n+test cases:  267 |  184 passed |  79 failed |  4 failed as expected\n+assertions: 1470 | 1308 passed | 141 failed | 21 failed as expected\n \ndiff --git a/projects/SelfTest/Baselines/junit.sw.approved.txt b/projects/SelfTest/Baselines/junit.sw.approved.txt\nindex 7f4b43dbb1..a7b775336b 100644\n--- a/projects/SelfTest/Baselines/junit.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/junit.sw.approved.txt\n@@ -1,7 +1,7 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <testsuitesloose text artifact\n >\n-  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"125\" tests=\"1467\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n+  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"125\" tests=\"1471\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n     <properties>\n       <property name=\"filters\" value=\"~[!nonportable]~[!benchmark]~[approvals]\"/>\n       <property name=\"random-seed\" value=\"1\"/>\n@@ -574,6 +574,8 @@ Message.tests.cpp:<line number>\n     <testcase classname=\"<exe-name>.global\" name=\"Parse test names and tags/empty quoted name\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Parse test names and tags/quoted string followed by tag exclusion\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Pointers can be compared to null\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"Precision of floating point stringification can be set/Floats\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"Precision of floating point stringification can be set/Double\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Predicate matcher can accept const char*\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Process can be configured on command line/empty args don't cause a crash\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Process can be configured on command line/default - no arguments\" time=\"{duration}\"/>\ndiff --git a/projects/SelfTest/Baselines/xml.sw.approved.txt b/projects/SelfTest/Baselines/xml.sw.approved.txt\nindex fa078ac800..fcd6ff13f4 100644\n--- a/projects/SelfTest/Baselines/xml.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/xml.sw.approved.txt\n@@ -7778,6 +7778,47 @@ Nor would this\n       </Expression>\n       <OverallResult success=\"true\"/>\n     </TestCase>\n+    <TestCase name=\"Precision of floating point stringification can be set\" tags=\"[floatingPoint][toString]\" filename=\"projects/<exe-name>/UsageTests/ToStringGeneral.tests.cpp\" >\n+      <Section name=\"Floats\" filename=\"projects/<exe-name>/UsageTests/ToStringGeneral.tests.cpp\" >\n+        <Expression success=\"true\" type=\"CHECK\" filename=\"projects/<exe-name>/UsageTests/ToStringGeneral.tests.cpp\" >\n+          <Original>\n+            str1.size() == 3 + 5\n+          </Original>\n+          <Expanded>\n+            8 == 8\n+          </Expanded>\n+        </Expression>\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/ToStringGeneral.tests.cpp\" >\n+          <Original>\n+            str2.size() == 3 + 10\n+          </Original>\n+          <Expanded>\n+            13 == 13\n+          </Expanded>\n+        </Expression>\n+        <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n+      <Section name=\"Double\" filename=\"projects/<exe-name>/UsageTests/ToStringGeneral.tests.cpp\" >\n+        <Expression success=\"true\" type=\"CHECK\" filename=\"projects/<exe-name>/UsageTests/ToStringGeneral.tests.cpp\" >\n+          <Original>\n+            str1.size() == 2 + 5\n+          </Original>\n+          <Expanded>\n+            7 == 7\n+          </Expanded>\n+        </Expression>\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/ToStringGeneral.tests.cpp\" >\n+          <Original>\n+            str2.size() == 2 + 15\n+          </Original>\n+          <Expanded>\n+            17 == 17\n+          </Expanded>\n+        </Expression>\n+        <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n     <TestCase name=\"Predicate matcher can accept const char*\" tags=\"[compilation][matchers]\" filename=\"projects/<exe-name>/UsageTests/Matchers.tests.cpp\" >\n       <Expression success=\"true\" type=\"REQUIRE_THAT\" filename=\"projects/<exe-name>/UsageTests/Matchers.tests.cpp\" >\n         <Original>\n@@ -13728,7 +13769,7 @@ loose text artifact\n       </Section>\n       <OverallResult success=\"true\"/>\n     </TestCase>\n-    <OverallResults successes=\"1304\" failures=\"142\" expectedFailures=\"21\"/>\n+    <OverallResults successes=\"1308\" failures=\"142\" expectedFailures=\"21\"/>\n   </Group>\n-  <OverallResults successes=\"1304\" failures=\"141\" expectedFailures=\"21\"/>\n+  <OverallResults successes=\"1308\" failures=\"141\" expectedFailures=\"21\"/>\n </Catch>\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp b/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp\nindex 09ac304517..69d6320d99 100644\n--- a/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp\n+++ b/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp\n@@ -128,6 +128,40 @@ TEST_CASE(\"String views are stringified like other strings\", \"[toString][approva\n \n #endif\n \n+TEST_CASE(\"Precision of floating point stringification can be set\", \"[toString][floatingPoint]\") {\n+    SECTION(\"Floats\") {\n+        using sm = Catch::StringMaker<float>;\n+        const auto oldPrecision = sm::precision;\n+\n+        const float testFloat = 1.12345678901234567899f;\n+        auto str1 = sm::convert(testFloat);\n+        sm::precision = 5;\n+        // \"1.\" prefix = 2 chars, f suffix is another char\n+        CHECK(str1.size() == 3 + 5);\n+\n+        sm::precision = 10;\n+        auto str2 = sm::convert(testFloat);\n+        REQUIRE(str2.size() == 3 + 10);\n+        sm::precision = oldPrecision;\n+    }\n+    SECTION(\"Double\") {\n+        using sm = Catch::StringMaker<double>;\n+        const auto oldPrecision = sm::precision;\n+\n+        const double testDouble = 1.123456789012345678901234567899;\n+        sm::precision = 5;\n+        auto str1 = sm::convert(testDouble);\n+        // \"1.\" prefix = 2 chars\n+        CHECK(str1.size() == 2 + 5);\n+\n+        sm::precision = 15;\n+        auto str2 = sm::convert(testDouble);\n+        REQUIRE(str2.size() == 2 + 15);\n+\n+        sm::precision = oldPrecision;\n+    }\n+}\n+\n namespace {\n \n struct WhatException : std::exception {\n", "fixed_tests": {"approvaltests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "noassertions": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtags": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "notest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtestnamesonly": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listreporters": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "p2p_tests": {}, "f2p_tests": {}, "s2p_tests": {}, "n2p_tests": {"approvaltests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "noassertions": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtags": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "notest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtestnamesonly": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listreporters": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "run_result": {"passed_count": 10, "failed_count": 0, "skipped_count": 0, "passed_tests": ["approvaltests", "noassertions", "runtests", "listtags", "listreporters", "listtests", "notest", "filteredsection-1", "filteredsection-2", "listtestnamesonly"], "failed_tests": [], "skipped_tests": []}, "test_patch_result": {"passed_count": 0, "failed_count": 0, "skipped_count": 0, "passed_tests": [], "failed_tests": [], "skipped_tests": []}, "fix_patch_result": {"passed_count": 10, "failed_count": 0, "skipped_count": 0, "passed_tests": ["approvaltests", "noassertions", "runtests", "listtags", "listreporters", "listtests", "notest", "filteredsection-1", "filteredsection-2", "listtestnamesonly"], "failed_tests": [], "skipped_tests": []}, "instance_id": "catchorg__Catch2-1614"}
{"org": "catchorg", "repo": "Catch2", "number": 1609, "state": "closed", "title": "Nttp support", "body": "<!--\r\nPlease do not submit pull requests changing the `version.hpp`\r\nor the single-include `catch.hpp` file, these are changed\r\nonly when a new release is made.\r\n\r\nBefore submitting a PR you should probably read the contributor documentation\r\nat docs/contributing.md. It will tell you how to properly test your changes.\r\n-->\r\n\r\n\r\n## Description\r\n<!--\r\nDescribe the what and the why of your pull request. Remember that these two\r\nare usually a bit different. As an example, if you have made various changes\r\nto decrease the number of new strings allocated, that's what. The why probably\r\nwas that you have a large set of tests and found that this speeds them up.\r\n-->\r\nAdding support for non type template parameters in form of signature based tests `TEMPLATE_TEST_CASE_SIG`, `TEMPLATE_TEST_CASE_METHOD_SIG`, `TEMPLATE_PRODUCT_TEST_CASE_SIG`, `TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG`\r\n\r\n## GitHub Issues\r\nCloses #1531 \r\n", "base": {"label": "catchorg:master", "ref": "master", "sha": "bd703dd74be7fd2413eb0c01662a491bcebea430"}, "resolved_issues": [{"number": 1531, "title": "Type parametrised test case: support for non-type template parameters", "body": "Right now, TEMPLATE_TEST_CASE and friends only seem to support type template parameters. Would be nice if we can also do something like this:\r\n\r\n    template<std::size_t,typename> struct Type;\r\n\r\n    TEMPLATE_TEST_CASE(\"\", \"\", 1, 2, 3, 4) {\r\n       Type<TestType, float> test;\r\n    }\r\n\r\n or even\r\n\r\n    TEMPLATE_TEST_CASE(\"\", \"\", (1, int), (2, float), (3, int), (4, float)) {\r\n       Type<TestType> test;\r\n    }\r\n  \r\nP.S. Right now I am circumventing it like this:\r\n\r\n    TEMPLATE_TEST_CASE(\"\", \"\", (Type<1, float), (Type<2, float), (Type<3, float), (Type<4, float)) {\r\n       TestType test;\r\n    }\r\n\r\nwhich does work"}], "fix_patch": "diff --git a/include/catch.hpp b/include/catch.hpp\nindex 1f60e5c1ae..443d409fe9 100644\n--- a/include/catch.hpp\n+++ b/include/catch.hpp\n@@ -150,14 +150,22 @@\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )\n #else\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )\n #endif\n \n \n@@ -233,14 +241,22 @@\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )\n #else\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )\n+#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )\n #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )\n+#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )\n #endif\n \n \n@@ -324,15 +340,23 @@ using Catch::Detail::Approx;\n #define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n-#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) )\n-#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className )\n+#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)\n+#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n-#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) ) )\n-#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className ) )\n+#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )\n+#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #endif\n \n // \"BDD-style\" convenience wrappers\n@@ -400,15 +424,23 @@ using Catch::Detail::Approx;\n #define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n-#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) )\n-#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className )\n+#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)\n+#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)\n+#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)\n+#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n-#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) ) )\n-#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className ) )\n+#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )\n+#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )\n+#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )\n+#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )\n #define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #endif\n \n #define STATIC_REQUIRE( ... )       (void)(0)\ndiff --git a/include/internal/catch_compiler_capabilities.h b/include/internal/catch_compiler_capabilities.h\nindex 012bf462a8..8d5af618c0 100644\n--- a/include/internal/catch_compiler_capabilities.h\n+++ b/include/internal/catch_compiler_capabilities.h\n@@ -64,6 +64,12 @@\n #       define CATCH_INTERNAL_UNSUPPRESS_UNUSED_WARNINGS \\\n             _Pragma( \"clang diagnostic pop\" )\n \n+#       define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+            _Pragma( \"clang diagnostic push\" ) \\\n+            _Pragma( \"clang diagnostic ignored \\\"-Wgnu-zero-variadic-macro-arguments\\\"\" )\n+#       define CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+            _Pragma( \"clang diagnostic pop\" )\n+\n #endif // __clang__\n \n \n@@ -274,6 +280,10 @@\n #   define CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS\n #   define CATCH_INTERNAL_UNSUPPRESS_UNUSED_WARNINGS\n #endif\n+#if !defined(CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS)\n+#   define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS\n+#   define CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS\n+#endif\n \n #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)\n #define CATCH_TRY if ((true))\ndiff --git a/include/internal/catch_meta.hpp b/include/internal/catch_meta.hpp\nindex 3508a46f76..686dbb8c07 100644\n--- a/include/internal/catch_meta.hpp\n+++ b/include/internal/catch_meta.hpp\n@@ -12,66 +12,8 @@\n #include <type_traits>\n \n namespace Catch {\n-template< typename... >\n-struct TypeList {};\n-\n-template< typename... >\n-struct append;\n-\n-template< template<typename...> class L1\n-    , typename...E1\n-    , template<typename...> class L2\n-    , typename...E2\n->\n-struct append< L1<E1...>, L2<E2...> > {\n-    using type = L1<E1..., E2...>;\n-};\n-\n-template< template<typename...> class L1\n-    , typename...E1\n-    , template<typename...> class L2\n-    , typename...E2\n-    , typename...Rest\n->\n-struct append< L1<E1...>, L2<E2...>, Rest...> {\n-    using type = typename append< L1<E1..., E2...>, Rest... >::type;\n-};\n-\n-template< template<typename...> class\n-    , typename...\n->\n-struct rewrap;\n-\n-template< template<typename...> class Container\n-    , template<typename...> class List\n-    , typename...elems\n->\n-struct rewrap<Container, List<elems...>> {\n-    using type = TypeList< Container< elems... > >;\n-};\n-\n-template< template<typename...> class Container\n-    , template<typename...> class List\n-    , class...Elems\n-    , typename...Elements>\n-    struct rewrap<Container, List<Elems...>, Elements...> {\n-    using type = typename append<TypeList<Container<Elems...>>, typename rewrap<Container, Elements...>::type>::type;\n-};\n-\n-template< template<typename...> class...Containers >\n-struct combine {\n-    template< typename...Types >\n-    struct with_types {\n-        template< template <typename...> class Final >\n-        struct into {\n-            using type = typename append<Final<>, typename rewrap<Containers, Types...>::type...>::type;\n-        };\n-    };\n-};\n-\n-template<typename T>\n-struct always_false : std::false_type {};\n-\n+    template<typename T>\n+    struct always_false : std::false_type {};\n } // namespace Catch\n \n #endif // TWOBLUECUBES_CATCH_META_HPP_INCLUDED\ndiff --git a/include/internal/catch_preprocessor.hpp b/include/internal/catch_preprocessor.hpp\nindex faf41e6b31..1dc65ad9c1 100644\n--- a/include/internal/catch_preprocessor.hpp\n+++ b/include/internal/catch_preprocessor.hpp\n@@ -68,22 +68,151 @@\n #define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) (INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param)) + 1)\n #endif\n \n+#define INTERNAL_CATCH_MAKE_NAMESPACE2(...) ns_##__VA_ARGS__\n+#define INTERNAL_CATCH_MAKE_NAMESPACE(name) INTERNAL_CATCH_MAKE_NAMESPACE2(name)\n+\n #define INTERNAL_CATCH_REMOVE_PARENS(...) INTERNAL_CATCH_EXPAND1(INTERNAL_CATCH_DEF __VA_ARGS__)\n \n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME2(Name, ...) INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME3(Name, __VA_ARGS__)\n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME3(Name,...) Name \" - \" #__VA_ARGS__\n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME(Name,...) INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME2(Name, INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__))\n+#define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)>())\n+#define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__))\n #else\n-// MSVC is adding extra space and needs more calls to properly remove ()\n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME3(Name,...) Name \" -\" #__VA_ARGS__\n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME1(Name, ...) INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME2(Name, __VA_ARGS__)\n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME(Name, ...) INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME1(Name, INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__)))\n+#define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) INTERNAL_CATCH_EXPAND_VARGS(decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)>()))\n+#define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__)))\n #endif\n \n-#define INTERNAL_CATCH_MAKE_TYPE_LIST(types) Catch::TypeList<INTERNAL_CATCH_REMOVE_PARENS(types)>\n+#define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(...)\\\n+    CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,__VA_ARGS__)\n+\n+#define INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_0) INTERNAL_CATCH_REMOVE_PARENS(_0)\n+#define INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_0, _1) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_1)\n+#define INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_0, _1, _2) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_1, _2)\n+#define INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_0, _1, _2, _3) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_1, _2, _3)\n+#define INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_0, _1, _2, _3, _4) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_1, _2, _3, _4)\n+#define INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_0, _1, _2, _3, _4, _5) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_1, _2, _3, _4, _5)\n+#define INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_0, _1, _2, _3, _4, _5, _6) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_1, _2, _4, _5, _6)\n+#define INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_0, _1, _2, _3, _4, _5, _6, _7) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_1, _2, _3, _4, _5, _6, _7)\n+#define INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_1, _2, _3, _4, _5, _6, _7, _8)\n+#define INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9)\n+#define INTERNAL_CATCH_REMOVE_PARENS_11_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10)\n+\n+#define INTERNAL_CATCH_VA_NARGS_IMPL(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n+\n+#define INTERNAL_CATCH_TYPE_GEN\\\n+    template<typename...> struct TypeList {};\\\n+    template<typename...Ts>\\\n+    constexpr auto get_wrapper() noexcept -> TypeList<Ts...> { return {}; }\\\n+    \\\n+    template<template<typename...> class L1, typename...E1, template<typename...> class L2, typename...E2> \\\n+    constexpr auto append(L1<E1...>, L2<E2...>) noexcept -> L1<E1...,E2...> { return {}; }\\\n+    template< template<typename...> class L1, typename...E1, template<typename...> class L2, typename...E2, typename...Rest>\\\n+    constexpr auto append(L1<E1...>, L2<E2...>, Rest...) noexcept -> decltype(append(L1<E1...,E2...>{}, Rest{}...)) { return {}; }\\\n+    \\\n+    template< template<typename...> class Container, template<typename...> class List, typename...elems>\\\n+    constexpr auto rewrap(List<elems...>) noexcept -> TypeList<Container<elems...>> { return {}; }\\\n+    template< template<typename...> class Container, template<typename...> class List, class...Elems, typename...Elements>\\\n+    constexpr auto rewrap(List<Elems...>,Elements...) noexcept -> decltype(append(TypeList<Container<Elems...>>{}, rewrap<Container>(Elements{}...))) { return {}; }\\\n+    \\\n+    template<template <typename...> class Final, template< typename...> class...Containers, typename...Types>\\\n+    constexpr auto create(TypeList<Types...>) noexcept -> decltype(append(Final<>{}, rewrap<Containers>(Types{}...)...)) { return {}; }\n+\n+#define INTERNAL_CATCH_NTTP_1(signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> struct Nttp{};\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    constexpr auto get_wrapper() noexcept -> Nttp<__VA_ARGS__> { return {}; } \\\n+    \\\n+    template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    constexpr auto rewrap(List<__VA_ARGS__>) noexcept -> TypeList<Container<__VA_ARGS__>> { return {}; }\\\n+    template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature), typename...Elements>\\\n+    constexpr auto rewrap(List<__VA_ARGS__>,Elements...elems) noexcept -> decltype(append(TypeList<Container<__VA_ARGS__>>{}, rewrap<Container>(elems...))) { return {}; }\\\n+    template<template <typename...> class Final, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...Containers, typename...Types>\\\n+    constexpr auto create(TypeList<Types...>) noexcept -> decltype(append(Final<>{}, rewrap<Containers>(Types{}...)...)) { return {}; }\n+\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST0(TestName)\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST1(TestName, signature)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    static void TestName()\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_X(TestName, signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    static void TestName()\n+\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST0(TestName)\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST1(TestName, signature)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    static void TestName()\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_X(TestName, signature,...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    static void TestName()\n+\n+#define INTERNAL_CATCH_NTTP_REGISTER0(TestFunc, signature)\\\n+    template<typename Type>\\\n+    void reg_test(TypeList<Type>, Catch::NameAndTags nameAndTags)\\\n+    {\\\n+        Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<Type>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\\\n+    }\n+\n+#define INTERNAL_CATCH_NTTP_REGISTER(TestFunc, signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    void reg_test(Nttp<__VA_ARGS__>, Catch::NameAndTags nameAndTags)\\\n+    {\\\n+        Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<__VA_ARGS__>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\\\n+    }\n+\n+#define INTERNAL_CATCH_NTTP_REGISTER_METHOD0(TestName, signature, ...)\\\n+    template<typename Type>\\\n+    void reg_test(TypeList<Type>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\\\n+    {\\\n+        Catch::AutoReg( Catch::makeTestInvoker(&TestName<Type>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\\\n+    }\n+\n+#define INTERNAL_CATCH_NTTP_REGISTER_METHOD(TestName, signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    void reg_test(Nttp<__VA_ARGS__>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\\\n+    {\\\n+        Catch::AutoReg( Catch::makeTestInvoker(&TestName<__VA_ARGS__>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\\\n+    }\n+\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0(TestName, ClassName)\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1(TestName, ClassName, signature)\\\n+    template<typename TestType> \\\n+    struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<TestType> { \\\n+        void test();\\\n+    }\n+\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X(TestName, ClassName, signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \\\n+    struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<__VA_ARGS__> { \\\n+        void test();\\\n+    }\n+\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0(TestName)\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1(TestName, signature)\\\n+    template<typename TestType> \\\n+    void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<TestType>::test()\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X(TestName, signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \\\n+    void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<__VA_ARGS__>::test()\n \n-#define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(types)\\\n-    CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,INTERNAL_CATCH_REMOVE_PARENS(types))\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+#define INTERNAL_CATCH_NTTP_0\n+#define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__),INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_0)\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__)\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__)\n+#define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__)\n+#define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__)\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__)\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__)\n+#define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__)\n+#else\n+#define INTERNAL_CATCH_NTTP_0(signature)\n+#define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1,INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_0)( __VA_ARGS__))\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__))\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__))\n+#define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__))\n+#define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__))\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__))\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__))\n+#define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__))\n+#endif\n \n #endif // TWOBLUECUBES_CATCH_PREPROCESSOR_HPP_INCLUDED\ndiff --git a/projects/SelfTest/Baselines/compact.sw.approved.txt b/projects/SelfTest/Baselines/compact.sw.approved.txt\nindex 7c00f483b2..89ebdfb1b5 100644\n--- a/projects/SelfTest/Baselines/compact.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/compact.sw.approved.txt\n@@ -155,18 +155,36 @@ Class.tests.cpp:<line number>: passed: Template_Fixture_2<TestType>::m_a.size()\n Class.tests.cpp:<line number>: passed: Template_Fixture_2<TestType>::m_a.size() == 0 for: 0 == 0\n Class.tests.cpp:<line number>: passed: Template_Fixture_2<TestType>::m_a.size() == 0 for: 0 == 0\n Class.tests.cpp:<line number>: passed: Template_Fixture_2<TestType>::m_a.size() == 0 for: 0 == 0\n+Class.tests.cpp:<line number>: failed: Template_Fixture_2<TestType>{}.m_a.size() < 2 for: 6 < 2\n+Class.tests.cpp:<line number>: failed: Template_Fixture_2<TestType>{}.m_a.size() < 2 for: 2 < 2\n+Class.tests.cpp:<line number>: failed: Template_Fixture_2<TestType>{}.m_a.size() < 2 for: 6 < 2\n+Class.tests.cpp:<line number>: failed: Template_Fixture_2<TestType>{}.m_a.size() < 2 for: 2 < 2\n+Class.tests.cpp:<line number>: passed: Template_Fixture_2<TestType>{}.m_a.size() >= 2 for: 6 >= 2\n+Class.tests.cpp:<line number>: passed: Template_Fixture_2<TestType>{}.m_a.size() >= 2 for: 2 >= 2\n+Class.tests.cpp:<line number>: passed: Template_Fixture_2<TestType>{}.m_a.size() >= 2 for: 6 >= 2\n+Class.tests.cpp:<line number>: passed: Template_Fixture_2<TestType>{}.m_a.size() >= 2 for: 2 >= 2\n Class.tests.cpp:<line number>: failed: Template_Fixture<TestType>::m_a == 2 for: 1.0 == 2\n Class.tests.cpp:<line number>: failed: Template_Fixture<TestType>::m_a == 2 for: 1.0f == 2\n Class.tests.cpp:<line number>: failed: Template_Fixture<TestType>::m_a == 2 for: 1 == 2\n Class.tests.cpp:<line number>: passed: Template_Fixture<TestType>::m_a == 1 for: 1.0 == 1\n Class.tests.cpp:<line number>: passed: Template_Fixture<TestType>::m_a == 1 for: 1.0f == 1\n Class.tests.cpp:<line number>: passed: Template_Fixture<TestType>::m_a == 1 for: 1 == 1\n+Class.tests.cpp:<line number>: failed: Nttp_Fixture<V>::value == 0 for: 1 == 0\n+Class.tests.cpp:<line number>: failed: Nttp_Fixture<V>::value == 0 for: 3 == 0\n+Class.tests.cpp:<line number>: failed: Nttp_Fixture<V>::value == 0 for: 6 == 0\n+Class.tests.cpp:<line number>: passed: Nttp_Fixture<V>::value > 0 for: 1 > 0\n+Class.tests.cpp:<line number>: passed: Nttp_Fixture<V>::value > 0 for: 3 > 0\n+Class.tests.cpp:<line number>: passed: Nttp_Fixture<V>::value > 0 for: 6 > 0\n Class.tests.cpp:<line number>: failed: m_a == 2 for: 1 == 2\n Class.tests.cpp:<line number>: passed: m_a == 1 for: 1 == 1\n Misc.tests.cpp:<line number>: passed: x.size() == 0 for: 0 == 0\n Misc.tests.cpp:<line number>: passed: x.size() == 0 for: 0 == 0\n Misc.tests.cpp:<line number>: passed: x.size() == 0 for: 0 == 0\n Misc.tests.cpp:<line number>: passed: x.size() == 0 for: 0 == 0\n+Misc.tests.cpp:<line number>: passed: x.size() > 0 for: 42 > 0\n+Misc.tests.cpp:<line number>: passed: x.size() > 0 for: 9 > 0\n+Misc.tests.cpp:<line number>: passed: x.size() > 0 for: 42 > 0\n+Misc.tests.cpp:<line number>: passed: x.size() > 0 for: 9 > 0\n Approx.tests.cpp:<line number>: passed: d == 1.23_a for: 1.23 == Approx( 1.23 )\n Approx.tests.cpp:<line number>: passed: d != 1.22_a for: 1.23 != Approx( 1.22 )\n Approx.tests.cpp:<line number>: passed: -d == -1.23_a for: -1.23 == Approx( -1.23 )\n@@ -1126,6 +1144,74 @@ Misc.tests.cpp:<line number>: passed: v.size() == 5 for: 5 == 5\n Misc.tests.cpp:<line number>: passed: v.capacity() >= 5 for: 5 >= 5\n Misc.tests.cpp:<line number>: passed: v.size() == 5 for: 5 == 5\n Misc.tests.cpp:<line number>: passed: v.capacity() >= 5 for: 5 >= 5\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 6 == 6\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 6 >= 6\n+Misc.tests.cpp:<line number>: passed: v.size() == 2 * V for: 12 == 12\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= 2 * V for: 12 >= 12\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 6 == 6\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 6 >= 6\n+Misc.tests.cpp:<line number>: passed: v.size() == 0 for: 0 == 0\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 6 >= 6\n+Misc.tests.cpp:<line number>: passed: v.capacity() == 0 for: 0 == 0\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 6 == 6\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 6 >= 6\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 6 == 6\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= 2 * V for: 12 >= 12\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 6 == 6\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 6 >= 6\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 6 == 6\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 6 >= 6\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 4 == 4\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 4 >= 4\n+Misc.tests.cpp:<line number>: passed: v.size() == 2 * V for: 8 == 8\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= 2 * V for: 8 >= 8\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 4 == 4\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 4 >= 4\n+Misc.tests.cpp:<line number>: passed: v.size() == 0 for: 0 == 0\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 4 >= 4\n+Misc.tests.cpp:<line number>: passed: v.capacity() == 0 for: 0 == 0\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 4 == 4\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 4 >= 4\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 4 == 4\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= 2 * V for: 8 >= 8\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 4 == 4\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 4 >= 4\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 4 == 4\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 4 >= 4\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 5 == 5\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 5 >= 5\n+Misc.tests.cpp:<line number>: passed: v.size() == 2 * V for: 10 == 10\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= 2 * V for: 10 >= 10\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 5 == 5\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 5 >= 5\n+Misc.tests.cpp:<line number>: passed: v.size() == 0 for: 0 == 0\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 5 >= 5\n+Misc.tests.cpp:<line number>: passed: v.capacity() == 0 for: 0 == 0\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 5 == 5\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 5 >= 5\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 5 == 5\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= 2 * V for: 10 >= 10\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 5 == 5\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 5 >= 5\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 5 == 5\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 5 >= 5\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 15 == 15\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 15 >= 15\n+Misc.tests.cpp:<line number>: passed: v.size() == 2 * V for: 30 == 30\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= 2 * V for: 30 >= 30\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 15 == 15\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 15 >= 15\n+Misc.tests.cpp:<line number>: passed: v.size() == 0 for: 0 == 0\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 15 >= 15\n+Misc.tests.cpp:<line number>: passed: v.capacity() == 0 for: 0 == 0\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 15 == 15\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 15 >= 15\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 15 == 15\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= 2 * V for: 30 >= 30\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 15 == 15\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 15 >= 15\n+Misc.tests.cpp:<line number>: passed: v.size() == V for: 15 == 15\n+Misc.tests.cpp:<line number>: passed: v.capacity() >= V for: 15 >= 15\n VariadicMacros.tests.cpp:<line number>: passed: with 1 message: 'no assertions'\n Tricky.tests.cpp:<line number>: passed: 0x<hex digits> == bit30and31 for: 3221225472 (0x<hex digits>) == 3221225472\n Message.tests.cpp:<line number>: failed - but was ok: 1 == 2\n@@ -1543,5 +1629,5 @@ Misc.tests.cpp:<line number>: passed: v.size() == 5 for: 5 == 5\n Misc.tests.cpp:<line number>: passed: v.capacity() >= 5 for: 5 >= 5\n Misc.tests.cpp:<line number>: passed:\n Misc.tests.cpp:<line number>: passed:\n-Failed 79 test cases, failed 141 assertions.\n+Failed 86 test cases, failed 148 assertions.\n \ndiff --git a/projects/SelfTest/Baselines/console.std.approved.txt b/projects/SelfTest/Baselines/console.std.approved.txt\nindex aa991bd403..5f8e036272 100644\n--- a/projects/SelfTest/Baselines/console.std.approved.txt\n+++ b/projects/SelfTest/Baselines/console.std.approved.txt\n@@ -163,6 +163,54 @@ Class.tests.cpp:<line number>: FAILED:\n with expansion:\n   0 == 1\n \n+-------------------------------------------------------------------------------\n+A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails -\n+Template_Foo_2<float, 6>\n+-------------------------------------------------------------------------------\n+Class.tests.cpp:<line number>\n+...............................................................................\n+\n+Class.tests.cpp:<line number>: FAILED:\n+  REQUIRE( Template_Fixture_2<TestType>{}.m_a.size() < 2 )\n+with expansion:\n+  6 < 2\n+\n+-------------------------------------------------------------------------------\n+A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails -\n+Template_Foo_2<int, 2>\n+-------------------------------------------------------------------------------\n+Class.tests.cpp:<line number>\n+...............................................................................\n+\n+Class.tests.cpp:<line number>: FAILED:\n+  REQUIRE( Template_Fixture_2<TestType>{}.m_a.size() < 2 )\n+with expansion:\n+  2 < 2\n+\n+-------------------------------------------------------------------------------\n+A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails - std::array\n+<float, 6>\n+-------------------------------------------------------------------------------\n+Class.tests.cpp:<line number>\n+...............................................................................\n+\n+Class.tests.cpp:<line number>: FAILED:\n+  REQUIRE( Template_Fixture_2<TestType>{}.m_a.size() < 2 )\n+with expansion:\n+  6 < 2\n+\n+-------------------------------------------------------------------------------\n+A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails - std::array\n+<int, 2>\n+-------------------------------------------------------------------------------\n+Class.tests.cpp:<line number>\n+...............................................................................\n+\n+Class.tests.cpp:<line number>: FAILED:\n+  REQUIRE( Template_Fixture_2<TestType>{}.m_a.size() < 2 )\n+with expansion:\n+  2 < 2\n+\n -------------------------------------------------------------------------------\n A TEMPLATE_TEST_CASE_METHOD based test run that fails - double\n -------------------------------------------------------------------------------\n@@ -196,6 +244,39 @@ Class.tests.cpp:<line number>: FAILED:\n with expansion:\n   1 == 2\n \n+-------------------------------------------------------------------------------\n+A TEMPLATE_TEST_CASE_METHOD_SIG based test run that fails - 1\n+-------------------------------------------------------------------------------\n+Class.tests.cpp:<line number>\n+...............................................................................\n+\n+Class.tests.cpp:<line number>: FAILED:\n+  REQUIRE( Nttp_Fixture<V>::value == 0 )\n+with expansion:\n+  1 == 0\n+\n+-------------------------------------------------------------------------------\n+A TEMPLATE_TEST_CASE_METHOD_SIG based test run that fails - 3\n+-------------------------------------------------------------------------------\n+Class.tests.cpp:<line number>\n+...............................................................................\n+\n+Class.tests.cpp:<line number>: FAILED:\n+  REQUIRE( Nttp_Fixture<V>::value == 0 )\n+with expansion:\n+  3 == 0\n+\n+-------------------------------------------------------------------------------\n+A TEMPLATE_TEST_CASE_METHOD_SIG based test run that fails - 6\n+-------------------------------------------------------------------------------\n+Class.tests.cpp:<line number>\n+...............................................................................\n+\n+Class.tests.cpp:<line number>: FAILED:\n+  REQUIRE( Nttp_Fixture<V>::value == 0 )\n+with expansion:\n+  6 == 0\n+\n -------------------------------------------------------------------------------\n A TEST_CASE_METHOD based test run that fails\n -------------------------------------------------------------------------------\n@@ -1299,6 +1380,6 @@ due to unexpected exception with message:\n   Why would you throw a std::string?\n \n ===============================================================================\n-test cases:  267 |  200 passed |  63 failed |  4 failed as expected\n-assertions: 1453 | 1308 passed | 124 failed | 21 failed as expected\n+test cases:  289 |  215 passed |  70 failed |  4 failed as expected\n+assertions: 1539 | 1387 passed | 131 failed | 21 failed as expected\n \ndiff --git a/projects/SelfTest/Baselines/console.sw.approved.txt b/projects/SelfTest/Baselines/console.sw.approved.txt\nindex cca937fe2a..cd65bc1709 100644\n--- a/projects/SelfTest/Baselines/console.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/console.sw.approved.txt\n@@ -1179,6 +1179,102 @@ Class.tests.cpp:<line number>: PASSED:\n with expansion:\n   0 == 0\n \n+-------------------------------------------------------------------------------\n+A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails -\n+Template_Foo_2<float, 6>\n+-------------------------------------------------------------------------------\n+Class.tests.cpp:<line number>\n+...............................................................................\n+\n+Class.tests.cpp:<line number>: FAILED:\n+  REQUIRE( Template_Fixture_2<TestType>{}.m_a.size() < 2 )\n+with expansion:\n+  6 < 2\n+\n+-------------------------------------------------------------------------------\n+A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails -\n+Template_Foo_2<int, 2>\n+-------------------------------------------------------------------------------\n+Class.tests.cpp:<line number>\n+...............................................................................\n+\n+Class.tests.cpp:<line number>: FAILED:\n+  REQUIRE( Template_Fixture_2<TestType>{}.m_a.size() < 2 )\n+with expansion:\n+  2 < 2\n+\n+-------------------------------------------------------------------------------\n+A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails - std::array\n+<float, 6>\n+-------------------------------------------------------------------------------\n+Class.tests.cpp:<line number>\n+...............................................................................\n+\n+Class.tests.cpp:<line number>: FAILED:\n+  REQUIRE( Template_Fixture_2<TestType>{}.m_a.size() < 2 )\n+with expansion:\n+  6 < 2\n+\n+-------------------------------------------------------------------------------\n+A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails - std::array\n+<int, 2>\n+-------------------------------------------------------------------------------\n+Class.tests.cpp:<line number>\n+...............................................................................\n+\n+Class.tests.cpp:<line number>: FAILED:\n+  REQUIRE( Template_Fixture_2<TestType>{}.m_a.size() < 2 )\n+with expansion:\n+  2 < 2\n+\n+-------------------------------------------------------------------------------\n+A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds -\n+Template_Foo_2<float,6>\n+-------------------------------------------------------------------------------\n+Class.tests.cpp:<line number>\n+...............................................................................\n+\n+Class.tests.cpp:<line number>: PASSED:\n+  REQUIRE( Template_Fixture_2<TestType>{}.m_a.size() >= 2 )\n+with expansion:\n+  6 >= 2\n+\n+-------------------------------------------------------------------------------\n+A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds -\n+Template_Foo_2<int,2>\n+-------------------------------------------------------------------------------\n+Class.tests.cpp:<line number>\n+...............................................................................\n+\n+Class.tests.cpp:<line number>: PASSED:\n+  REQUIRE( Template_Fixture_2<TestType>{}.m_a.size() >= 2 )\n+with expansion:\n+  2 >= 2\n+\n+-------------------------------------------------------------------------------\n+A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds - std::\n+array<float,6>\n+-------------------------------------------------------------------------------\n+Class.tests.cpp:<line number>\n+...............................................................................\n+\n+Class.tests.cpp:<line number>: PASSED:\n+  REQUIRE( Template_Fixture_2<TestType>{}.m_a.size() >= 2 )\n+with expansion:\n+  6 >= 2\n+\n+-------------------------------------------------------------------------------\n+A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds - std::\n+array<int,2>\n+-------------------------------------------------------------------------------\n+Class.tests.cpp:<line number>\n+...............................................................................\n+\n+Class.tests.cpp:<line number>: PASSED:\n+  REQUIRE( Template_Fixture_2<TestType>{}.m_a.size() >= 2 )\n+with expansion:\n+  2 >= 2\n+\n -------------------------------------------------------------------------------\n A TEMPLATE_TEST_CASE_METHOD based test run that fails - double\n -------------------------------------------------------------------------------\n@@ -1245,6 +1341,72 @@ Class.tests.cpp:<line number>: PASSED:\n with expansion:\n   1 == 1\n \n+-------------------------------------------------------------------------------\n+A TEMPLATE_TEST_CASE_METHOD_SIG based test run that fails - 1\n+-------------------------------------------------------------------------------\n+Class.tests.cpp:<line number>\n+...............................................................................\n+\n+Class.tests.cpp:<line number>: FAILED:\n+  REQUIRE( Nttp_Fixture<V>::value == 0 )\n+with expansion:\n+  1 == 0\n+\n+-------------------------------------------------------------------------------\n+A TEMPLATE_TEST_CASE_METHOD_SIG based test run that fails - 3\n+-------------------------------------------------------------------------------\n+Class.tests.cpp:<line number>\n+...............................................................................\n+\n+Class.tests.cpp:<line number>: FAILED:\n+  REQUIRE( Nttp_Fixture<V>::value == 0 )\n+with expansion:\n+  3 == 0\n+\n+-------------------------------------------------------------------------------\n+A TEMPLATE_TEST_CASE_METHOD_SIG based test run that fails - 6\n+-------------------------------------------------------------------------------\n+Class.tests.cpp:<line number>\n+...............................................................................\n+\n+Class.tests.cpp:<line number>: FAILED:\n+  REQUIRE( Nttp_Fixture<V>::value == 0 )\n+with expansion:\n+  6 == 0\n+\n+-------------------------------------------------------------------------------\n+A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds - 1\n+-------------------------------------------------------------------------------\n+Class.tests.cpp:<line number>\n+...............................................................................\n+\n+Class.tests.cpp:<line number>: PASSED:\n+  REQUIRE( Nttp_Fixture<V>::value > 0 )\n+with expansion:\n+  1 > 0\n+\n+-------------------------------------------------------------------------------\n+A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds - 3\n+-------------------------------------------------------------------------------\n+Class.tests.cpp:<line number>\n+...............................................................................\n+\n+Class.tests.cpp:<line number>: PASSED:\n+  REQUIRE( Nttp_Fixture<V>::value > 0 )\n+with expansion:\n+  3 > 0\n+\n+-------------------------------------------------------------------------------\n+A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds - 6\n+-------------------------------------------------------------------------------\n+Class.tests.cpp:<line number>\n+...............................................................................\n+\n+Class.tests.cpp:<line number>: PASSED:\n+  REQUIRE( Nttp_Fixture<V>::value > 0 )\n+with expansion:\n+  6 > 0\n+\n -------------------------------------------------------------------------------\n A TEST_CASE_METHOD based test run that fails\n -------------------------------------------------------------------------------\n@@ -1311,6 +1473,50 @@ Misc.tests.cpp:<line number>: PASSED:\n with expansion:\n   0 == 0\n \n+-------------------------------------------------------------------------------\n+A Template product test case with array signature - Bar<float, 42>\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( x.size() > 0 )\n+with expansion:\n+  42 > 0\n+\n+-------------------------------------------------------------------------------\n+A Template product test case with array signature - Bar<int, 9>\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( x.size() > 0 )\n+with expansion:\n+  9 > 0\n+\n+-------------------------------------------------------------------------------\n+A Template product test case with array signature - std::array<float, 42>\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( x.size() > 0 )\n+with expansion:\n+  42 > 0\n+\n+-------------------------------------------------------------------------------\n+A Template product test case with array signature - std::array<int, 9>\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( x.size() > 0 )\n+with expansion:\n+  9 > 0\n+\n -------------------------------------------------------------------------------\n A comparison that uses literals instead of the normal constructor\n -------------------------------------------------------------------------------\n@@ -8274,6 +8480,586 @@ Misc.tests.cpp:<line number>: PASSED:\n with expansion:\n   5 >= 5\n \n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  6 == 6\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  6 >= 6\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6\n+  resizing bigger changes size and capacity\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == 2 * V )\n+with expansion:\n+  12 == 12\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= 2 * V )\n+with expansion:\n+  12 >= 12\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  6 == 6\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  6 >= 6\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6\n+  resizing smaller changes size but not capacity\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == 0 )\n+with expansion:\n+  0 == 0\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  6 >= 6\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6\n+  resizing smaller changes size but not capacity\n+  We can use the 'swap trick' to reset the capacity\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() == 0 )\n+with expansion:\n+  0 == 0\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  6 == 6\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  6 >= 6\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6\n+  reserving bigger changes capacity but not size\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  6 == 6\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= 2 * V )\n+with expansion:\n+  12 >= 12\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  6 == 6\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  6 >= 6\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6\n+  reserving smaller does not change size or capacity\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  6 == 6\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  6 >= 6\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - float,4\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  4 == 4\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  4 >= 4\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - float,4\n+  resizing bigger changes size and capacity\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == 2 * V )\n+with expansion:\n+  8 == 8\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= 2 * V )\n+with expansion:\n+  8 >= 8\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - float,4\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  4 == 4\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  4 >= 4\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - float,4\n+  resizing smaller changes size but not capacity\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == 0 )\n+with expansion:\n+  0 == 0\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  4 >= 4\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - float,4\n+  resizing smaller changes size but not capacity\n+  We can use the 'swap trick' to reset the capacity\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() == 0 )\n+with expansion:\n+  0 == 0\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - float,4\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  4 == 4\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  4 >= 4\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - float,4\n+  reserving bigger changes capacity but not size\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  4 == 4\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= 2 * V )\n+with expansion:\n+  8 >= 8\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - float,4\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  4 == 4\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  4 >= 4\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - float,4\n+  reserving smaller does not change size or capacity\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  4 == 4\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  4 >= 4\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - int,5\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  5 == 5\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  5 >= 5\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - int,5\n+  resizing bigger changes size and capacity\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == 2 * V )\n+with expansion:\n+  10 == 10\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= 2 * V )\n+with expansion:\n+  10 >= 10\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - int,5\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  5 == 5\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  5 >= 5\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - int,5\n+  resizing smaller changes size but not capacity\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == 0 )\n+with expansion:\n+  0 == 0\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  5 >= 5\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - int,5\n+  resizing smaller changes size but not capacity\n+  We can use the 'swap trick' to reset the capacity\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() == 0 )\n+with expansion:\n+  0 == 0\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - int,5\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  5 == 5\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  5 >= 5\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - int,5\n+  reserving bigger changes capacity but not size\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  5 == 5\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= 2 * V )\n+with expansion:\n+  10 >= 10\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - int,5\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  5 == 5\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  5 >= 5\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - int,5\n+  reserving smaller does not change size or capacity\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  5 == 5\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  5 >= 5\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - std::string,15\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  15 == 15\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  15 >= 15\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - std::string,15\n+  resizing bigger changes size and capacity\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == 2 * V )\n+with expansion:\n+  30 == 30\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= 2 * V )\n+with expansion:\n+  30 >= 30\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - std::string,15\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  15 == 15\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  15 >= 15\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - std::string,15\n+  resizing smaller changes size but not capacity\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == 0 )\n+with expansion:\n+  0 == 0\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  15 >= 15\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - std::string,15\n+  resizing smaller changes size but not capacity\n+  We can use the 'swap trick' to reset the capacity\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() == 0 )\n+with expansion:\n+  0 == 0\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - std::string,15\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  15 == 15\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  15 >= 15\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - std::string,15\n+  reserving bigger changes capacity but not size\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  15 == 15\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= 2 * V )\n+with expansion:\n+  30 >= 30\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - std::string,15\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  15 == 15\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  15 >= 15\n+\n+-------------------------------------------------------------------------------\n+TemplateTestSig: vectors can be sized and resized - std::string,15\n+  reserving smaller does not change size or capacity\n+-------------------------------------------------------------------------------\n+Misc.tests.cpp:<line number>\n+...............................................................................\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.size() == V )\n+with expansion:\n+  15 == 15\n+\n+Misc.tests.cpp:<line number>: PASSED:\n+  REQUIRE( v.capacity() >= V )\n+with expansion:\n+  15 >= 15\n+\n -------------------------------------------------------------------------------\n Test case with one argument\n -------------------------------------------------------------------------------\n@@ -11432,6 +12218,6 @@ Misc.tests.cpp:<line number>\n Misc.tests.cpp:<line number>: PASSED:\n \n ===============================================================================\n-test cases:  267 |  184 passed |  79 failed |  4 failed as expected\n-assertions: 1470 | 1308 passed | 141 failed | 21 failed as expected\n+test cases:  289 |  199 passed |  86 failed |  4 failed as expected\n+assertions: 1556 | 1387 passed | 148 failed | 21 failed as expected\n \ndiff --git a/projects/SelfTest/Baselines/junit.sw.approved.txt b/projects/SelfTest/Baselines/junit.sw.approved.txt\nindex f4d8b37db5..94f0138552 100644\n--- a/projects/SelfTest/Baselines/junit.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/junit.sw.approved.txt\n@@ -1,7 +1,7 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <testsuitesloose text artifact\n >\n-  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"125\" tests=\"1471\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n+  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"132\" tests=\"1557\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n     <properties>\n       <property name=\"filters\" value=\"~[!nonportable]~[!benchmark]~[approvals]\"/>\n       <property name=\"random-seed\" value=\"1\"/>\n@@ -119,6 +119,30 @@ Class.tests.cpp:<line number>\n     <testcase classname=\"<exe-name>.Template_Fixture_2\" name=\"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that succeeds - Template_Foo&lt;int>\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.Template_Fixture_2\" name=\"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that succeeds - std::vector&lt;float>\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.Template_Fixture_2\" name=\"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that succeeds - std::vector&lt;int>\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.Template_Fixture_2\" name=\"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails - Template_Foo_2&lt;float, 6>\" time=\"{duration}\">\n+      <failure message=\"6 &lt; 2\" type=\"REQUIRE\">\n+Class.tests.cpp:<line number>\n+      </failure>\n+    </testcase>\n+    <testcase classname=\"<exe-name>.Template_Fixture_2\" name=\"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails - Template_Foo_2&lt;int, 2>\" time=\"{duration}\">\n+      <failure message=\"2 &lt; 2\" type=\"REQUIRE\">\n+Class.tests.cpp:<line number>\n+      </failure>\n+    </testcase>\n+    <testcase classname=\"<exe-name>.Template_Fixture_2\" name=\"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails - std::array&lt;float, 6>\" time=\"{duration}\">\n+      <failure message=\"6 &lt; 2\" type=\"REQUIRE\">\n+Class.tests.cpp:<line number>\n+      </failure>\n+    </testcase>\n+    <testcase classname=\"<exe-name>.Template_Fixture_2\" name=\"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails - std::array&lt;int, 2>\" time=\"{duration}\">\n+      <failure message=\"2 &lt; 2\" type=\"REQUIRE\">\n+Class.tests.cpp:<line number>\n+      </failure>\n+    </testcase>\n+    <testcase classname=\"<exe-name>.Template_Fixture_2\" name=\"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds - Template_Foo_2&lt;float,6>\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.Template_Fixture_2\" name=\"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds - Template_Foo_2&lt;int,2>\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.Template_Fixture_2\" name=\"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds - std::array&lt;float,6>\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.Template_Fixture_2\" name=\"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds - std::array&lt;int,2>\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.Template_Fixture\" name=\"A TEMPLATE_TEST_CASE_METHOD based test run that fails - double\" time=\"{duration}\">\n       <failure message=\"1.0 == 2\" type=\"REQUIRE\">\n Class.tests.cpp:<line number>\n@@ -137,6 +161,24 @@ Class.tests.cpp:<line number>\n     <testcase classname=\"<exe-name>.Template_Fixture\" name=\"A TEMPLATE_TEST_CASE_METHOD based test run that succeeds - double\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.Template_Fixture\" name=\"A TEMPLATE_TEST_CASE_METHOD based test run that succeeds - float\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.Template_Fixture\" name=\"A TEMPLATE_TEST_CASE_METHOD based test run that succeeds - int\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.Nttp_Fixture\" name=\"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that fails - 1\" time=\"{duration}\">\n+      <failure message=\"1 == 0\" type=\"REQUIRE\">\n+Class.tests.cpp:<line number>\n+      </failure>\n+    </testcase>\n+    <testcase classname=\"<exe-name>.Nttp_Fixture\" name=\"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that fails - 3\" time=\"{duration}\">\n+      <failure message=\"3 == 0\" type=\"REQUIRE\">\n+Class.tests.cpp:<line number>\n+      </failure>\n+    </testcase>\n+    <testcase classname=\"<exe-name>.Nttp_Fixture\" name=\"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that fails - 6\" time=\"{duration}\">\n+      <failure message=\"6 == 0\" type=\"REQUIRE\">\n+Class.tests.cpp:<line number>\n+      </failure>\n+    </testcase>\n+    <testcase classname=\"<exe-name>.Nttp_Fixture\" name=\"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds - 1\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.Nttp_Fixture\" name=\"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds - 3\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.Nttp_Fixture\" name=\"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds - 6\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.Fixture\" name=\"A TEST_CASE_METHOD based test run that fails\" time=\"{duration}\">\n       <failure message=\"1 == 2\" type=\"REQUIRE\">\n Class.tests.cpp:<line number>\n@@ -147,6 +189,10 @@ Class.tests.cpp:<line number>\n     <testcase classname=\"<exe-name>.global\" name=\"A Template product test case - Foo&lt;int>\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"A Template product test case - std::vector&lt;float>\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"A Template product test case - std::vector&lt;int>\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"A Template product test case with array signature - Bar&lt;float, 42>\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"A Template product test case with array signature - Bar&lt;int, 9>\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"A Template product test case with array signature - std::array&lt;float, 42>\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"A Template product test case with array signature - std::array&lt;int, 9>\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"A comparison that uses literals instead of the normal constructor\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"A couple of nested sections followed by a failure\" time=\"{duration}\">\n       <failure type=\"FAIL\">\n@@ -720,6 +766,30 @@ Misc.tests.cpp:<line number>\n     <testcase classname=\"<exe-name>.global\" name=\"TemplateTest: vectors can be sized and resized - std::tuple&lt;int,float>/resizing smaller changes size but not capacity/We can use the 'swap trick' to reset the capacity\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"TemplateTest: vectors can be sized and resized - std::tuple&lt;int,float>/reserving bigger changes capacity but not size\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"TemplateTest: vectors can be sized and resized - std::tuple&lt;int,float>/reserving smaller does not change size or capacity\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - (std::tuple&lt;int, float>), 6\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - (std::tuple&lt;int, float>), 6/resizing bigger changes size and capacity\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - (std::tuple&lt;int, float>), 6/resizing smaller changes size but not capacity\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - (std::tuple&lt;int, float>), 6/resizing smaller changes size but not capacity/We can use the 'swap trick' to reset the capacity\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - (std::tuple&lt;int, float>), 6/reserving bigger changes capacity but not size\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - (std::tuple&lt;int, float>), 6/reserving smaller does not change size or capacity\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - float,4\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - float,4/resizing bigger changes size and capacity\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - float,4/resizing smaller changes size but not capacity\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - float,4/resizing smaller changes size but not capacity/We can use the 'swap trick' to reset the capacity\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - float,4/reserving bigger changes capacity but not size\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - float,4/reserving smaller does not change size or capacity\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - int,5\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - int,5/resizing bigger changes size and capacity\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - int,5/resizing smaller changes size but not capacity\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - int,5/resizing smaller changes size but not capacity/We can use the 'swap trick' to reset the capacity\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - int,5/reserving bigger changes capacity but not size\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - int,5/reserving smaller does not change size or capacity\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - std::string,15\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - std::string,15/resizing bigger changes size and capacity\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - std::string,15/resizing smaller changes size but not capacity\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - std::string,15/resizing smaller changes size but not capacity/We can use the 'swap trick' to reset the capacity\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - std::string,15/reserving bigger changes capacity but not size\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"TemplateTestSig: vectors can be sized and resized - std::string,15/reserving smaller does not change size or capacity\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Test case with one argument\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Test enum bit values\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"The NO_FAIL macro reports a failure but does not fail the test\" time=\"{duration}\"/>\ndiff --git a/projects/SelfTest/Baselines/xml.sw.approved.txt b/projects/SelfTest/Baselines/xml.sw.approved.txt\nindex 7fcb4f5c35..dd2c3f4a96 100644\n--- a/projects/SelfTest/Baselines/xml.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/xml.sw.approved.txt\n@@ -1318,6 +1318,94 @@ Nor would this\n       </Expression>\n       <OverallResult success=\"true\"/>\n     </TestCase>\n+    <TestCase name=\"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails - Template_Foo_2&lt;float, 6>\" tags=\"[.][class][failing][nttp][product][template]\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+      <Expression success=\"false\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+        <Original>\n+          Template_Fixture_2&lt;TestType>{}.m_a.size() &lt; 2\n+        </Original>\n+        <Expanded>\n+          6 &lt; 2\n+        </Expanded>\n+      </Expression>\n+      <OverallResult success=\"false\"/>\n+    </TestCase>\n+    <TestCase name=\"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails - Template_Foo_2&lt;int, 2>\" tags=\"[.][class][failing][nttp][product][template]\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+      <Expression success=\"false\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+        <Original>\n+          Template_Fixture_2&lt;TestType>{}.m_a.size() &lt; 2\n+        </Original>\n+        <Expanded>\n+          2 &lt; 2\n+        </Expanded>\n+      </Expression>\n+      <OverallResult success=\"false\"/>\n+    </TestCase>\n+    <TestCase name=\"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails - std::array&lt;float, 6>\" tags=\"[.][class][failing][nttp][product][template]\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+      <Expression success=\"false\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+        <Original>\n+          Template_Fixture_2&lt;TestType>{}.m_a.size() &lt; 2\n+        </Original>\n+        <Expanded>\n+          6 &lt; 2\n+        </Expanded>\n+      </Expression>\n+      <OverallResult success=\"false\"/>\n+    </TestCase>\n+    <TestCase name=\"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails - std::array&lt;int, 2>\" tags=\"[.][class][failing][nttp][product][template]\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+      <Expression success=\"false\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+        <Original>\n+          Template_Fixture_2&lt;TestType>{}.m_a.size() &lt; 2\n+        </Original>\n+        <Expanded>\n+          2 &lt; 2\n+        </Expanded>\n+      </Expression>\n+      <OverallResult success=\"false\"/>\n+    </TestCase>\n+    <TestCase name=\"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds - Template_Foo_2&lt;float,6>\" tags=\"[class][nttp][product][template]\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+        <Original>\n+          Template_Fixture_2&lt;TestType>{}.m_a.size() >= 2\n+        </Original>\n+        <Expanded>\n+          6 >= 2\n+        </Expanded>\n+      </Expression>\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n+    <TestCase name=\"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds - Template_Foo_2&lt;int,2>\" tags=\"[class][nttp][product][template]\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+        <Original>\n+          Template_Fixture_2&lt;TestType>{}.m_a.size() >= 2\n+        </Original>\n+        <Expanded>\n+          2 >= 2\n+        </Expanded>\n+      </Expression>\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n+    <TestCase name=\"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds - std::array&lt;float,6>\" tags=\"[class][nttp][product][template]\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+        <Original>\n+          Template_Fixture_2&lt;TestType>{}.m_a.size() >= 2\n+        </Original>\n+        <Expanded>\n+          6 >= 2\n+        </Expanded>\n+      </Expression>\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n+    <TestCase name=\"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds - std::array&lt;int,2>\" tags=\"[class][nttp][product][template]\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+        <Original>\n+          Template_Fixture_2&lt;TestType>{}.m_a.size() >= 2\n+        </Original>\n+        <Expanded>\n+          2 >= 2\n+        </Expanded>\n+      </Expression>\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n     <TestCase name=\"A TEMPLATE_TEST_CASE_METHOD based test run that fails - double\" tags=\"[.][class][failing][template]\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n       <Expression success=\"false\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n         <Original>\n@@ -1384,6 +1472,72 @@ Nor would this\n       </Expression>\n       <OverallResult success=\"true\"/>\n     </TestCase>\n+    <TestCase name=\"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that fails - 1\" tags=\"[.][class][failing][nttp][template]\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+      <Expression success=\"false\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+        <Original>\n+          Nttp_Fixture&lt;V>::value == 0\n+        </Original>\n+        <Expanded>\n+          1 == 0\n+        </Expanded>\n+      </Expression>\n+      <OverallResult success=\"false\"/>\n+    </TestCase>\n+    <TestCase name=\"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that fails - 3\" tags=\"[.][class][failing][nttp][template]\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+      <Expression success=\"false\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+        <Original>\n+          Nttp_Fixture&lt;V>::value == 0\n+        </Original>\n+        <Expanded>\n+          3 == 0\n+        </Expanded>\n+      </Expression>\n+      <OverallResult success=\"false\"/>\n+    </TestCase>\n+    <TestCase name=\"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that fails - 6\" tags=\"[.][class][failing][nttp][template]\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+      <Expression success=\"false\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+        <Original>\n+          Nttp_Fixture&lt;V>::value == 0\n+        </Original>\n+        <Expanded>\n+          6 == 0\n+        </Expanded>\n+      </Expression>\n+      <OverallResult success=\"false\"/>\n+    </TestCase>\n+    <TestCase name=\"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds - 1\" tags=\"[class][nttp][template]\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+        <Original>\n+          Nttp_Fixture&lt;V>::value > 0\n+        </Original>\n+        <Expanded>\n+          1 > 0\n+        </Expanded>\n+      </Expression>\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n+    <TestCase name=\"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds - 3\" tags=\"[class][nttp][template]\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+        <Original>\n+          Nttp_Fixture&lt;V>::value > 0\n+        </Original>\n+        <Expanded>\n+          3 > 0\n+        </Expanded>\n+      </Expression>\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n+    <TestCase name=\"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds - 6\" tags=\"[class][nttp][template]\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n+        <Original>\n+          Nttp_Fixture&lt;V>::value > 0\n+        </Original>\n+        <Expanded>\n+          6 > 0\n+        </Expanded>\n+      </Expression>\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n     <TestCase name=\"A TEST_CASE_METHOD based test run that fails\" tags=\"[.][class][failing]\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n       <Expression success=\"false\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Class.tests.cpp\" >\n         <Original>\n@@ -1450,6 +1604,50 @@ Nor would this\n       </Expression>\n       <OverallResult success=\"true\"/>\n     </TestCase>\n+    <TestCase name=\"A Template product test case with array signature - Bar&lt;float, 42>\" tags=\"[nttp][product][template]\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          x.size() > 0\n+        </Original>\n+        <Expanded>\n+          42 > 0\n+        </Expanded>\n+      </Expression>\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n+    <TestCase name=\"A Template product test case with array signature - Bar&lt;int, 9>\" tags=\"[nttp][product][template]\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          x.size() > 0\n+        </Original>\n+        <Expanded>\n+          9 > 0\n+        </Expanded>\n+      </Expression>\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n+    <TestCase name=\"A Template product test case with array signature - std::array&lt;float, 42>\" tags=\"[nttp][product][template]\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          x.size() > 0\n+        </Original>\n+        <Expanded>\n+          42 > 0\n+        </Expanded>\n+      </Expression>\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n+    <TestCase name=\"A Template product test case with array signature - std::array&lt;int, 9>\" tags=\"[nttp][product][template]\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          x.size() > 0\n+        </Original>\n+        <Expanded>\n+          9 > 0\n+        </Expanded>\n+      </Expression>\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n     <TestCase name=\"A comparison that uses literals instead of the normal constructor\" tags=\"[Approx]\" filename=\"projects/<exe-name>/UsageTests/Approx.tests.cpp\" >\n       <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Approx.tests.cpp\" >\n         <Original>\n@@ -10198,6 +10396,622 @@ Message from section two\n       </Section>\n       <OverallResult success=\"true\"/>\n     </TestCase>\n+    <TestCase name=\"TemplateTestSig: vectors can be sized and resized - (std::tuple&lt;int, float>), 6\" tags=\"[nttp][template][vector]\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.size() == V\n+        </Original>\n+        <Expanded>\n+          6 == 6\n+        </Expanded>\n+      </Expression>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.capacity() >= V\n+        </Original>\n+        <Expanded>\n+          6 >= 6\n+        </Expanded>\n+      </Expression>\n+      <Section name=\"resizing bigger changes size and capacity\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.size() == 2 * V\n+          </Original>\n+          <Expanded>\n+            12 == 12\n+          </Expanded>\n+        </Expression>\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.capacity() >= 2 * V\n+          </Original>\n+          <Expanded>\n+            12 >= 12\n+          </Expanded>\n+        </Expression>\n+        <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.size() == V\n+        </Original>\n+        <Expanded>\n+          6 == 6\n+        </Expanded>\n+      </Expression>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.capacity() >= V\n+        </Original>\n+        <Expanded>\n+          6 >= 6\n+        </Expanded>\n+      </Expression>\n+      <Section name=\"resizing smaller changes size but not capacity\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.size() == 0\n+          </Original>\n+          <Expanded>\n+            0 == 0\n+          </Expanded>\n+        </Expression>\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.capacity() >= V\n+          </Original>\n+          <Expanded>\n+            6 >= 6\n+          </Expanded>\n+        </Expression>\n+        <Section name=\"We can use the 'swap trick' to reset the capacity\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+            <Original>\n+              v.capacity() == 0\n+            </Original>\n+            <Expanded>\n+              0 == 0\n+            </Expanded>\n+          </Expression>\n+          <OverallResults successes=\"1\" failures=\"0\" expectedFailures=\"0\"/>\n+        </Section>\n+        <OverallResults successes=\"3\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.size() == V\n+        </Original>\n+        <Expanded>\n+          6 == 6\n+        </Expanded>\n+      </Expression>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.capacity() >= V\n+        </Original>\n+        <Expanded>\n+          6 >= 6\n+        </Expanded>\n+      </Expression>\n+      <Section name=\"reserving bigger changes capacity but not size\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.size() == V\n+          </Original>\n+          <Expanded>\n+            6 == 6\n+          </Expanded>\n+        </Expression>\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.capacity() >= 2 * V\n+          </Original>\n+          <Expanded>\n+            12 >= 12\n+          </Expanded>\n+        </Expression>\n+        <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.size() == V\n+        </Original>\n+        <Expanded>\n+          6 == 6\n+        </Expanded>\n+      </Expression>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.capacity() >= V\n+        </Original>\n+        <Expanded>\n+          6 >= 6\n+        </Expanded>\n+      </Expression>\n+      <Section name=\"reserving smaller does not change size or capacity\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.size() == V\n+          </Original>\n+          <Expanded>\n+            6 == 6\n+          </Expanded>\n+        </Expression>\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.capacity() >= V\n+          </Original>\n+          <Expanded>\n+            6 >= 6\n+          </Expanded>\n+        </Expression>\n+        <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n+    <TestCase name=\"TemplateTestSig: vectors can be sized and resized - float,4\" tags=\"[nttp][template][vector]\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.size() == V\n+        </Original>\n+        <Expanded>\n+          4 == 4\n+        </Expanded>\n+      </Expression>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.capacity() >= V\n+        </Original>\n+        <Expanded>\n+          4 >= 4\n+        </Expanded>\n+      </Expression>\n+      <Section name=\"resizing bigger changes size and capacity\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.size() == 2 * V\n+          </Original>\n+          <Expanded>\n+            8 == 8\n+          </Expanded>\n+        </Expression>\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.capacity() >= 2 * V\n+          </Original>\n+          <Expanded>\n+            8 >= 8\n+          </Expanded>\n+        </Expression>\n+        <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.size() == V\n+        </Original>\n+        <Expanded>\n+          4 == 4\n+        </Expanded>\n+      </Expression>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.capacity() >= V\n+        </Original>\n+        <Expanded>\n+          4 >= 4\n+        </Expanded>\n+      </Expression>\n+      <Section name=\"resizing smaller changes size but not capacity\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.size() == 0\n+          </Original>\n+          <Expanded>\n+            0 == 0\n+          </Expanded>\n+        </Expression>\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.capacity() >= V\n+          </Original>\n+          <Expanded>\n+            4 >= 4\n+          </Expanded>\n+        </Expression>\n+        <Section name=\"We can use the 'swap trick' to reset the capacity\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+            <Original>\n+              v.capacity() == 0\n+            </Original>\n+            <Expanded>\n+              0 == 0\n+            </Expanded>\n+          </Expression>\n+          <OverallResults successes=\"1\" failures=\"0\" expectedFailures=\"0\"/>\n+        </Section>\n+        <OverallResults successes=\"3\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.size() == V\n+        </Original>\n+        <Expanded>\n+          4 == 4\n+        </Expanded>\n+      </Expression>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.capacity() >= V\n+        </Original>\n+        <Expanded>\n+          4 >= 4\n+        </Expanded>\n+      </Expression>\n+      <Section name=\"reserving bigger changes capacity but not size\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.size() == V\n+          </Original>\n+          <Expanded>\n+            4 == 4\n+          </Expanded>\n+        </Expression>\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.capacity() >= 2 * V\n+          </Original>\n+          <Expanded>\n+            8 >= 8\n+          </Expanded>\n+        </Expression>\n+        <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.size() == V\n+        </Original>\n+        <Expanded>\n+          4 == 4\n+        </Expanded>\n+      </Expression>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.capacity() >= V\n+        </Original>\n+        <Expanded>\n+          4 >= 4\n+        </Expanded>\n+      </Expression>\n+      <Section name=\"reserving smaller does not change size or capacity\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.size() == V\n+          </Original>\n+          <Expanded>\n+            4 == 4\n+          </Expanded>\n+        </Expression>\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.capacity() >= V\n+          </Original>\n+          <Expanded>\n+            4 >= 4\n+          </Expanded>\n+        </Expression>\n+        <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n+    <TestCase name=\"TemplateTestSig: vectors can be sized and resized - int,5\" tags=\"[nttp][template][vector]\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.size() == V\n+        </Original>\n+        <Expanded>\n+          5 == 5\n+        </Expanded>\n+      </Expression>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.capacity() >= V\n+        </Original>\n+        <Expanded>\n+          5 >= 5\n+        </Expanded>\n+      </Expression>\n+      <Section name=\"resizing bigger changes size and capacity\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.size() == 2 * V\n+          </Original>\n+          <Expanded>\n+            10 == 10\n+          </Expanded>\n+        </Expression>\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.capacity() >= 2 * V\n+          </Original>\n+          <Expanded>\n+            10 >= 10\n+          </Expanded>\n+        </Expression>\n+        <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.size() == V\n+        </Original>\n+        <Expanded>\n+          5 == 5\n+        </Expanded>\n+      </Expression>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.capacity() >= V\n+        </Original>\n+        <Expanded>\n+          5 >= 5\n+        </Expanded>\n+      </Expression>\n+      <Section name=\"resizing smaller changes size but not capacity\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.size() == 0\n+          </Original>\n+          <Expanded>\n+            0 == 0\n+          </Expanded>\n+        </Expression>\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.capacity() >= V\n+          </Original>\n+          <Expanded>\n+            5 >= 5\n+          </Expanded>\n+        </Expression>\n+        <Section name=\"We can use the 'swap trick' to reset the capacity\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+            <Original>\n+              v.capacity() == 0\n+            </Original>\n+            <Expanded>\n+              0 == 0\n+            </Expanded>\n+          </Expression>\n+          <OverallResults successes=\"1\" failures=\"0\" expectedFailures=\"0\"/>\n+        </Section>\n+        <OverallResults successes=\"3\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.size() == V\n+        </Original>\n+        <Expanded>\n+          5 == 5\n+        </Expanded>\n+      </Expression>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.capacity() >= V\n+        </Original>\n+        <Expanded>\n+          5 >= 5\n+        </Expanded>\n+      </Expression>\n+      <Section name=\"reserving bigger changes capacity but not size\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.size() == V\n+          </Original>\n+          <Expanded>\n+            5 == 5\n+          </Expanded>\n+        </Expression>\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.capacity() >= 2 * V\n+          </Original>\n+          <Expanded>\n+            10 >= 10\n+          </Expanded>\n+        </Expression>\n+        <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.size() == V\n+        </Original>\n+        <Expanded>\n+          5 == 5\n+        </Expanded>\n+      </Expression>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.capacity() >= V\n+        </Original>\n+        <Expanded>\n+          5 >= 5\n+        </Expanded>\n+      </Expression>\n+      <Section name=\"reserving smaller does not change size or capacity\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.size() == V\n+          </Original>\n+          <Expanded>\n+            5 == 5\n+          </Expanded>\n+        </Expression>\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.capacity() >= V\n+          </Original>\n+          <Expanded>\n+            5 >= 5\n+          </Expanded>\n+        </Expression>\n+        <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n+    <TestCase name=\"TemplateTestSig: vectors can be sized and resized - std::string,15\" tags=\"[nttp][template][vector]\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.size() == V\n+        </Original>\n+        <Expanded>\n+          15 == 15\n+        </Expanded>\n+      </Expression>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.capacity() >= V\n+        </Original>\n+        <Expanded>\n+          15 >= 15\n+        </Expanded>\n+      </Expression>\n+      <Section name=\"resizing bigger changes size and capacity\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.size() == 2 * V\n+          </Original>\n+          <Expanded>\n+            30 == 30\n+          </Expanded>\n+        </Expression>\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.capacity() >= 2 * V\n+          </Original>\n+          <Expanded>\n+            30 >= 30\n+          </Expanded>\n+        </Expression>\n+        <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.size() == V\n+        </Original>\n+        <Expanded>\n+          15 == 15\n+        </Expanded>\n+      </Expression>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.capacity() >= V\n+        </Original>\n+        <Expanded>\n+          15 >= 15\n+        </Expanded>\n+      </Expression>\n+      <Section name=\"resizing smaller changes size but not capacity\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.size() == 0\n+          </Original>\n+          <Expanded>\n+            0 == 0\n+          </Expanded>\n+        </Expression>\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.capacity() >= V\n+          </Original>\n+          <Expanded>\n+            15 >= 15\n+          </Expanded>\n+        </Expression>\n+        <Section name=\"We can use the 'swap trick' to reset the capacity\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+            <Original>\n+              v.capacity() == 0\n+            </Original>\n+            <Expanded>\n+              0 == 0\n+            </Expanded>\n+          </Expression>\n+          <OverallResults successes=\"1\" failures=\"0\" expectedFailures=\"0\"/>\n+        </Section>\n+        <OverallResults successes=\"3\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.size() == V\n+        </Original>\n+        <Expanded>\n+          15 == 15\n+        </Expanded>\n+      </Expression>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.capacity() >= V\n+        </Original>\n+        <Expanded>\n+          15 >= 15\n+        </Expanded>\n+      </Expression>\n+      <Section name=\"reserving bigger changes capacity but not size\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.size() == V\n+          </Original>\n+          <Expanded>\n+            15 == 15\n+          </Expanded>\n+        </Expression>\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.capacity() >= 2 * V\n+          </Original>\n+          <Expanded>\n+            30 >= 30\n+          </Expanded>\n+        </Expression>\n+        <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.size() == V\n+        </Original>\n+        <Expanded>\n+          15 == 15\n+        </Expanded>\n+      </Expression>\n+      <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Original>\n+          v.capacity() >= V\n+        </Original>\n+        <Expanded>\n+          15 >= 15\n+        </Expanded>\n+      </Expression>\n+      <Section name=\"reserving smaller does not change size or capacity\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.size() == V\n+          </Original>\n+          <Expanded>\n+            15 == 15\n+          </Expanded>\n+        </Expression>\n+        <Expression success=\"true\" type=\"REQUIRE\" filename=\"projects/<exe-name>/UsageTests/Misc.tests.cpp\" >\n+          <Original>\n+            v.capacity() >= V\n+          </Original>\n+          <Expanded>\n+            15 >= 15\n+          </Expanded>\n+        </Expression>\n+        <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n     <TestCase name=\"Test case with one argument\" filename=\"projects/<exe-name>/UsageTests/VariadicMacros.tests.cpp\" >\n       <OverallResult success=\"true\"/>\n     </TestCase>\n@@ -13772,7 +14586,7 @@ loose text artifact\n       </Section>\n       <OverallResult success=\"true\"/>\n     </TestCase>\n-    <OverallResults successes=\"1308\" failures=\"142\" expectedFailures=\"21\"/>\n+    <OverallResults successes=\"1387\" failures=\"149\" expectedFailures=\"21\"/>\n   </Group>\n-  <OverallResults successes=\"1308\" failures=\"141\" expectedFailures=\"21\"/>\n+  <OverallResults successes=\"1387\" failures=\"148\" expectedFailures=\"21\"/>\n </Catch>\n", "test_patch": "diff --git a/docs/test-cases-and-sections.md b/docs/test-cases-and-sections.md\nindex 62a805f49e..8a494b5c83 100644\n--- a/docs/test-cases-and-sections.md\n+++ b/docs/test-cases-and-sections.md\n@@ -6,6 +6,7 @@\n [Tag aliases](#tag-aliases)<br>\n [BDD-style test cases](#bdd-style-test-cases)<br>\n [Type parametrised test cases](#type-parametrised-test-cases)<br>\n+[Signature based parametrised test cases](#signature-based-parametrised-test-cases)<br>\n \n While Catch fully supports the traditional, xUnit, style of class-based fixtures containing test case methods this is not the preferred style.\n \n@@ -191,6 +192,56 @@ _While there is an upper limit on the number of types you can specify\n in single `TEMPLATE_TEST_CASE` or `TEMPLATE_PRODUCT_TEST_CASE`, the limit\n is very high and should not be encountered in practice._\n \n+\n+## Signature based parametrised test cases\n+\n+In addition to [type parametrised test cases](#type-parametrised-test-cases) Catch2 also supports\n+signature base parametrised test cases, in form of `TEMPLATE_TEST_CASE_SIG` and `TEMPLATE_PRODUCT_TEST_CASE_SIG`.\n+These test cases have similar syntax like [type parametrised test cases](#type-parametrised-test-cases), with one\n+additional positional argument which specifies the signature.\n+\n+### Signature\n+Signature has some strict rules for these tests cases to work properly:\n+* signature with multiple template parameters e.g. `typename T, size_t S` must have this format in test case declaration\n+  `((typename T, size_t S), T, S)`\n+* signature with variadic template arguments e.g. `typename T, size_t S, typename...Ts` must have this format in test case declaration\n+  `((typename T, size_t S, typename...Ts), T, S, Ts...)`\n+* signature with single non type template parameter e.g. `int V` must have this format in test case declaration `((int V), V)`\n+* signature with single type template parameter e.g. `typename T` should not be used as it is in fact `TEMPLATE_TEST_CASE`\n+\n+Currently Catch2 support up to 11 template parameters in signature\n+\n+### Examples\n+\n+* **TEMPLATE_TEST_CASE_SIG(** _test name_ , _tags_,  _signature_, _type1_, _type2_, ..., _typen_ **)**\n+\n+Inside `TEMPLATE_TEST_CASE_SIG` test case you can use the names of template parameters as defined in _signature_. \n+\n+```cpp\n+TEMPLATE_TEST_CASE_SIG(\"TemplateTestSig: arrays can be created from NTTP arguments\", \"[vector][template][nttp]\",\n+  ((typename T, int V), T, V), (int,5), (float,4), (std::string,15), ((std::tuple<int, float>), 6)) {\n+\n+    std::array<T, V> v;\n+    REQUIRE(v.size() > 1);\n+}\n+```\n+\n+* **TEMPLATE_PRODUCT_TEST_CASE_SIG(** _test name_ , _tags_, _signature_, (_template-type1_, _template-type2_, ..., _template-typen_), (_template-arg1_, _template-arg2_, ..., _template-argm_) **)**\n+\n+```cpp\n+\n+template<typename T, size_t S>\n+struct Bar {\n+    size_t size() { return S; }\n+};\n+\n+TEMPLATE_PRODUCT_TEST_CASE_SIG(\"A Template product test case with array signature\", \"[template][product][nttp]\", ((typename T, size_t S), T, S), (std::array, Bar), ((int, 9), (float, 42))) {\n+    TestType x;\n+    REQUIRE(x.size() > 0);\n+}\n+```\n+\n+\n ---\n \n [Home](Readme.md#top)\ndiff --git a/docs/test-fixtures.md b/docs/test-fixtures.md\nindex 6b29ce68b1..5a2d4df5ab 100644\n--- a/docs/test-fixtures.md\n+++ b/docs/test-fixtures.md\n@@ -84,6 +84,33 @@ _While there is an upper limit on the number of types you can specify\n in single `TEMPLATE_TEST_CASE_METHOD` or `TEMPLATE_PRODUCT_TEST_CASE_METHOD`,\n the limit is very high and should not be encountered in practice._\n \n+\n+Catch2 also provides `TEMPLATE_TEST_CASE_METHOD_SIG` and `TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG` to support\n+fixtures using non-type template parameters. These test cases work similar to `TEMPLATE_TEST_CASE_METHOD` and `TEMPLATE_PRODUCT_TEST_CASE_METHOD`,\n+with additional positional argument for [signature](test-cases-and-sections.md#signature-based-parametrised-test-cases).\n+\n+Example:\n+```cpp\n+template <int V>\n+struct Nttp_Fixture{\n+    int value = V;\n+};\n+\n+TEMPLATE_TEST_CASE_METHOD_SIG(Nttp_Fixture, \"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds\", \"[class][template][nttp]\",((int V), V), 1, 3, 6) {\n+    REQUIRE(Nttp_Fixture<V>::value > 0);\n+}\n+\n+template< typename T, size_t V>\n+struct Template_Foo_2 {\n+    size_t size() { return V; }\n+};\n+\n+TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds\", \"[class][template][product][nttp]\", ((typename T, size_t S), T, S),(std::array, Template_Foo_2), ((int,2), (float,6)))\n+{\n+    REQUIRE(Template_Fixture_2<TestType>{}.m_a.size() >= 2);\n+}\n+```\n+\n ---\n \n [Home](Readme.md#top)\ndiff --git a/include/internal/catch_test_registry.h b/include/internal/catch_test_registry.h\nindex feae962d92..cfb56bd79b 100644\n--- a/include/internal/catch_test_registry.h\n+++ b/include/internal/catch_test_registry.h\n@@ -60,18 +60,47 @@ struct AutoReg : NonCopyable {\n             };                            \\\n         }                                 \\\n         void TestName::test()\n-    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION( TestName, ... )  \\\n-        template<typename TestType>                                             \\\n-        static void TestName()\n-    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( TestName, ClassName, ... )    \\\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( TestName, TestFunc, Name, Tags, Signature, ... )  \\\n+        INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature))\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... )    \\\n         namespace{                                                                                  \\\n-            template<typename TestType>                                                             \\\n-            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) {     \\\n-                void test();                                                                        \\\n-            };                                                                                      \\\n+            namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                      \\\n+            INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\\n         }                                                                                           \\\n-        template<typename TestType>                                                                 \\\n-        void TestName::test()\n+        }                                                                                           \\\n+        INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\n+\n+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \\\n+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )\n+    #else\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \\\n+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )\n+    #endif  \n+\n+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \\\n+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )\n+    #else\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \\\n+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )\n+    #endif\n+\n+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \\\n+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )\n+    #else\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \\\n+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )\n+    #endif\n+\n+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \\\n+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )\n+    #else\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \\\n+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )\n+    #endif\n #endif\n \n     ///////////////////////////////////////////////////////////////////////////////\n@@ -111,46 +140,61 @@ struct AutoReg : NonCopyable {\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\n \n     ///////////////////////////////////////////////////////////////////////////////\n-    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, ... )\\\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, Signature, ... )\\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n-        template<typename TestType> \\\n-        static void TestFunc();\\\n+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+        INTERNAL_CATCH_DECLARE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\\n         namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\\\n+            INTERNAL_CATCH_TYPE_GEN\\\n+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n+            INTERNAL_CATCH_NTTP_REG_GEN(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n             template<typename...Types> \\\n             struct TestName{\\\n-                template<typename...Ts> \\\n-                TestName(Ts...names){\\\n+                TestName(){\\\n+                    int index = 0;                                    \\\n+                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\\\n                     using expander = int[];\\\n-                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestFunc<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ names, Tags } ), 0)... };/* NOLINT */ \\\n+                    (void)expander{(reg_test(Types{}, Catch::NameAndTags{ Name \" - \" + std::string(tmpl_types[index]), Tags } ), index++, 0)... };/* NOLINT */ \\\n                 }\\\n             };\\\n-            INTERNAL_CATCH_TEMPLATE_REGISTRY_INITIATE(TestName, Name, __VA_ARGS__) \\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n+            TestName<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\\\n+            return 0;\\\n+        }();\\\n+        }\\\n         }\\\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n-        template<typename TestType> \\\n-        static void TestFunc()\n+        CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+        INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \\\n-        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, __VA_ARGS__ )\n+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )\n #else\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \\\n-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, __VA_ARGS__ ) )\n-#endif\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )\n+#endif  \n \n-    #define INTERNAL_CATCH_TEMPLATE_REGISTRY_INITIATE(TestName, Name, ...)\\\n-        static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n-            TestName<CATCH_REC_LIST(INTERNAL_CATCH_REMOVE_PARENS, __VA_ARGS__)>(CATCH_REC_LIST_UD(INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME,Name, __VA_ARGS__));\\\n-            return 0;\\\n-        }();\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \\\n+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )\n+#endif\n \n-    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, TmplTypes, TypesList) \\\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, Signature, TmplTypes, TypesList) \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                      \\\n+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS                \\\n         template<typename TestType> static void TestFuncName();       \\\n-        namespace {                                                   \\\n+        namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                     \\\n+            INTERNAL_CATCH_TYPE_GEN                                                  \\\n+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))         \\\n             template<typename... Types>                               \\\n             struct TestName {                                         \\\n-                TestName() {                                          \\\n+                void reg_tests() {                                          \\\n                     int index = 0;                                    \\\n                     using expander = int[];                           \\\n                     constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\\\n@@ -160,63 +204,92 @@ struct AutoReg : NonCopyable {\n                 }                                                     \\\n             };                                                        \\\n             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \\\n-                using TestInit = Catch::combine<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)> \\\n-                            ::with_types<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(TypesList)>::into<TestName>::type; \\\n-                TestInit();                                           \\\n+                using TestInit = decltype(create<TestName, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>(TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>{})); \\\n+                TestInit t;                                           \\\n+                t.reg_tests();                                        \\\n                 return 0;                                             \\\n             }();                                                      \\\n         }                                                             \\\n+        }                                                             \\\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS                    \\\n+        CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS              \\\n         template<typename TestType>                                   \\\n         static void TestFuncName()\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\\n-        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ),Name,Tags,__VA_ARGS__)\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T,__VA_ARGS__)\n #else\n     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\\n-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, __VA_ARGS__ ) )\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T, __VA_ARGS__ ) )\n+#endif\n+\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\\\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__)\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )\n #endif\n \n-    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, ... ) \\\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n-        namespace{ \\\n-            template<typename TestType> \\\n-            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \\\n-                void test();\\\n-            };\\\n+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+        namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \\\n+            INTERNAL_CATCH_TYPE_GEN\\\n+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n+            INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\\n+            INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n             template<typename...Types> \\\n             struct TestNameClass{\\\n-                template<typename...Ts> \\\n-                TestNameClass(Ts...names){\\\n+                TestNameClass(){\\\n+                    int index = 0;                                    \\\n+                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\\\n                     using expander = int[];\\\n-                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ names, Tags } ), 0)... };/* NOLINT */ \\\n+                    (void)expander{(reg_test(Types{}, #ClassName, Catch::NameAndTags{ Name \" - \" + std::string(tmpl_types[index]), Tags } ), index++, 0)... };/* NOLINT */ \\\n                 }\\\n             };\\\n-            INTERNAL_CATCH_TEMPLATE_REGISTRY_INITIATE(TestNameClass, Name, __VA_ARGS__)\\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n+                TestNameClass<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\\\n+                return 0;\\\n+        }();\\\n+        }\\\n         }\\\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\\\n-        template<typename TestType> \\\n-        void TestName<TestType>::test()\n+        CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS\\\n+        INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \\\n-        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, __VA_ARGS__ )\n+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )\n #else\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \\\n-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, __VA_ARGS__ ) )\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )\n #endif\n \n-    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, TmplTypes, TypesList)\\\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \\\n+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )\n+#endif\n+\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, Signature, TmplTypes, TypesList)\\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n         template<typename TestType> \\\n             struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \\\n                 void test();\\\n             };\\\n         namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestNameClass) {\\\n+            INTERNAL_CATCH_TYPE_GEN                  \\\n+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n             template<typename...Types>\\\n             struct TestNameClass{\\\n-                TestNameClass(){\\\n+                void reg_tests(){\\\n                     int index = 0;\\\n                     using expander = int[];\\\n                     constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\\\n@@ -226,22 +299,33 @@ struct AutoReg : NonCopyable {\n                 }\\\n             };\\\n             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n-                using TestInit = Catch::combine<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>\\\n-                            ::with_types<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(TypesList)>::into<TestNameClass>::type;\\\n-                TestInit();\\\n+                using TestInit = decltype(create<TestNameClass, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>(TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>{}));\\\n+                TestInit t;\\\n+                t.reg_tests();\\\n                 return 0;\\\n             }(); \\\n         }\\\n+        }\\\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n+        CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS \\\n         template<typename TestType> \\\n         void TestName<TestType>::test()\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\\n-        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, __VA_ARGS__ )\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T, __VA_ARGS__ )\n #else\n     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\\n-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, __VA_ARGS__ ) )\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T,__VA_ARGS__ ) )\n #endif\n \n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\\\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature, __VA_ARGS__ )\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature,__VA_ARGS__ ) )\n+#endif\n+\n+\n #endif // TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED\ndiff --git a/projects/SelfTest/UsageTests/Class.tests.cpp b/projects/SelfTest/UsageTests/Class.tests.cpp\nindex 3bde1d82ab..815bb4fd0b 100644\n--- a/projects/SelfTest/UsageTests/Class.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Class.tests.cpp\n@@ -7,6 +7,7 @@\n  */\n \n #include \"catch.hpp\"\n+#include <array>\n \n namespace{ namespace ClassTests {\n \n@@ -58,6 +59,15 @@ struct Template_Foo {\n     size_t size() { return 0; }\n };\n \n+template< typename T, size_t V>\n+struct Template_Foo_2 {\n+    size_t size() { return V; }\n+};\n+\n+template <int V>\n+struct Nttp_Fixture{\n+    int value = V;\n+};\n #endif\n \n \n@@ -74,11 +84,20 @@ TEMPLATE_TEST_CASE_METHOD(Template_Fixture, \"A TEMPLATE_TEST_CASE_METHOD based t\n     REQUIRE( Template_Fixture<TestType>::m_a == 1 );\n }\n \n+TEMPLATE_TEST_CASE_METHOD_SIG(Nttp_Fixture, \"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds\", \"[class][template][nttp]\",((int V), V), 1, 3, 6) {\n+    REQUIRE(Nttp_Fixture<V>::value > 0);\n+}\n+\n TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that succeeds\",\"[class][template][product]\",(std::vector,Template_Foo),(int,float))\n {\n     REQUIRE( Template_Fixture_2<TestType>::m_a.size() == 0 );\n }\n \n+TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds\", \"[class][template][product][nttp]\", ((typename T, size_t S), T, S),(std::array, Template_Foo_2), ((int,2), (float,6)))\n+{\n+    REQUIRE(Template_Fixture_2<TestType>{}.m_a.size() >= 2);\n+}\n+\n // We should be able to write our tests within a different namespace\n namespace Inner\n {\n@@ -92,10 +111,19 @@ namespace Inner\n         REQUIRE( Template_Fixture<TestType>::m_a == 2 );\n     }\n \n+    TEMPLATE_TEST_CASE_METHOD_SIG(Nttp_Fixture, \"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that fails\", \"[.][class][template][nttp][failing]\", ((int V), V), 1, 3, 6) {\n+        REQUIRE(Nttp_Fixture<V>::value == 0);\n+    }\n+\n     TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that fails\",\"[.][class][template][product][failing]\",(std::vector,Template_Foo),(int,float))\n     {\n         REQUIRE( Template_Fixture_2<TestType>::m_a.size() == 1 );\n     }\n+\n+    TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails\", \"[.][class][template][product][nttp][failing]\", ((typename T, size_t S), T, S), (std::array, Template_Foo_2), ((int, 2), (float, 6)))\n+    {\n+        REQUIRE(Template_Fixture_2<TestType>{}.m_a.size() < 2);\n+    }\n }\n \n \ndiff --git a/projects/SelfTest/UsageTests/Misc.tests.cpp b/projects/SelfTest/UsageTests/Misc.tests.cpp\nindex 4de6f1aa0d..9a87169b93 100644\n--- a/projects/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Misc.tests.cpp\n@@ -18,6 +18,7 @@\n #include <cerrno>\n #include <limits>\n #include <sstream>\n+#include <array>\n \n namespace { namespace MiscTests {\n \n@@ -66,6 +67,10 @@ struct Foo {\n     size_t size() { return 0; }\n };\n \n+template<typename T, size_t S>\n+struct Bar {\n+    size_t size() { return S; }\n+};\n #endif\n \n TEST_CASE( \"random SECTION tests\", \"[.][sections][failing]\" ) {\n@@ -306,11 +311,56 @@ TEMPLATE_TEST_CASE( \"TemplateTest: vectors can be sized and resized\", \"[vector][\n     }\n }\n \n+TEMPLATE_TEST_CASE_SIG(\"TemplateTestSig: vectors can be sized and resized\", \"[vector][template][nttp]\", ((typename TestType, int V), TestType, V), (int,5), (float,4), (std::string,15), ((std::tuple<int, float>), 6)) {\n+\n+    std::vector<TestType> v(V);\n+\n+    REQUIRE(v.size() == V);\n+    REQUIRE(v.capacity() >= V);\n+\n+    SECTION(\"resizing bigger changes size and capacity\") {\n+        v.resize(2 * V);\n+\n+        REQUIRE(v.size() == 2 * V);\n+        REQUIRE(v.capacity() >= 2 * V);\n+    }\n+    SECTION(\"resizing smaller changes size but not capacity\") {\n+        v.resize(0);\n+\n+        REQUIRE(v.size() == 0);\n+        REQUIRE(v.capacity() >= V);\n+\n+        SECTION(\"We can use the 'swap trick' to reset the capacity\") {\n+            std::vector<TestType> empty;\n+            empty.swap(v);\n+\n+            REQUIRE(v.capacity() == 0);\n+        }\n+    }\n+    SECTION(\"reserving bigger changes capacity but not size\") {\n+        v.reserve(2 * V);\n+\n+        REQUIRE(v.size() == V);\n+        REQUIRE(v.capacity() >= 2 * V);\n+    }\n+    SECTION(\"reserving smaller does not change size or capacity\") {\n+        v.reserve(0);\n+\n+        REQUIRE(v.size() == V);\n+        REQUIRE(v.capacity() >= V);\n+    }\n+}\n+\n TEMPLATE_PRODUCT_TEST_CASE(\"A Template product test case\", \"[template][product]\", (std::vector, Foo), (int, float)) {\n     TestType x;\n     REQUIRE(x.size() == 0);\n }\n \n+TEMPLATE_PRODUCT_TEST_CASE_SIG(\"A Template product test case with array signature\", \"[template][product][nttp]\", ((typename T, size_t S), T, S), (std::array, Bar), ((int, 9), (float, 42))) {\n+    TestType x;\n+    REQUIRE(x.size() > 0);\n+}\n+\n TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product]\", std::tuple, (int, (int, double), (int, double, float))) {\n     REQUIRE(std::tuple_size<TestType>::value >= 1);\n }\n", "fixed_tests": {"approvaltests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "noassertions": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtags": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "notest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtestnamesonly": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listreporters": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "p2p_tests": {}, "f2p_tests": {}, "s2p_tests": {}, "n2p_tests": {"approvaltests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "noassertions": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtags": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "notest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-1": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listtestnamesonly": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "filteredsection-2": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "listreporters": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "run_result": {"passed_count": 10, "failed_count": 0, "skipped_count": 0, "passed_tests": ["approvaltests", "noassertions", "runtests", "listtags", "listreporters", "listtests", "notest", "filteredsection-1", "filteredsection-2", "listtestnamesonly"], "failed_tests": [], "skipped_tests": []}, "test_patch_result": {"passed_count": 0, "failed_count": 0, "skipped_count": 0, "passed_tests": [], "failed_tests": [], "skipped_tests": []}, "fix_patch_result": {"passed_count": 10, "failed_count": 0, "skipped_count": 0, "passed_tests": ["approvaltests", "noassertions", "runtests", "listtags", "listreporters", "listtests", "notest", "filteredsection-1", "filteredsection-2", "listtestnamesonly"], "failed_tests": [], "skipped_tests": []}, "instance_id": "catchorg__Catch2-1609"}
{"org": "catchorg", "repo": "Catch2", "number": 1608, "state": "closed", "title": "Allow quotes in CAPTURE arguments", "body": "Simple fix to allow CAPTURE to handle string with comma. Also ignores\r\nbrackets in string. No quotation mark escaping is implemented, so `\"\\\"\"`\r\nand `'\"'` will still fail.\r\n\r\nFixes #1607 \r\n\r\nI can improve parsing algorithm to handle single and double quotes correctly, but that is probably overkill ...\r\n\r\n\r\n", "base": {"label": "catchorg:master", "ref": "master", "sha": "979bbf03bb00bc55ca09783791b5091a2247df68"}, "resolved_issues": [{"number": 1607, "title": "CAPTURE(\"text, with comma\") fails", "body": "**Describe the bug**\r\nWhen string containing comma is passed to CAPTURE and test succeeds, the program will fail assertion \r\n`Capturer::~Capturer() : assert( m_captured == m_messages.size() );`\r\n\r\n**Expected behavior**\r\nDocumenting this behavior is probably enough. CAPTURE((\"test, with comma\")) works as expected. \r\n\r\n**Reproduction steps**\r\n```\r\nTEST_CASE(\"catch\") {\r\n  CAPTURE(\"test, with comma\");\r\n  CHECK(false);\r\n  CAPTURE(\"test, with comma\");\r\n  CHECK(true);\r\n}\r\n```\r\nproduces:\r\n```\r\ntest/test_suite.cpp:35: FAILED:\r\n  CHECK( false )\r\nwith message:\r\n  \"test := \"test, with comma\"\r\n\r\ntest_suite: test/catch.hpp:9638: Catch::Capturer::~Capturer(): Assertion `m_captured == m_messages.size()' failed.\r\n```\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: **Debian stretch**\r\n - Compiler+version: **gcc (Debian 6.3.0-18+deb9u1) 6.3.0 20170516**\r\n - Catch version: **Catch v2.7.0**\r\n\r\n\r\n**Additional context**\r\nCapturer::Capturer() does not expect quotation in names. It should be quite easy to fix (just add `bool isquoted` into parsing algorithm.\r\n\r\nBTW: Capturing string is quite useful when capturing __VA_ARGS__ in macro ... \r\n"}], "fix_patch": "diff --git a/include/internal/catch_message.cpp b/include/internal/catch_message.cpp\nindex fa7e874614..69e48211f6 100644\n--- a/include/internal/catch_message.cpp\n+++ b/include/internal/catch_message.cpp\n@@ -9,6 +9,7 @@\n #include \"catch_message.h\"\n #include \"catch_interfaces_capture.h\"\n #include \"catch_uncaught_exceptions.h\"\n+#include \"catch_enforce.h\"\n \n #include <cassert>\n #include <stack>\n@@ -76,6 +77,15 @@ namespace Catch {\n             }\n             return names.substr(start, end - start + 1);\n         };\n+        auto skipq = [&] (size_t start, char quote) {\n+            for (auto i = start + 1; i < names.size() ; ++i) {\n+                if (names[i] == quote)\n+                    return i;\n+                if (names[i] == '\\\\')\n+                    ++i;\n+            }\n+            CATCH_INTERNAL_ERROR(\"CAPTURE parsing encountered unmatched parentheses\");\n+        };\n \n         size_t start = 0;\n         std::stack<char> openings;\n@@ -96,6 +106,10 @@ namespace Catch {\n //           case '>':\n                 openings.pop();\n                 break;\n+            case '\"':\n+            case '\\'':\n+                pos = skipq(pos, c);\n+                break;\n             case ',':\n                 if (start != pos && openings.size() == 0) {\n                     m_messages.emplace_back(macroName, lineInfo, resultType);\ndiff --git a/projects/SelfTest/Baselines/compact.sw.approved.txt b/projects/SelfTest/Baselines/compact.sw.approved.txt\nindex 3755dd955d..259954e4b8 100644\n--- a/projects/SelfTest/Baselines/compact.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/compact.sw.approved.txt\n@@ -230,6 +230,7 @@ Tricky.tests.cpp:<line number>: passed: y.v == 0 for: 0 == 0\n Tricky.tests.cpp:<line number>: passed: 0 == y.v for: 0 == 0\n Message.tests.cpp:<line number>: passed: with 7 messages: 'a := 1' and 'b := 2' and 'c := 3' and 'a + b := 3' and 'a+b := 3' and 'c > b := true' and 'a == 1 := true'\n Message.tests.cpp:<line number>: passed: with 7 messages: 'std::vector<int>{1, 2, 3}[0, 1, 2] := 3' and 'std::vector<int>{1, 2, 3}[(0, 1)] := 2' and 'std::vector<int>{1, 2, 3}[0] := 1' and '(helper_1436<int, int>{12, -12}) := { 12, -12 }' and '(helper_1436<int, int>(-12, 12)) := { -12, 12 }' and '(1, 2) := 2' and '(2, 3) := 3'\n+Message.tests.cpp:<line number>: passed: with 11 messages: '(\"comma, in string\", \"escaped, \\\", \") := \"escaped, \", \"' and '\"single quote in string,',\" := \"single quote in string,',\"' and '\"some escapes, \\\\,\\\\\\\\\" := \"some escapes, \\,\\\\\"' and '\"some, ), unmatched, } prenheses {[<\" := \"some, ), unmatched, } prenheses {[<\"' and ''\"' := '\"'' and ''\\'' := '''' and '',' := ','' and ''}' := '}'' and '')' := ')'' and ''(' := '('' and ''{' := '{''\n ToStringGeneral.tests.cpp:<line number>: passed: true with 1 message: 'i := 2'\n ToStringGeneral.tests.cpp:<line number>: passed: true with 1 message: '3'\n ToStringGeneral.tests.cpp:<line number>: passed: tab == '\\t' for: '\\t' == '\\t'\ndiff --git a/projects/SelfTest/Baselines/console.std.approved.txt b/projects/SelfTest/Baselines/console.std.approved.txt\nindex 8e86cb2eeb..0a4de92369 100644\n--- a/projects/SelfTest/Baselines/console.std.approved.txt\n+++ b/projects/SelfTest/Baselines/console.std.approved.txt\n@@ -1299,6 +1299,6 @@ due to unexpected exception with message:\n   Why would you throw a std::string?\n \n ===============================================================================\n-test cases:  265 |  198 passed |  63 failed |  4 failed as expected\n-assertions: 1448 | 1303 passed | 124 failed | 21 failed as expected\n+test cases:  266 |  199 passed |  63 failed |  4 failed as expected\n+assertions: 1449 | 1304 passed | 124 failed | 21 failed as expected\n \ndiff --git a/projects/SelfTest/Baselines/console.sw.approved.txt b/projects/SelfTest/Baselines/console.sw.approved.txt\nindex d5c143b256..2b998afc7e 100644\n--- a/projects/SelfTest/Baselines/console.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/console.sw.approved.txt\n@@ -1786,6 +1786,27 @@ with messages:\n   (1, 2) := 2\n   (2, 3) := 3\n \n+-------------------------------------------------------------------------------\n+CAPTURE parses string and character constants\n+-------------------------------------------------------------------------------\n+Message.tests.cpp:<line number>\n+...............................................................................\n+\n+Message.tests.cpp:<line number>: PASSED:\n+with messages:\n+  (\"comma, in string\", \"escaped, \\\", \") := \"escaped, \", \"\n+  \"single quote in string,',\" := \"single quote in string,',\"\n+  \"some escapes, \\\\,\\\\\\\\\" := \"some escapes, \\,\\\\\"\n+  \"some, ), unmatched, } prenheses {[<\" := \"some, ), unmatched, } prenheses {[\n+  <\"\n+  '\"' := '\"'\n+  '\\'' := '''\n+  ',' := ','\n+  '}' := '}'\n+  ')' := ')'\n+  '(' := '('\n+  '{' := '{'\n+\n -------------------------------------------------------------------------------\n Capture and info messages\n   Capture should stringify like assertions\n@@ -11368,6 +11389,6 @@ Misc.tests.cpp:<line number>\n Misc.tests.cpp:<line number>: PASSED:\n \n ===============================================================================\n-test cases:  265 |  182 passed |  79 failed |  4 failed as expected\n-assertions: 1465 | 1303 passed | 141 failed | 21 failed as expected\n+test cases:  266 |  183 passed |  79 failed |  4 failed as expected\n+assertions: 1466 | 1304 passed | 141 failed | 21 failed as expected\n \ndiff --git a/projects/SelfTest/Baselines/junit.sw.approved.txt b/projects/SelfTest/Baselines/junit.sw.approved.txt\nindex 709171f205..7f4b43dbb1 100644\n--- a/projects/SelfTest/Baselines/junit.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/junit.sw.approved.txt\n@@ -1,7 +1,7 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <testsuitesloose text artifact\n >\n-  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"125\" tests=\"1466\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n+  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"125\" tests=\"1467\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n     <properties>\n       <property name=\"filters\" value=\"~[!nonportable]~[!benchmark]~[approvals]\"/>\n       <property name=\"random-seed\" value=\"1\"/>\n@@ -189,6 +189,7 @@ Exception.tests.cpp:<line number>\n     <testcase classname=\"<exe-name>.global\" name=\"Bitfields can be captured (#1027)\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"CAPTURE can deal with complex expressions\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"CAPTURE can deal with complex expressions involving commas\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"CAPTURE parses string and character constants\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Capture and info messages/Capture should stringify like assertions\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Capture and info messages/Info should NOT stringify the way assertions do\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Character pretty printing/Specifically escaped\" time=\"{duration}\"/>\ndiff --git a/projects/SelfTest/Baselines/xml.sw.approved.txt b/projects/SelfTest/Baselines/xml.sw.approved.txt\nindex c704406ff7..fa078ac800 100644\n--- a/projects/SelfTest/Baselines/xml.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/xml.sw.approved.txt\n@@ -2049,6 +2049,42 @@ Nor would this\n       </Info>\n       <OverallResult success=\"true\"/>\n     </TestCase>\n+    <TestCase name=\"CAPTURE parses string and character constants\" tags=\"[capture][messages]\" filename=\"projects/<exe-name>/UsageTests/Message.tests.cpp\" >\n+      <Info>\n+        (\"comma, in string\", \"escaped, \\\", \") := \"escaped, \", \"\n+      </Info>\n+      <Info>\n+        \"single quote in string,',\" := \"single quote in string,',\"\n+      </Info>\n+      <Info>\n+        \"some escapes, \\\\,\\\\\\\\\" := \"some escapes, \\,\\\\\"\n+      </Info>\n+      <Info>\n+        \"some, ), unmatched, } prenheses {[&lt;\" := \"some, ), unmatched, } prenheses {[&lt;\"\n+      </Info>\n+      <Info>\n+        '\"' := '\"'\n+      </Info>\n+      <Info>\n+        '\\'' := '''\n+      </Info>\n+      <Info>\n+        ',' := ','\n+      </Info>\n+      <Info>\n+        '}' := '}'\n+      </Info>\n+      <Info>\n+        ')' := ')'\n+      </Info>\n+      <Info>\n+        '(' := '('\n+      </Info>\n+      <Info>\n+        '{' := '{'\n+      </Info>\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n     <TestCase name=\"Capture and info messages\" filename=\"projects/<exe-name>/UsageTests/ToStringGeneral.tests.cpp\" >\n       <Section name=\"Capture should stringify like assertions\" filename=\"projects/<exe-name>/UsageTests/ToStringGeneral.tests.cpp\" >\n         <Info>\n@@ -13692,7 +13728,7 @@ loose text artifact\n       </Section>\n       <OverallResult success=\"true\"/>\n     </TestCase>\n-    <OverallResults successes=\"1303\" failures=\"142\" expectedFailures=\"21\"/>\n+    <OverallResults successes=\"1304\" failures=\"142\" expectedFailures=\"21\"/>\n   </Group>\n-  <OverallResults successes=\"1303\" failures=\"141\" expectedFailures=\"21\"/>\n+  <OverallResults successes=\"1304\" failures=\"141\" expectedFailures=\"21\"/>\n </Catch>\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/Message.tests.cpp b/projects/SelfTest/UsageTests/Message.tests.cpp\nindex ccb7ac2f0c..933470845b 100644\n--- a/projects/SelfTest/UsageTests/Message.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Message.tests.cpp\n@@ -251,6 +251,13 @@ TEST_CASE(\"CAPTURE can deal with complex expressions involving commas\", \"[messag\n     SUCCEED();\n }\n \n+TEST_CASE(\"CAPTURE parses string and character constants\", \"[messages][capture]\") {\n+    CAPTURE((\"comma, in string\", \"escaped, \\\", \"), \"single quote in string,',\", \"some escapes, \\\\,\\\\\\\\\");\n+    CAPTURE(\"some, ), unmatched, } prenheses {[<\");\n+    CAPTURE('\"', '\\'', ',', '}', ')', '(', '{');\n+    SUCCEED();\n+}\n+\n #ifdef __clang__\n #pragma clang diagnostic pop\n #endif\n", "fixed_tests": {"approvaltests": {"run": "PASS", "test": "FAIL", "fix": "PASS"}, "noassertions": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "p2p_tests": {"listtags": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "listtests": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "notest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "filteredsection-1": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "listtestnamesonly": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "filteredsection-2": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "listreporters": {"run": "PASS", "test": "PASS", "fix": "PASS"}}, "f2p_tests": {"approvaltests": {"run": "PASS", "test": "FAIL", "fix": "PASS"}}, "s2p_tests": {}, "n2p_tests": {"noassertions": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "run_result": {"passed_count": 10, "failed_count": 0, "skipped_count": 0, "passed_tests": ["approvaltests", "noassertions", "runtests", "listtags", "listreporters", "listtests", "notest", "filteredsection-1", "filteredsection-2", "listtestnamesonly"], "failed_tests": [], "skipped_tests": []}, "test_patch_result": {"passed_count": 7, "failed_count": 1, "skipped_count": 0, "passed_tests": ["listtags", "listreporters", "listtests", "notest", "filteredsection-1", "filteredsection-2", "listtestnamesonly"], "failed_tests": ["approvaltests"], "skipped_tests": []}, "fix_patch_result": {"passed_count": 10, "failed_count": 0, "skipped_count": 0, "passed_tests": ["approvaltests", "noassertions", "runtests", "listtags", "listreporters", "listtests", "notest", "filteredsection-1", "filteredsection-2", "listtestnamesonly"], "failed_tests": [], "skipped_tests": []}, "instance_id": "catchorg__Catch2-1608"}
{"org": "catchorg", "repo": "Catch2", "number": 1448, "state": "closed", "title": "Fix CAPTURE macro for nontrivial uses", "body": "The previous implemetation was just plain broken for most of\r\npossible uses, the new one should work (even though it is ugly\r\nas all hell, and should be improved ASAP).\r\n\r\nFixes #1436\r\n\r\n", "base": {"label": "catchorg:master", "ref": "master", "sha": "62460fafe6b54c3173bc5cbc46d05a5f071017ff"}, "resolved_issues": [{"number": 1436, "title": "Capturer destructor asserts due to bad expression parsing", "body": "The following asserts:\r\n\r\n```\r\nTEST_CASE(\"Explodes\")\r\n{\r\n    int a = 1;\r\n    int b = 2;\r\n    CAPTURE(a + b);\r\n    REQUIRE(false);\r\n}\r\n```\r\n\r\nThe following does not:\r\n```\r\nTEST_CASE(\"Works\")\r\n{\r\n    int a = 1;\r\n    int b = 2;\r\n    CAPTURE(a+b);\r\n    REQUIRE(false);\r\n}\r\n```\r\n\r\nThe assertion that fires:\r\nhttps://github.com/catchorg/Catch2/blame/1cdaa48a0b20e28ee32553070700b86557f9619d/include/internal/catch_message.cpp#L79\r\n\r\nThe issue appears to have been caused here: https://github.com/catchorg/Catch2/blame/1cdaa48a0b20e28ee32553070700b86557f9619d/include/internal/catch_message.cpp#L66\r\n\r\n"}], "fix_patch": "diff --git a/docs/logging.md b/docs/logging.md\nindex 39ae5c7ac3..423ce6a878 100644\n--- a/docs/logging.md\n+++ b/docs/logging.md\n@@ -57,20 +57,37 @@ The message is reported and the test case fails.\n \n AS `FAIL`, but does not abort the test\n \n-## Quickly capture a variable value\n+## Quickly capture value of variables or expressions\n \n-**CAPTURE(** _expression_ **)**\n+**CAPTURE(** _expression1_, _expression2_, ... **)**\n \n-Sometimes you just want to log the name and value of a variable. While you can easily do this with the INFO macro, above, as a convenience the CAPTURE macro handles the stringising of the variable name for you (actually it works with any expression, not just variables).\n+Sometimes you just want to log a value of variable, or expression. For\n+convenience, we provide the `CAPTURE` macro, that can take a variable,\n+or an expression, and prints out that variable/expression and its value\n+at the time of capture.\n \n-E.g.\n-```c++\n-CAPTURE( theAnswer );\n+e.g. `CAPTURE( theAnswer );` will log message \"theAnswer := 42\", while\n+```cpp\n+int a = 1, b = 2, c = 3;\n+CAPTURE( a, b, c, a + b, c > b, a == 1);\n+```\n+will log a total of 6 messages:\n+```\n+a := 1\n+b := 2\n+c := 3\n+a + b := 3\n+c > b := true\n+a == 1 := true\n ```\n \n-This would log something like:\n+You can also capture expressions that use commas inside parentheses\n+(e.g. function calls), brackets, or braces (e.g. initializers). To\n+properly capture expression that contains template parameters list\n+(in other words, it contains commas between angle brackets), you need\n+to enclose the expression inside parentheses:\n+`CAPTURE( (std::pair<int, int>{1, 2}) );`\n \n-<pre>\"theAnswer := 42\"</pre>\n \n ---\n \ndiff --git a/include/internal/catch_message.cpp b/include/internal/catch_message.cpp\nindex df905bf6b4..98a4dae119 100644\n--- a/include/internal/catch_message.cpp\n+++ b/include/internal/catch_message.cpp\n@@ -11,6 +11,7 @@\n #include \"catch_uncaught_exceptions.h\"\n \n #include <cassert>\n+#include <stack>\n \n namespace Catch {\n \n@@ -60,19 +61,48 @@ namespace Catch {\n \n \n     Capturer::Capturer( StringRef macroName, SourceLineInfo const& lineInfo, ResultWas::OfType resultType, StringRef names ) {\n-        auto start = std::string::npos;\n-        for( size_t pos = 0; pos <= names.size(); ++pos ) {\n+        auto trimmed = [&] (size_t start, size_t end) {\n+            while (names[start] == ',' || isspace(names[start])) {\n+                ++start;\n+            }\n+            while (names[end] == ',' || isspace(names[end])) {\n+                --end;\n+            }\n+            return names.substr(start, end - start + 1);\n+        };\n+\n+        size_t start = 0;\n+        std::stack<char> openings;\n+        for (size_t pos = 0; pos < names.size(); ++pos) {\n             char c = names[pos];\n-            if( pos == names.size() || c == ' ' || c == '\\t' || c == ',' || c == ']' ) {\n-                if( start != std::string::npos ) {\n-                    m_messages.push_back( MessageInfo( macroName, lineInfo, resultType ) );\n-                    m_messages.back().message = names.substr( start, pos-start) + \" := \";\n-                    start = std::string::npos;\n+            switch (c) {\n+            case '[':\n+            case '{':\n+            case '(':\n+            // It is basically impossible to disambiguate between\n+            // comparison and start of template args in this context\n+//            case '<':\n+                openings.push(c);\n+                break;\n+            case ']':\n+            case '}':\n+            case ')':\n+//           case '>':\n+                openings.pop();\n+                break;\n+            case ',':\n+                if (start != pos && openings.size() == 0) {\n+                    m_messages.emplace_back(macroName, lineInfo, resultType);\n+                    m_messages.back().message = trimmed(start, pos);\n+                    m_messages.back().message += \" := \";\n+                    start = pos;\n                 }\n             }\n-            else if( c != '[' && c != ']' && start == std::string::npos )\n-                start = pos;\n         }\n+        assert(openings.size() == 0 && \"Mismatched openings\");\n+        m_messages.emplace_back(macroName, lineInfo, resultType);\n+        m_messages.back().message = trimmed(start, names.size() - 1);\n+        m_messages.back().message += \" := \";\n     }\n     Capturer::~Capturer() {\n         if ( !uncaught_exceptions() ){\n@@ -82,7 +112,7 @@ namespace Catch {\n         }\n     }\n \n-    void Capturer::captureValue( size_t index, StringRef value ) {\n+    void Capturer::captureValue( size_t index, std::string const& value ) {\n         assert( index < m_messages.size() );\n         m_messages[index].message += value;\n         m_resultCapture.pushScopedMessage( m_messages[index] );\ndiff --git a/include/internal/catch_message.h b/include/internal/catch_message.h\nindex 73f9efd162..e81069bfb8 100644\n--- a/include/internal/catch_message.h\n+++ b/include/internal/catch_message.h\n@@ -77,16 +77,16 @@ namespace Catch {\n         Capturer( StringRef macroName, SourceLineInfo const& lineInfo, ResultWas::OfType resultType, StringRef names );\n         ~Capturer();\n \n-        void captureValue( size_t index, StringRef value );\n+        void captureValue( size_t index, std::string const& value );\n \n         template<typename T>\n-        void captureValues( size_t index, T&& value ) {\n+        void captureValues( size_t index, T const& value ) {\n             captureValue( index, Catch::Detail::stringify( value ) );\n         }\n \n         template<typename T, typename... Ts>\n-        void captureValues( size_t index, T&& value, Ts&&... values ) {\n-            captureValues( index, value );\n+        void captureValues( size_t index, T const& value, Ts const&... values ) {\n+            captureValue( index, Catch::Detail::stringify(value) );\n             captureValues( index+1, values... );\n         }\n     };\ndiff --git a/projects/SelfTest/Baselines/compact.sw.approved.txt b/projects/SelfTest/Baselines/compact.sw.approved.txt\nindex 496ead9106..1b32b42e96 100644\n--- a/projects/SelfTest/Baselines/compact.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/compact.sw.approved.txt\n@@ -228,6 +228,8 @@ Approx.tests.cpp:<line number>: passed: NAN != Approx(NAN) for: nanf != Approx(\n Approx.tests.cpp:<line number>: passed: !(NAN == Approx(NAN)) for: !(nanf == Approx( nan ))\n Tricky.tests.cpp:<line number>: passed: y.v == 0 for: 0 == 0\n Tricky.tests.cpp:<line number>: passed: 0 == y.v for: 0 == 0\n+Message.tests.cpp:<line number>: passed: with 7 messages: 'a := 1' and 'b := 2' and 'c := 3' and 'a + b := 3' and 'a+b := 3' and 'c > b := true' and 'a == 1 := true'\n+Message.tests.cpp:<line number>: passed: with 7 messages: 'std::vector<int>{1, 2, 3}[0, 1, 2] := 3' and 'std::vector<int>{1, 2, 3}[(0, 1)] := 2' and 'std::vector<int>{1, 2, 3}[0] := 1' and '(helper_1436<int, int>{12, -12}) := { 12, -12 }' and '(helper_1436<int, int>(-12, 12)) := { -12, 12 }' and '(1, 2) := 2' and '(2, 3) := 3'\n ToStringGeneral.tests.cpp:<line number>: passed: true with 1 message: 'i := 2'\n ToStringGeneral.tests.cpp:<line number>: passed: true with 1 message: '3'\n ToStringGeneral.tests.cpp:<line number>: passed: tab == '\\t' for: '\\t' == '\\t'\ndiff --git a/projects/SelfTest/Baselines/console.std.approved.txt b/projects/SelfTest/Baselines/console.std.approved.txt\nindex f48a98ec84..5e82417e30 100644\n--- a/projects/SelfTest/Baselines/console.std.approved.txt\n+++ b/projects/SelfTest/Baselines/console.std.approved.txt\n@@ -1126,6 +1126,6 @@ due to unexpected exception with message:\n   Why would you throw a std::string?\n \n ===============================================================================\n-test cases:  226 |  170 passed |  52 failed |  4 failed as expected\n-assertions: 1308 | 1176 passed | 111 failed | 21 failed as expected\n+test cases:  228 |  172 passed |  52 failed |  4 failed as expected\n+assertions: 1310 | 1178 passed | 111 failed | 21 failed as expected\n \ndiff --git a/projects/SelfTest/Baselines/console.sw.approved.txt b/projects/SelfTest/Baselines/console.sw.approved.txt\nindex e99ea050c9..286384258b 100644\n--- a/projects/SelfTest/Baselines/console.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/console.sw.approved.txt\n@@ -2108,6 +2108,38 @@ Tricky.tests.cpp:<line number>: PASSED:\n with expansion:\n   0 == 0\n \n+-------------------------------------------------------------------------------\n+CAPTURE can deal with complex expressions\n+-------------------------------------------------------------------------------\n+Message.tests.cpp:<line number>\n+...............................................................................\n+\n+Message.tests.cpp:<line number>: PASSED:\n+with messages:\n+  a := 1\n+  b := 2\n+  c := 3\n+  a + b := 3\n+  a+b := 3\n+  c > b := true\n+  a == 1 := true\n+\n+-------------------------------------------------------------------------------\n+CAPTURE can deal with complex expressions involving commas\n+-------------------------------------------------------------------------------\n+Message.tests.cpp:<line number>\n+...............................................................................\n+\n+Message.tests.cpp:<line number>: PASSED:\n+with messages:\n+  std::vector<int>{1, 2, 3}[0, 1, 2] := 3\n+  std::vector<int>{1, 2, 3}[(0, 1)] := 2\n+  std::vector<int>{1, 2, 3}[0] := 1\n+  (helper_1436<int, int>{12, -12}) := { 12, -12 }\n+  (helper_1436<int, int>(-12, 12)) := { -12, 12 }\n+  (1, 2) := 2\n+  (2, 3) := 3\n+\n -------------------------------------------------------------------------------\n Capture and info messages\n   Capture should stringify like assertions\n@@ -10432,6 +10464,6 @@ Misc.tests.cpp:<line number>\n Misc.tests.cpp:<line number>: PASSED:\n \n ===============================================================================\n-test cases:  226 |  157 passed |  65 failed |  4 failed as expected\n-assertions: 1322 | 1176 passed | 125 failed | 21 failed as expected\n+test cases:  228 |  159 passed |  65 failed |  4 failed as expected\n+assertions: 1324 | 1178 passed | 125 failed | 21 failed as expected\n \ndiff --git a/projects/SelfTest/Baselines/junit.sw.approved.txt b/projects/SelfTest/Baselines/junit.sw.approved.txt\nindex 5984b3db6b..cb03cdb790 100644\n--- a/projects/SelfTest/Baselines/junit.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/junit.sw.approved.txt\n@@ -1,7 +1,7 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <testsuitesloose text artifact\n >\n-  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"109\" tests=\"1323\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n+  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"109\" tests=\"1325\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n     <testcase classname=\"<exe-name>.global\" name=\"# A test name that starts with a #\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"#1005: Comparing pointer to int and long (NULL can be either on various systems)\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"#1027\" time=\"{duration}\"/>\n@@ -141,6 +141,8 @@ Exception.tests.cpp:<line number>\n     <testcase classname=\"<exe-name>.global\" name=\"Assertions then sections/A section/Another other section\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Assorted miscellaneous tests\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Bitfields can be captured (#1027)\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"CAPTURE can deal with complex expressions\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"CAPTURE can deal with complex expressions involving commas\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Capture and info messages/Capture should stringify like assertions\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Capture and info messages/Info should NOT stringify the way assertions do\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Character pretty printing/Specifically escaped\" time=\"{duration}\"/>\ndiff --git a/projects/SelfTest/Baselines/xml.sw.approved.txt b/projects/SelfTest/Baselines/xml.sw.approved.txt\nindex d89b4e18ae..7e02b772ea 100644\n--- a/projects/SelfTest/Baselines/xml.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/xml.sw.approved.txt\n@@ -1986,6 +1986,54 @@\n       </Expression>\n       <OverallResult success=\"true\"/>\n     </TestCase>\n+    <TestCase name=\"CAPTURE can deal with complex expressions\" tags=\"[capture][messages]\" filename=\"projects/<exe-name>/UsageTests/Message.tests.cpp\" >\n+      <Info>\n+        a := 1\n+      </Info>\n+      <Info>\n+        b := 2\n+      </Info>\n+      <Info>\n+        c := 3\n+      </Info>\n+      <Info>\n+        a + b := 3\n+      </Info>\n+      <Info>\n+        a+b := 3\n+      </Info>\n+      <Info>\n+        c > b := true\n+      </Info>\n+      <Info>\n+        a == 1 := true\n+      </Info>\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n+    <TestCase name=\"CAPTURE can deal with complex expressions involving commas\" tags=\"[capture][messages]\" filename=\"projects/<exe-name>/UsageTests/Message.tests.cpp\" >\n+      <Info>\n+        std::vector&lt;int>{1, 2, 3}[0, 1, 2] := 3\n+      </Info>\n+      <Info>\n+        std::vector&lt;int>{1, 2, 3}[(0, 1)] := 2\n+      </Info>\n+      <Info>\n+        std::vector&lt;int>{1, 2, 3}[0] := 1\n+      </Info>\n+      <Info>\n+        (helper_1436&lt;int, int>{12, -12}) := { 12, -12 }\n+      </Info>\n+      <Info>\n+        (helper_1436&lt;int, int>(-12, 12)) := { -12, 12 }\n+      </Info>\n+      <Info>\n+        (1, 2) := 2\n+      </Info>\n+      <Info>\n+        (2, 3) := 3\n+      </Info>\n+      <OverallResult success=\"true\"/>\n+    </TestCase>\n     <TestCase name=\"Capture and info messages\" filename=\"projects/<exe-name>/UsageTests/ToStringGeneral.tests.cpp\" >\n       <Section name=\"Capture should stringify like assertions\" filename=\"projects/<exe-name>/UsageTests/ToStringGeneral.tests.cpp\" >\n         <Info>\n@@ -12051,7 +12099,7 @@ loose text artifact\n       </Section>\n       <OverallResult success=\"true\"/>\n     </TestCase>\n-    <OverallResults successes=\"1176\" failures=\"126\" expectedFailures=\"21\"/>\n+    <OverallResults successes=\"1178\" failures=\"126\" expectedFailures=\"21\"/>\n   </Group>\n-  <OverallResults successes=\"1176\" failures=\"125\" expectedFailures=\"21\"/>\n+  <OverallResults successes=\"1178\" failures=\"125\" expectedFailures=\"21\"/>\n </Catch>\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/Message.tests.cpp b/projects/SelfTest/UsageTests/Message.tests.cpp\nindex f3ac02a1fa..002fb875ae 100644\n--- a/projects/SelfTest/UsageTests/Message.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Message.tests.cpp\n@@ -9,10 +9,6 @@\n #include \"catch.hpp\"\n #include <iostream>\n \n-#ifdef __clang__\n-#pragma clang diagnostic ignored \"-Wc++98-compat-pedantic\"\n-#endif\n-\n TEST_CASE( \"INFO and WARN do not abort tests\", \"[messages][.]\" ) {\n     INFO( \"this is a \" << \"message\" );    // This should output the message if a failure occurs\n     WARN( \"this is a \" << \"warning\" );    // This should always output the message but then continue\n@@ -135,3 +131,60 @@ TEST_CASE( \"Pointers can be converted to strings\", \"[messages][.][approvals]\" )\n     WARN( \"actual address of p: \" << &p );\n     WARN( \"toString(p): \" << ::Catch::Detail::stringify( &p ) );\n }\n+\n+TEST_CASE( \"CAPTURE can deal with complex expressions\", \"[messages][capture]\" ) {\n+    int a = 1;\n+    int b = 2;\n+    int c = 3;\n+    CAPTURE( a, b, c, a + b, a+b, c > b, a == 1 );\n+    SUCCEED();\n+}\n+\n+#ifdef __clang__\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-Wunused-value\" // In (1, 2), the \"1\" is unused ...\n+#endif\n+#ifdef __GNUC__\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wunused-value\" // All the comma operators are side-effect free\n+#endif\n+#ifdef _MSC_VER\n+#pragma warning(push)\n+#pragma warning(disable:4709) // comma in indexing operator\n+#endif\n+\n+template <typename T1, typename T2>\n+struct helper_1436 {\n+    helper_1436(T1 t1, T2 t2):\n+        t1{ t1 },\n+        t2{ t2 }\n+    {}\n+    T1 t1;\n+    T2 t2;\n+};\n+\n+template <typename T1, typename T2>\n+std::ostream& operator<<(std::ostream& out, helper_1436<T1, T2> const& helper) {\n+    out << \"{ \" << helper.t1 << \", \" << helper.t2 << \" }\";\n+    return out;\n+}\n+\n+TEST_CASE(\"CAPTURE can deal with complex expressions involving commas\", \"[messages][capture]\") {\n+    CAPTURE(std::vector<int>{1, 2, 3}[0, 1, 2],\n+            std::vector<int>{1, 2, 3}[(0, 1)],\n+            std::vector<int>{1, 2, 3}[0]);\n+    CAPTURE((helper_1436<int, int>{12, -12}),\n+            (helper_1436<int, int>(-12, 12)));\n+    CAPTURE( (1, 2), (2, 3) );\n+    SUCCEED();\n+}\n+\n+#ifdef __clang__\n+#pragma clang diagnostic pop\n+#endif\n+#ifdef __GNUC__\n+#pragma GCC diagnostic pop\n+#endif\n+#ifdef _MSC_VER\n+#pragma warning(pop)\n+#endif\n", "fixed_tests": {"approvaltests": {"run": "PASS", "test": "FAIL", "fix": "PASS"}, "noassertions": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "p2p_tests": {"listtags": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "listtests": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "notest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "listtestnamesonly": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "listreporters": {"run": "PASS", "test": "PASS", "fix": "PASS"}}, "f2p_tests": {"approvaltests": {"run": "PASS", "test": "FAIL", "fix": "PASS"}}, "s2p_tests": {}, "n2p_tests": {"noassertions": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "run_result": {"passed_count": 8, "failed_count": 0, "skipped_count": 0, "passed_tests": ["approvaltests", "noassertions", "runtests", "listtags", "listreporters", "listtests", "notest", "listtestnamesonly"], "failed_tests": [], "skipped_tests": []}, "test_patch_result": {"passed_count": 5, "failed_count": 1, "skipped_count": 0, "passed_tests": ["listtags", "listreporters", "listtests", "notest", "listtestnamesonly"], "failed_tests": ["approvaltests"], "skipped_tests": []}, "fix_patch_result": {"passed_count": 8, "failed_count": 0, "skipped_count": 0, "passed_tests": ["approvaltests", "noassertions", "runtests", "listtags", "listreporters", "listtests", "notest", "listtestnamesonly"], "failed_tests": [], "skipped_tests": []}, "instance_id": "catchorg__Catch2-1448"}
{"org": "catchorg", "repo": "Catch2", "number": 1422, "state": "closed", "title": "Command line parser should verify whether reporter is registered", "body": "<!--\r\nPlease do not submit pull requests changing the `version.hpp`\r\nor the single-include `catch.hpp` file, these are changed\r\nonly when a new release is made.\r\n\r\nBefore submitting a PR you should probably read the contributor documentation\r\nat docs/contributing.md. It will tell you how to properly test your changes.\r\n-->\r\n\r\n\r\n## Description\r\n<!--\r\nDescribe the what and the why of your pull request. Remember that these two\r\nare usually a bit different. As an example, if you have made various changes\r\nto decrease the number of new strings allocated, thats what. The why probably\r\nwas that you have a large set of tests and found that this speeds them up.\r\n-->\r\nRelated to #1351 \r\n\r\nIntroduced check during option parsing to validate whether reporter provided by the user is one of registered ones.\r\n\r\n## GitHub Issues\r\n<!-- \r\nIf this PR was motivated by some existing issues, reference them here.\r\n\r\nIf it is a simple bug-fix, please also add a line like 'Closes #123'\r\nto your commit message, so that it is automatically closed.\r\nIf it is not, don't, as it might take several iterations for a feature\r\nto be done properly. If in doubt, leave it open and reference it in the\r\nPR itself, so that maintainers can decide.\r\n-->\r\nRelated to #1351 \r\n\r\nI don't know why regression didn't start ", "base": {"label": "catchorg:master", "ref": "master", "sha": "1faccd601d904a951142d8fba82914a8325b764e"}, "resolved_issues": [{"number": 1351, "title": "unregistered reporter is not considered a command line error", "body": "## Description\r\nwhen `session.applyCommandLine()` is called with an unregistered reporter, the function simply returns 0 and the later call to `session.run()` just outputs a text: `No reporter registered with name: 'foo'`\r\n\r\n### Steps to reproduce\r\n    int main()\r\n    {\r\n      const char* argv[] = { \"runner\", \"-r foo\" };\r\n\r\n      Catch::Session session;\r\n\r\n      const int command_line_errors = session.applyCommandLine( std::size( argv ), const_cast< char** >( argv ) );\r\n\r\n      if ( command_line_errors == 0 )\r\n      {\r\n        session.run();\r\n      }\r\n      else\r\n      {\r\n        Catch::cerr() << \"Error parsing following command line: \" << *std::prev( std::end( argv ) ) << std::endl;\r\n      }\r\n    }\r\n\r\nI would expect the parser to recognize this as command line argument error.\r\n\r\n* Catch version: v2.3\r\n* Operating System: No Operation System; bare metal\r\n* Compiler+version: gcc version 7.3.1 20180622 (release) [ARM/embedded-7-branch revision 261907] (GNU Tools for Arm Embedded Processors 7-2018-q2-update) "}], "fix_patch": "diff --git a/include/internal/catch_commandline.cpp b/include/internal/catch_commandline.cpp\nindex c57b7ed74d..66759ebbf1 100644\n--- a/include/internal/catch_commandline.cpp\n+++ b/include/internal/catch_commandline.cpp\n@@ -10,6 +10,9 @@\n \n #include \"catch_string_manip.h\"\n \n+#include \"catch_interfaces_registry_hub.h\"\n+#include \"catch_interfaces_reporter.h\"\n+\n #include <fstream>\n #include <ctime>\n \n@@ -105,6 +108,18 @@ namespace Catch {\n                 return ParserResult::runtimeError( \"Unrecognised verbosity, '\" + verbosity + \"'\" );\n             return ParserResult::ok( ParseResultType::Matched );\n         };\n+        auto const setReporter = [&]( std::string const& reporter ) {\n+            IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();\n+\n+            auto lcReporter = toLower( reporter );\n+            auto result = factories.find( lcReporter );\n+\n+            if( factories.end() != result )\n+                config.reporterName = lcReporter;\n+            else\n+                return ParserResult::runtimeError( \"Unrecognized reporter, '\" + reporter + \"'. Check available with --list-reporters\" );\n+            return ParserResult::ok( ParseResultType::Matched );\n+        };\n \n         auto cli\n             = ExeName( config.processName )\n@@ -130,7 +145,7 @@ namespace Catch {\n             | Opt( config.outputFilename, \"filename\" )\n                 [\"-o\"][\"--out\"]\n                 ( \"output filename\" )\n-            | Opt( config.reporterName, \"name\" )\n+            | Opt( setReporter, \"name\" )\n                 [\"-r\"][\"--reporter\"]\n                 ( \"reporter to use (defaults to console)\" )\n             | Opt( config.name, \"name\" )\ndiff --git a/include/internal/catch_list.cpp b/include/internal/catch_list.cpp\nindex 3b0e33f112..6010ec15d2 100644\n--- a/include/internal/catch_list.cpp\n+++ b/include/internal/catch_list.cpp\n@@ -124,7 +124,7 @@ namespace Catch {\n         return tagCounts.size();\n     }\n \n-    std::size_t listReporters( Config const& /*config*/ ) {\n+    std::size_t listReporters() {\n         Catch::cout() << \"Available reporters:\\n\";\n         IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();\n         std::size_t maxNameLen = 0;\n@@ -155,7 +155,7 @@ namespace Catch {\n         if( config.listTags() )\n             listedCount = listedCount.valueOr(0) + listTags( config );\n         if( config.listReporters() )\n-            listedCount = listedCount.valueOr(0) + listReporters( config );\n+            listedCount = listedCount.valueOr(0) + listReporters();\n         return listedCount;\n     }\n \ndiff --git a/include/internal/catch_list.h b/include/internal/catch_list.h\nindex 4bc96ec517..bd29d97066 100644\n--- a/include/internal/catch_list.h\n+++ b/include/internal/catch_list.h\n@@ -29,7 +29,7 @@ namespace Catch {\n \n     std::size_t listTags( Config const& config );\n \n-    std::size_t listReporters( Config const& /*config*/ );\n+    std::size_t listReporters();\n     \n     Option<std::size_t> list( Config const& config );\n \ndiff --git a/projects/SelfTest/Baselines/compact.sw.approved.txt b/projects/SelfTest/Baselines/compact.sw.approved.txt\nindex 767cb567a4..2b1b917a87 100644\n--- a/projects/SelfTest/Baselines/compact.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/compact.sw.approved.txt\n@@ -707,6 +707,8 @@ CmdLine.tests.cpp:<line number>: passed: config.reporterName == \"xml\" for: \"xml\"\n CmdLine.tests.cpp:<line number>: passed: cli.parse({\"test\", \"--reporter\", \"junit\"}) for: {?}\n CmdLine.tests.cpp:<line number>: passed: config.reporterName == \"junit\" for: \"junit\" == \"junit\"\n CmdLine.tests.cpp:<line number>: passed: !(cli.parse({ \"test\", \"-r\", \"xml\", \"-r\", \"junit\" })) for: !{?}\n+CmdLine.tests.cpp:<line number>: passed: !result for: true\n+CmdLine.tests.cpp:<line number>: passed: result.errorMessage(), Contains(\"Unrecognized reporter\") for: \"Unrecognized reporter, 'unsupported'. Check available with --list-reporters\" contains: \"Unrecognized reporter\"\n CmdLine.tests.cpp:<line number>: passed: cli.parse({\"test\", \"-b\"}) for: {?}\n CmdLine.tests.cpp:<line number>: passed: config.shouldDebugBreak == true for: true == true\n CmdLine.tests.cpp:<line number>: passed: cli.parse({\"test\", \"--break\"}) for: {?}\ndiff --git a/projects/SelfTest/Baselines/console.std.approved.txt b/projects/SelfTest/Baselines/console.std.approved.txt\nindex 525a193c2d..7d3a4db4fa 100644\n--- a/projects/SelfTest/Baselines/console.std.approved.txt\n+++ b/projects/SelfTest/Baselines/console.std.approved.txt\n@@ -1099,5 +1099,5 @@ due to unexpected exception with message:\n \n ===============================================================================\n test cases:  215 |  162 passed |  49 failed |  4 failed as expected\n-assertions: 1231 | 1102 passed | 108 failed | 21 failed as expected\n+assertions: 1233 | 1104 passed | 108 failed | 21 failed as expected\n \ndiff --git a/projects/SelfTest/Baselines/console.sw.approved.txt b/projects/SelfTest/Baselines/console.sw.approved.txt\nindex 6642a06e83..3085960ed8 100644\n--- a/projects/SelfTest/Baselines/console.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/console.sw.approved.txt\n@@ -5977,6 +5977,27 @@ PASSED:\n with expansion:\n   !{?}\n \n+-------------------------------------------------------------------------------\n+Process can be configured on command line\n+  reporter\n+  must match one of the available ones\n+-------------------------------------------------------------------------------\n+CmdLine.tests.cpp:<line number>\n+...............................................................................\n+\n+CmdLine.tests.cpp:<line number>:\n+PASSED:\n+  CHECK( !result )\n+with expansion:\n+  true\n+\n+CmdLine.tests.cpp:<line number>:\n+PASSED:\n+  REQUIRE_THAT( result.errorMessage(), Contains(\"Unrecognized reporter\") )\n+with expansion:\n+  \"Unrecognized reporter, 'unsupported'. Check available with --list-reporters\"\n+  contains: \"Unrecognized reporter\"\n+\n -------------------------------------------------------------------------------\n Process can be configured on command line\n   debugger\n@@ -10865,5 +10886,5 @@ PASSED:\n \n ===============================================================================\n test cases:  215 |  149 passed |  62 failed |  4 failed as expected\n-assertions: 1245 | 1102 passed | 122 failed | 21 failed as expected\n+assertions: 1247 | 1104 passed | 122 failed | 21 failed as expected\n \ndiff --git a/projects/SelfTest/Baselines/junit.sw.approved.txt b/projects/SelfTest/Baselines/junit.sw.approved.txt\nindex f364448511..0b726c8d51 100644\n--- a/projects/SelfTest/Baselines/junit.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/junit.sw.approved.txt\n@@ -1,7 +1,7 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <testsuitesloose text artifact\n >\n-  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"106\" tests=\"1246\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n+  <testsuite name=\"<exe-name>\" errors=\"17\" failures=\"106\" tests=\"1248\" hostname=\"tbd\" time=\"{duration}\" timestamp=\"{iso8601-timestamp}\">\n     <testcase classname=\"<exe-name>.global\" name=\"# A test name that starts with a #\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"#1005: Comparing pointer to int and long (NULL can be either on various systems)\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"#1027\" time=\"{duration}\"/>\n@@ -489,6 +489,7 @@ Message.tests.cpp:<line number>\n     <testcase classname=\"<exe-name>.global\" name=\"Process can be configured on command line/reporter/-r/xml\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Process can be configured on command line/reporter/--reporter/junit\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Process can be configured on command line/reporter/Only one reporter is accepted\" time=\"{duration}\"/>\n+    <testcase classname=\"<exe-name>.global\" name=\"Process can be configured on command line/reporter/must match one of the available ones\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Process can be configured on command line/debugger/-b\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Process can be configured on command line/debugger/--break\" time=\"{duration}\"/>\n     <testcase classname=\"<exe-name>.global\" name=\"Process can be configured on command line/abort/-a aborts after first failure\" time=\"{duration}\"/>\ndiff --git a/projects/SelfTest/Baselines/xml.sw.approved.txt b/projects/SelfTest/Baselines/xml.sw.approved.txt\nindex 02509e0831..f573f58529 100644\n--- a/projects/SelfTest/Baselines/xml.sw.approved.txt\n+++ b/projects/SelfTest/Baselines/xml.sw.approved.txt\n@@ -6237,6 +6237,28 @@\n         </Section>\n         <OverallResults successes=\"1\" failures=\"0\" expectedFailures=\"0\"/>\n       </Section>\n+      <Section name=\"reporter\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n+        <Section name=\"must match one of the available ones\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n+          <Expression success=\"true\" type=\"CHECK\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n+            <Original>\n+              !result\n+            </Original>\n+            <Expanded>\n+              true\n+            </Expanded>\n+          </Expression>\n+          <Expression success=\"true\" type=\"REQUIRE_THAT\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n+            <Original>\n+              result.errorMessage(), Contains(\"Unrecognized reporter\")\n+            </Original>\n+            <Expanded>\n+              \"Unrecognized reporter, 'unsupported'. Check available with --list-reporters\" contains: \"Unrecognized reporter\"\n+            </Expanded>\n+          </Expression>\n+          <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+        </Section>\n+        <OverallResults successes=\"2\" failures=\"0\" expectedFailures=\"0\"/>\n+      </Section>\n       <Section name=\"debugger\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n         <Section name=\"-b\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n           <Expression success=\"true\" type=\"CHECK\" filename=\"projects/<exe-name>/IntrospectiveTests/CmdLine.tests.cpp\" >\n@@ -11336,7 +11358,7 @@ loose text artifact\n       </Section>\n       <OverallResult success=\"true\"/>\n     </TestCase>\n-    <OverallResults successes=\"1102\" failures=\"123\" expectedFailures=\"21\"/>\n+    <OverallResults successes=\"1104\" failures=\"123\" expectedFailures=\"21\"/>\n   </Group>\n-  <OverallResults successes=\"1102\" failures=\"122\" expectedFailures=\"21\"/>\n+  <OverallResults successes=\"1104\" failures=\"122\" expectedFailures=\"21\"/>\n </Catch>\n", "test_patch": "diff --git a/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp b/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp\nindex cb635eade9..9b5b0ed7c8 100644\n--- a/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp\n+++ b/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp\n@@ -280,7 +280,6 @@ TEST_CASE( \"Process can be configured on command line\", \"[config][command-line]\"\n         CHECK(config.processName == \"\");\n     }\n \n-\n     SECTION(\"default - no arguments\") {\n         auto result = cli.parse({\"test\"});\n         CHECK(result);\n@@ -345,8 +344,15 @@ TEST_CASE( \"Process can be configured on command line\", \"[config][command-line]\"\n         SECTION(\"Only one reporter is accepted\") {\n             REQUIRE_FALSE(cli.parse({ \"test\", \"-r\", \"xml\", \"-r\", \"junit\" }));\n         }\n-    }\n+        SECTION(\"must match one of the available ones\") {\n+            auto result = cli.parse({\"test\", \"--reporter\", \"unsupported\"});\n+            CHECK(!result);\n \n+#ifndef CATCH_CONFIG_DISABLE_MATCHERS\n+            REQUIRE_THAT(result.errorMessage(), Contains(\"Unrecognized reporter\"));\n+#endif\n+        }\n+    }\n \n     SECTION(\"debugger\") {\n         SECTION(\"-b\") {\n", "fixed_tests": {"approvaltests": {"run": "PASS", "test": "FAIL", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "FAIL", "fix": "PASS"}}, "p2p_tests": {"noassertions": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "listtags": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "listtests": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "notest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "listtestnamesonly": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "listreporters": {"run": "PASS", "test": "PASS", "fix": "PASS"}}, "f2p_tests": {"approvaltests": {"run": "PASS", "test": "FAIL", "fix": "PASS"}, "runtests": {"run": "PASS", "test": "FAIL", "fix": "PASS"}}, "s2p_tests": {}, "n2p_tests": {}, "run_result": {"passed_count": 8, "failed_count": 0, "skipped_count": 0, "passed_tests": ["approvaltests", "noassertions", "runtests", "listtags", "listreporters", "listtests", "notest", "listtestnamesonly"], "failed_tests": [], "skipped_tests": []}, "test_patch_result": {"passed_count": 6, "failed_count": 2, "skipped_count": 0, "passed_tests": ["noassertions", "listtags", "listreporters", "listtests", "notest", "listtestnamesonly"], "failed_tests": ["runtests", "approvaltests"], "skipped_tests": []}, "fix_patch_result": {"passed_count": 8, "failed_count": 0, "skipped_count": 0, "passed_tests": ["approvaltests", "noassertions", "runtests", "listtags", "listreporters", "listtests", "notest", "listtestnamesonly"], "failed_tests": [], "skipped_tests": []}, "instance_id": "catchorg__Catch2-1422"}
